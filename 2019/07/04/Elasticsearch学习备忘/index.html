<!DOCTYPE html><html><head><meta name="generator" content="Hexo 3.9.0"><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"><title>Elasticsearch学习备忘 | JiGW's Blog</title><meta name="description" content="Elasticsearch学习备忘"><meta name="keywords" content="elasticsearch"><meta name="author" content="Willis J"><meta name="copyright" content="Willis J"><meta name="format-detection" content="telephone=no"><link rel="shortcut icon" href="/img/favicon.ico"><link rel="stylesheet" href="/css/index.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/font-awesome@latest/css/font-awesome.min.css"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Titillium+Web"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.css"><meta http-equiv="x-dns-prefetch-control" content="on"><link rel="canonical" href="https://jigw24.github.io/2019/07/04/Elasticsearch学习备忘/"><meta name="twitter:card" content="summary_large_image"><meta name="twitter:title" content="Elasticsearch学习备忘"><meta name="twitter:description" content="Elasticsearch学习备忘"><meta name="twitter:image" content="https://i.loli.net/2019/07/17/5d2f0b56d170e62593.jpeg"><meta property="og:type" content="article"><meta property="og:title" content="Elasticsearch学习备忘"><meta property="og:url" content="https://jigw24.github.io/2019/07/04/Elasticsearch学习备忘/"><meta property="og:site_name" content="JiGW's Blog"><meta property="og:description" content="Elasticsearch学习备忘"><meta property="og:image" content="https://i.loli.net/2019/07/17/5d2f0b56d170e62593.jpeg"><meta http-equiv="Cache-Control" content="no-transform"><meta http-equiv="Cache-Control" content="no-siteapp"><link rel="prev" title="消息中间件和RabbitMQ相关备忘" href="https://jigw24.github.io/2019/07/04/消息和RabbitMQ/"><link rel="next" title="SpringDataRedis实现缓存问题的解决" href="https://jigw24.github.io/2019/06/18/SpringDataRedis备忘/"><script>var GLOBAL_CONFIG = { 
  root: '/',
  algolia: undefined,
  localSearch: {"path":"search.xml","languages":{"hits_empty":"We didn't find any results for the search: ${query}"}},
  translate: {"defaultEncoding":1,"translateDelay":0,"cookieDomain":"https://jerryc.me/","msgToTraditionalChinese":"繁","msgToSimplifiedChinese":"简"},
  highlight_copy: 'true',
  copy: {
    success: 'Copy successfully',
    error: 'Copy error',
    noSupport: 'The browser does not support'
  },
  bookmark: {
    title: 'Bookmark',
    message_prev: 'Press',
    message_next: 'to bookmark this page'
  },
  runtime_unit: 'days'

  
}</script></head><body><i class="fa fa-arrow-right" id="toggle-sidebar" aria-hidden="true"></i><div class="auto_open" id="sidebar"><div class="sidebar-toc"><div class="sidebar-toc__title">Catalog</div><div class="sidebar-toc__progress"><span class="progress-notice">You've read</span><span class="progress-num">0</span><span class="progress-percentage">%</span><div class="sidebar-toc__progress-bar"></div></div><div class="sidebar-toc__content"><ol class="toc"><li class="toc-item toc-level-2"><a class="toc-link" href="#Elasticsearch学习记录"><span class="toc-number">1.</span> <span class="toc-text">Elasticsearch学习记录</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#与Elasticsearch交互"><span class="toc-number">2.</span> <span class="toc-text">与Elasticsearch交互</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Java-API"><span class="toc-number">2.1.</span> <span class="toc-text">Java API</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#基于HTTP协议"><span class="toc-number">2.2.</span> <span class="toc-text">基于HTTP协议</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#索引-文档"><span class="toc-number">3.</span> <span class="toc-text">索引/文档</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#文档元数据"><span class="toc-number">3.1.</span> <span class="toc-text">文档元数据</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#检索文档"><span class="toc-number">4.</span> <span class="toc-text">检索文档</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#检索"><span class="toc-number">4.1.</span> <span class="toc-text">检索</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#简单搜索"><span class="toc-number">4.2.</span> <span class="toc-text">简单搜索</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用DSL语句查询"><span class="toc-number">4.3.</span> <span class="toc-text">使用DSL语句查询</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#空搜索"><span class="toc-number">4.4.</span> <span class="toc-text">空搜索</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#3-5-多索引，多类型"><span class="toc-number">4.5.</span> <span class="toc-text">3.5.多索引，多类型</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#聚合-aggregations"><span class="toc-number">5.</span> <span class="toc-text">聚合(aggregations)</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#索引知识"><span class="toc-number">6.</span> <span class="toc-text">索引知识</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#创建索引"><span class="toc-number">6.1.</span> <span class="toc-text">创建索引</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#索引映射节（mappings）"><span class="toc-number">6.2.</span> <span class="toc-text">索引映射节（mappings）</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#文档的字段属性"><span class="toc-number">6.3.</span> <span class="toc-text">文档的字段属性</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#字段的数据类型"><span class="toc-number">6.3.1.</span> <span class="toc-text">字段的数据类型</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#字段的公共属性"><span class="toc-number">6.3.2.</span> <span class="toc-text">字段的公共属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#字符串类型常用的其他属性"><span class="toc-number">6.3.3.</span> <span class="toc-text">字符串类型常用的其他属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#数值类型的其他属性"><span class="toc-number">6.3.4.</span> <span class="toc-text">数值类型的其他属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#日期类型的其他属性"><span class="toc-number">6.3.5.</span> <span class="toc-text">日期类型的其他属性</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#多字段（fields）"><span class="toc-number">6.3.6.</span> <span class="toc-text">多字段（fields）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#文档值（doc-values）"><span class="toc-number">6.3.7.</span> <span class="toc-text">文档值（doc_values）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#字段数据（Fielddata）"><span class="toc-number">6.3.8.</span> <span class="toc-text">字段数据（Fielddata）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#存储（store）"><span class="toc-number">6.3.9.</span> <span class="toc-text">存储（store）</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#位置增加间隔（position-increment-gap）"><span class="toc-number">6.3.10.</span> <span class="toc-text">位置增加间隔（position_increment_gap）</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#元字段"><span class="toc-number">6.4.</span> <span class="toc-text">元字段</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#all-字段，可以配置"><span class="toc-number">6.4.1.</span> <span class="toc-text">_all 字段，可以配置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#source-字段，可以配置"><span class="toc-number">6.4.2.</span> <span class="toc-text">_source 字段，可以配置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#routing-字段，可以配置"><span class="toc-number">6.4.3.</span> <span class="toc-text">_routing 字段，可以配置</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#不可配置的元字段"><span class="toc-number">6.4.4.</span> <span class="toc-text">不可配置的元字段</span></a></li></ol></li><li class="toc-item toc-level-3"><a class="toc-link" href="#索引配置节（settings）"><span class="toc-number">6.5.</span> <span class="toc-text">索引配置节（settings）</span></a><ol class="toc-child"><li class="toc-item toc-level-4"><a class="toc-link" href="#配置索引的分片和副本数量"><span class="toc-number">6.5.1.</span> <span class="toc-text">配置索引的分片和副本数量</span></a></li><li class="toc-item toc-level-4"><a class="toc-link" href="#配置分析器（analyzer）"><span class="toc-number">6.5.2.</span> <span class="toc-text">配置分析器（analyzer）</span></a></li></ol></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ElasticSearch-High-Level-REST-文档基本操作"><span class="toc-number">7.</span> <span class="toc-text">ElasticSearch High Level REST  文档基本操作</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#坐标依赖"><span class="toc-number">7.1.</span> <span class="toc-text">坐标依赖</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#创建客户端"><span class="toc-number">7.2.</span> <span class="toc-text">创建客户端</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#索引操作"><span class="toc-number">7.3.</span> <span class="toc-text">索引操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#获取操作"><span class="toc-number">7.4.</span> <span class="toc-text">获取操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#删除操作"><span class="toc-number">7.5.</span> <span class="toc-text">删除操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#更新"><span class="toc-number">7.6.</span> <span class="toc-text">更新</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#查询文档是否存在"><span class="toc-number">7.7.</span> <span class="toc-text">查询文档是否存在</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#Bulk批量操作"><span class="toc-number">7.8.</span> <span class="toc-text">Bulk批量操作</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ElasticSearch-High-Level-REST-搜索查询"><span class="toc-number">8.</span> <span class="toc-text">ElasticSearch High Level REST 搜索查询</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#创建查询请求"><span class="toc-number">8.1.</span> <span class="toc-text">创建查询请求</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SearchHit使用汇总"><span class="toc-number">8.2.</span> <span class="toc-text">SearchHit使用汇总</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#指定排序"><span class="toc-number">8.3.</span> <span class="toc-text">指定排序</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#关闭检索"><span class="toc-number">8.4.</span> <span class="toc-text">关闭检索</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#高亮显示"><span class="toc-number">8.5.</span> <span class="toc-text">高亮显示</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#聚合-分组-操作"><span class="toc-number">8.6.</span> <span class="toc-text">聚合(分组)操作</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#匹配查询"><span class="toc-number">8.7.</span> <span class="toc-text">匹配查询</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#布尔与词条查询"><span class="toc-number">8.8.</span> <span class="toc-text">布尔与词条查询</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#过滤查询"><span class="toc-number">8.9.</span> <span class="toc-text">过滤查询</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ElasticSearch-High-Level-REST-其他功能"><span class="toc-number">9.</span> <span class="toc-text">ElasticSearch High Level REST 其他功能</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#Scroll-滚屏"><span class="toc-number">9.1.</span> <span class="toc-text">Scroll 滚屏</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#多搜索"><span class="toc-number">9.2.</span> <span class="toc-text">多搜索</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#使用模板搜索"><span class="toc-number">9.3.</span> <span class="toc-text">使用模板搜索</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#获取集群信息"><span class="toc-number">9.4.</span> <span class="toc-text">获取集群信息</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#相关博客推荐"><span class="toc-number">10.</span> <span class="toc-text">相关博客推荐</span></a></li></ol></div></div></div><div id="content-outer"><div id="top-container" style="background-image: url(https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/Photo/post.png)"><div id="page-header"><span class="pull-left"> <a class="blog_title" id="site-name" href="/">JiGW's Blog</a></span><div class="open toggle-menu pull-right"><div class="menu-icon-first"></div><div class="menu-icon-second"></div><div class="menu-icon-third"></div></div><span class="pull-right menus"><div class="mobile_author_icon"><img class="lozad" data-src="https://i.loli.net/2019/07/17/5d2f0b56d170e62593.jpeg" onerror="onerror=null;src='/img/friend_404.gif'"><div class="mobile_author-info__description">春寒料峭  善自珍重</div></div><hr><div class="menus_item"><a class="site-page" href="/"><i class="fa-fw fa fa-home"></i><span> 首页</span></a><a class="site-page" href="/archives/"><i class="fa-fw fa fa-archive"></i><span> 时间轴</span></a><a class="site-page" href="/tags/"><i class="fa-fw fa fa-tags"></i><span> 标签</span></a><a class="site-page" href="/categories/"><i class="fa-fw fa fa-folder-open"></i><span> 分类</span></a><a class="site-page" href="/comments/"><i class="fa-fw fa fa-coffee"></i><span> 留言</span></a><a class="site-page" href="/link/"><i class="fa-fw fa fa-link"></i><span> 友链</span></a><a class="site-page" href="/about/"><i class="fa-fw fa fa-heart"></i><span> 关于</span></a><script>document.body.addEventListener('touchstart', function(){ });</script></div></span><span class="pull-right"><a class="site-page social-icon search"><i class="fa fa-search fa-fw"></i><span> Search</span></a></span></div><div id="post-info"><div id="post-title"><div class="posttitle">Elasticsearch学习备忘</div></div><div id="post-meta"><time class="post-meta__date"><i class="fa fa-calendar" aria-hidden="true"></i> Created 2019-07-04<span class="post-meta__separator">|</span><i class="fa fa-history" aria-hidden="true"></i> Updated 2019-07-11</time><span class="post-meta__separator mobile_hidden">|</span><span class="mobile_hidden"><i class="fa fa-inbox post-meta__icon" aria-hidden="true"></i><a class="post-meta__categories" href="/categories/技术栈/">技术栈</a></span></div></div></div><div class="layout layout_post" id="content-inner">   <article id="post"><div class="article-container" id="post-content"><p>本文由zhoulu整理，感谢</p>
<h2 id="Elasticsearch学习记录"><a href="#Elasticsearch学习记录" class="headerlink" title="Elasticsearch学习记录"></a>Elasticsearch学习记录</h2><blockquote>
<p>1、Elasticsearch的特点</p>
<ul>
<li>可以分布式集群，对海量数据进行近实时的处理；</li>
<li>对用户而言，开箱即用,非常简单。如果数据量不大，操作不会太复杂；</li>
<li>具有关系型数据库没有的功能，比如全文检索，同义词处理，相关度排名，复杂数据分析，海量数据的近实时处理；</li>
<li>基于lucene，隐藏了复杂性，提供简单易用的restful api接口、java api接口</li>
</ul>
<p>2、elasticsearch的核心概念</p>
<ul>
<li>Cluster：集群包含多个节点，每个节点属于哪个集群是通过配置来决定的（默认是elasticsearch）</li>
<li>Node：集群中的一个节点，节点默认会自动加入名叫”elasticsearch”的集群。一个elasticsearch服务就是一个节点，比如一台机器启动两个es服务，就有两个节点。</li>
<li>Index:索引，相当于mysql的数据库，包含一堆有相似结构的文档数据。</li>
<li>Type:类型，相当于mysql的表，index中的一个逻辑数据分类。</li>
<li>document:文档，相当于mysql表中的一行记录，是es中的最小数据单元。</li>
<li>shard:分片，单台机器无法存储大量数据，es可以将一个索引中的数据切分为多个shard，分布在多台服务器上存储。</li>
<li>replica:副本，为了防止宕机，shard丢失，所以最小的高可用配置，是2台服务器。</li>
</ul>
</blockquote>
<h2 id="与Elasticsearch交互"><a href="#与Elasticsearch交互" class="headerlink" title="与Elasticsearch交互"></a>与Elasticsearch交互</h2><h3 id="Java-API"><a href="#Java-API" class="headerlink" title="Java API"></a>Java API</h3><ul>
<li><p><strong>节点客户端(node client)：</strong></p>
<p>节点客户端以无数据节点(none data node)身份加入集群，换言之，它自己不存储任何数据，但是它知道数据在集群中的具体位置，并且能够直接转发请求到对应的节点上。</p>
</li>
<li><p><strong>传输客户端(Transport client)：</strong></p>
<p>这个更轻量的传输客户端能够发送请求到远程集群。它自己不加入集群，只是简单转发请求给集群中的节点。</p>
<p>两个Java客户端都通过9300端口与集群交互，使用Elasticsearch传输协议(Elasticsearch Transport Protocol)。集群中的节点之间也通过9300端口进行通信。如果此端口未开放，你的节点将不能组成集群。</p>
<blockquote>
<p><strong>TIP</strong></p>
<p>Java客户端所在的Elasticsearch版本必须与集群中其他节点一致，否则，它们可能互相无法识别。</p>
</blockquote>
<p>关于Java API的更多信息请查看相关章节：<a href="http://www.elasticsearch.org/guide/" target="_blank" rel="noopener">Java API</a></p>
</li>
</ul>
<h3 id="基于HTTP协议"><a href="#基于HTTP协议" class="headerlink" title="基于HTTP协议"></a>基于HTTP协议</h3><ul>
<li><p>==以<strong>JSON</strong>为数据交互格式的<strong>RESTful API</strong>==，通过9200端口的与Elasticsearch进行通信，</p>
<blockquote>
<p>Elasticsearch官方提供了多种程序语言的客户端——Groovy，Javascript， .NET，PHP，Perl，Python，以及Ruby——还有很多由社区提供的客户端和插件，所有这些可以在<a href="http://www.elasticsearch.org/guide/" target="_blank" rel="noopener">文档</a>中找到。</p>
</blockquote>
</li>
<li><p>向Elasticsearch发出的请求的组成部分与其它普通的HTTP请求是一样的：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">curl -X&lt;VERB&gt; <span class="string">'&lt;PROTOCOL&gt;://&lt;HOST&gt;:&lt;PORT&gt;/&lt;PATH&gt;?&lt;QUERY_STRING&gt;'</span> -d <span class="string">'&lt;BODY&gt;'</span></span><br></pre></td></tr></table></figure>

<ul>
<li>VERB HTTP方法：<code>GET</code>, <code>POST</code>, <code>PUT</code>, <code>HEAD</code>,<code>DELETE</code></li>
<li>PROTOCOL http或者https协议（只有在Elasticsearch前面有https代理的时候可用）</li>
<li>HOST Elasticsearch集群中的任何一个节点的主机名，如果是在本地的节点，那么就叫localhost</li>
<li>PORT Elasticsearch HTTP服务所在的端口，默认为9200</li>
<li>PATH API路径（例如_count将返回集群中文档的数量），PATH可以包含多个组件，例如_cluster/stats或者_nodes/stats/jvm</li>
<li>QUERY_STRING一些可选的查询请求参数，例如<code>?pretty</code>参数将使请求返回更加美观易读的JSON数据</li>
<li>BODY 一个JSON格式的请求主体（如果请求需要的话）</li>
</ul>
</li>
</ul>
<p>  举例说明，为了计算集群中的文档数量，我们可以这样做：</p>
  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">curl -XGET <span class="string">'http://localhost:9200/_count?pretty'</span> -d <span class="string">'</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">    "query": &#123;</span></span><br><span class="line"><span class="string">        "match_all": &#123;&#125;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">'</span></span><br></pre></td></tr></table></figure>

<p>  Elasticsearch返回一个类似<code>200 OK</code>的HTTP状态码和JSON格式的响应主体（除了<code>HEAD</code>请求）。上面的请求会得到如下的JSON格式的响应主体：</p>
  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"count"</span> : <span class="number">0</span>,</span><br><span class="line">    <span class="string">"_shards"</span> : &#123;</span><br><span class="line">        <span class="string">"total"</span> : <span class="number">5</span>,</span><br><span class="line">        <span class="string">"successful"</span> : <span class="number">5</span>,</span><br><span class="line">        <span class="string">"failed"</span> : <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>  我们看不到HTTP头是因为我们没有让<code>curl</code>显示它们，如果要显示，使用<code>curl</code>命令后跟<code>-i</code>参数:</p>
  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">curl -i -XGET <span class="string">'localhost:9200/'</span></span><br></pre></td></tr></table></figure>

<p>  一个完整的请求形如：</p>
  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">curl -XGET <span class="string">'localhost:9200/_count?pretty'</span> -d <span class="string">'</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">    "query": &#123;</span></span><br><span class="line"><span class="string">        "match_all": &#123;&#125;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;'</span></span><br></pre></td></tr></table></figure>

<p>  我们将<strong>简写</strong>成这样：</p>
  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">GET /_count</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"query"</span>: &#123;</span><br><span class="line">        <span class="string">"match_all"</span>: &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="索引-文档"><a href="#索引-文档" class="headerlink" title="索引/文档"></a>索引/文档</h2><ul>
<li><p>在Elasticsearch中存储数据的行为就叫做<strong>索引(indexing)</strong>，不过在索引之前，我们需要明确数据应该存储在哪里。</p>
</li>
<li><p>在Elasticsearch中，文档归属于一种<strong>类型(type)</strong> ,而这些类型存在于<strong>索引(index)</strong>中，我们可以画一些简单的对比图来类比传统关系型数据库：</p>
<figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">Relational DB -&gt; Databases -&gt; Tables -&gt; Rows -&gt; Columns</span><br><span class="line">Elasticsearch -&gt; Indices   -&gt; Types  -&gt; Documents -&gt; Fields</span><br></pre></td></tr></table></figure>
</li>
<li><p>Elasticsearch集群可以包含多个<strong>索引(indices)</strong>（数据库），每一个索引可以包含多个<strong>类型(types)</strong>（表），每一个类型包含多个<strong>文档(documents)</strong>（行），然后每个文档包含多个<strong>字段(Fields)</strong>（列）。</p>
<blockquote>
<p>「索引」含义的区分</p>
<ul>
<li>索引（名词），一个<strong>索引(index)</strong>就像是传统关系数据库中的<strong>数据库</strong>，它是相关文档存储的地方，index的复数是<strong>indices</strong>或<strong>indexes</strong>。</li>
<li>索引（动词） <strong>「索引一个文档」</strong>表示把一个文档存储到<strong>索引（名词）</strong>里，以便它可以被检索或者查询。这很像SQL中的<code>INSERT</code>关键字，差别是，如果文档已经存在，新的文档将覆盖旧的文档。</li>
<li>倒排索引传统数据库为特定列增加一个索引，例如B-Tree索引来加速检索。Elasticsearch和Lucene使用一种叫做<strong>倒排索引(inverted index)</strong>的数据结构来达到相同目的。</li>
</ul>
</blockquote>
</li>
</ul>
<ul>
<li><p>如果创建员工目录，我们将进行如下操作：</p>
<ul>
<li>为每个员工的<strong>文档(document)</strong>建立索引，每个文档包含了相应员工的所有信息。</li>
<li>每个文档的类型为<code>employee</code>。</li>
<li><code>employee</code>类型归属于索引<code>megacorp</code>。</li>
<li><code>megacorp</code>索引存储在Elasticsearch集群中。</li>
</ul>
<p>我们能通过一个命令来完成对一个员工的文档存储：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">PUT /megacorp/employee/<span class="number">1</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"first_name"</span> : <span class="string">"John"</span>,</span><br><span class="line">    <span class="string">"last_name"</span> :  <span class="string">"Smith"</span>,</span><br><span class="line">    <span class="string">"age"</span> :        <span class="number">25</span>,</span><br><span class="line">    <span class="string">"about"</span> :      <span class="string">"I love to go rock climbing"</span>,</span><br><span class="line">    <span class="string">"interests"</span>: [ <span class="string">"sports"</span>, <span class="string">"music"</span> ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其中：path: <code>/megacorp/employee/1</code>包含三部分信息：</p>
<table>
<thead>
<tr>
<th>名字</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>megacorp</td>
<td>索引名</td>
</tr>
<tr>
<td>employee</td>
<td>类型名</td>
</tr>
<tr>
<td>1</td>
<td>这个员工的ID</td>
</tr>
</tbody></table>
</li>
<li><p>返回新</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"_index"</span>: <span class="string">"customer"</span>,</span><br><span class="line">  <span class="string">"_type"</span>: <span class="string">"external"</span>,</span><br><span class="line">  <span class="string">"_id"</span>: <span class="string">"AVyc9L6dtgHksqXKpTlM"</span>,</span><br><span class="line">  <span class="string">"_version"</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="string">"result"</span>: <span class="string">"created"</span>,</span><br><span class="line">  <span class="string">"_shards"</span>: &#123;</span><br><span class="line">    <span class="string">"total"</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="string">"successful"</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="string">"failed"</span>: <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">"created"</span>: <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>_index：文档存储的地方</li>
<li>_type： 文档代表的对象的类</li>
<li>_id：文档的唯一标识，是 URL-safe、 基于 Base64 编码且长度为20个字符的 GUID 字符串</li>
<li>_version：版本控制</li>
</ul>
</li>
</ul>
<h3 id="文档元数据"><a href="#文档元数据" class="headerlink" title="文档元数据"></a>文档元数据</h3><ul>
<li><p>一个文档不只有数据。它还包含了<strong>元数据(metadata)</strong> —— <strong>关于</strong>文档的信息。三个必须的元数据节点是：</p>
<table>
<thead>
<tr>
<th>节点</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><code>_index</code></td>
<td>文档存储的地方</td>
</tr>
<tr>
<td><code>_type</code></td>
<td>文档代表的对象的类</td>
</tr>
<tr>
<td><code>_id</code></td>
<td>文档的唯一标识</td>
</tr>
</tbody></table>
</li>
<li><p><code>_index</code></p>
<p><strong>索引(index)</strong>类似于关系型数据库里的“数据库”——它是我们存储和索引关联数据的地方。</p>
<blockquote>
<p>事实上，我们的数据被存储和索引在<strong>分片(shards)</strong>中，索引只是一个把一个或多个分片分组在一起的逻辑空间。然而，这只是一些内部细节——我们的程序完全不用关心分片。对于我们的程序而言，文档存储在<strong>索引(index)</strong>中。剩下的细节由Elasticsearch关心既可。</p>
</blockquote>
</li>
<li><p><code>_type</code></p>
<p>在Elasticsearch中，我们使用相同<strong>类型(type)</strong>的文档表示相同的“事物”，因为他们的数据结构也是相同的。</p>
<p>每个<strong>类型(type)</strong>都有自己的<strong>映射(mapping)</strong>或者结构定义，就像传统数据库表中的列一样。所有类型下的文档被存储在同一个索引下，但是类型的<strong>映射(mapping)</strong>会告诉Elasticsearch不同的文档如何被索引。我们将会在《映射》章节探讨如何定义和管理映射，但是现在我们将依赖Elasticsearch去自动处理数据结构。</p>
<p><code>_type</code>的名字可以是大写或小写，不能包含下划线或逗号。我们将使用<code>blog</code>做为类型名。</p>
</li>
<li><p><code>_id</code></p>
<p><strong>id</strong>仅仅是一个字符串，它与<code>_index</code>和<code>_type</code>组合时，就可以在Elasticsearch中唯一标识一个文档。当创建一个文档，你可以自定义<code>_id</code>，也可以让Elasticsearch帮你自动生成。</p>
</li>
</ul>
<h2 id="检索文档"><a href="#检索文档" class="headerlink" title="检索文档"></a>检索文档</h2><h3 id="检索"><a href="#检索" class="headerlink" title="检索"></a>检索</h3><ul>
<li><p>我们只要执行HTTP GET请求并指出文档的“地址”——<strong>索引、类型和ID既可</strong>。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">GET /megacorp/employee/<span class="number">1</span></span><br></pre></td></tr></table></figure>

<blockquote>
<p>我们通过HTTP方法<code>GET</code>来检索文档，同样的，我们可以使用<code>DELETE</code>方法删除文档，使用<code>HEAD</code>方法检查某文档是否存在。如果想更新已存在的文档，我们只需再<code>PUT</code>一次。</p>
</blockquote>
</li>
</ul>
<h3 id="简单搜索"><a href="#简单搜索" class="headerlink" title="简单搜索"></a>简单搜索</h3><ul>
<li><p>使用<code>GET</code>请求 获取全部员工请求</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">GET /megacorp/employee/_search</span><br></pre></td></tr></table></figure>
</li>
<li><p>我们搜索姓氏中包含<strong>“Smith”</strong>的员工。要做到这一点，我们将在命令行中使用轻量级的搜索方法。这种方法常被称作<strong>查询字符串(query string)</strong>搜索，因为我们像传递URL参数一样去传递查询语句：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">GET /megacorp/employee/_search?q=last_name:Smith</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h3 id="使用DSL语句查询"><a href="#使用DSL语句查询" class="headerlink" title="使用DSL语句查询"></a>使用DSL语句查询</h3><ul>
<li><p>Elasticsearch提供丰富且灵活的查询语言叫做<strong>DSL查询(Query DSL)</strong> ,它允许你构建更加复杂、强大的查询。</p>
<p><strong>DSL(Domain Specific Language特定领域语言)</strong>以JSON请求体的形式出现</p>
</li>
<li><p>如查询姓氏中包含<strong>“Smith”</strong>的员工</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">GET /megacorp/employee/_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"query"</span> : &#123;</span><br><span class="line">        <span class="string">"match"</span> : &#123;</span><br><span class="line">            <span class="string">"last_name"</span> : <span class="string">"Smith"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>找到姓氏为“Smith”的员工，但是我们只想得到年龄大于30岁的员工。我们的语句将添加<strong>过滤器(filter)</strong> </p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">GET /megacorp/employee/_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"query"</span> : &#123;</span><br><span class="line">        <span class="string">"filtered"</span> : &#123;</span><br><span class="line">            <span class="string">"filter"</span> : &#123;</span><br><span class="line">                <span class="string">"range"</span> : &#123;</span><br><span class="line">                    <span class="string">"age"</span> : &#123; <span class="string">"gt"</span> : <span class="number">30</span> &#125; &lt;<span class="number">1</span>&gt;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="string">"query"</span> : &#123;</span><br><span class="line">                <span class="string">"match"</span> : &#123;</span><br><span class="line">                    <span class="string">"last_name"</span> : <span class="string">"smith"</span> &lt;<span class="number">2</span>&gt;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li>&lt;1&gt;这部分查询属于<strong>区间过滤器(range filter)</strong> ,它用于查找所有年龄大于30岁的数据—— <code>gt</code>为”greater than”的缩写。</li>
<li>&lt;2&gt;这部分查询与之前的<code>match</code><strong>语句(query)</strong>一致。</li>
</ul>
</li>
<li><p>高亮搜索</p>
<p>之前的语句上增加<code>highlight</code>参数</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">GET /megacorp/employee/_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"query"</span> : &#123;</span><br><span class="line">        <span class="string">"match_phrase"</span> : &#123;</span><br><span class="line">            <span class="string">"about"</span> : <span class="string">"rock climbing"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">"highlight"</span>: &#123;</span><br><span class="line">        <span class="string">"fields"</span> : &#123;</span><br><span class="line">            <span class="string">"about"</span> : &#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在返回结果中会有一个新的部分叫做<code>highlight</code>，这里包含了来自<code>about</code>字段中的文本，并且用<code>&lt;em&gt;&lt;/em&gt;</code>来标识匹配到的单词。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   ...</span><br><span class="line">   <span class="string">"hits"</span>: &#123;</span><br><span class="line">      <span class="string">"total"</span>:      <span class="number">1</span>,</span><br><span class="line">      <span class="string">"max_score"</span>:  <span class="number">0.23013961</span>,</span><br><span class="line">      <span class="string">"hits"</span>: [</span><br><span class="line">         &#123;</span><br><span class="line">            ...</span><br><span class="line">            <span class="string">"_score"</span>:         <span class="number">0.23013961</span>,</span><br><span class="line">            <span class="string">"_source"</span>: &#123;</span><br><span class="line">               <span class="string">"first_name"</span>:  <span class="string">"John"</span>,</span><br><span class="line">               <span class="string">"last_name"</span>:   <span class="string">"Smith"</span>,</span><br><span class="line">               <span class="string">"age"</span>:         <span class="number">25</span>,</span><br><span class="line">               <span class="string">"about"</span>:       <span class="string">"I love to go rock climbing"</span>,</span><br><span class="line">               <span class="string">"interests"</span>: [ <span class="string">"sports"</span>, <span class="string">"music"</span> ]</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="string">"highlight"</span>: &#123;</span><br><span class="line">               <span class="string">"about"</span>: [</span><br><span class="line">                  <span class="string">"I love to go &lt;em&gt;rock&lt;/em&gt; &lt;em&gt;climbing&lt;/em&gt;"</span> &lt;<span class="number">1</span>&gt;</span><br><span class="line">               ]</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      ]</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><code>total</code>：返回记录数</li>
<li><code>max_score</code>：最高的匹配程度</li>
<li><code>hits</code>：返回的记录组成的数组。</li>
</ul>
</li>
</ul>
<h3 id="空搜索"><a href="#空搜索" class="headerlink" title="空搜索"></a>空搜索</h3><ul>
<li><p>输入</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">GET /_search</span><br></pre></td></tr></table></figure>
</li>
<li><p>返回</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="string">"hits"</span> : &#123;</span><br><span class="line">      <span class="string">"total"</span> :       <span class="number">14</span>,</span><br><span class="line">      <span class="string">"hits"</span> : [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="string">"_index"</span>:   <span class="string">"us"</span>,</span><br><span class="line">          <span class="string">"_type"</span>:    <span class="string">"tweet"</span>,</span><br><span class="line">          <span class="string">"_id"</span>:      <span class="string">"7"</span>,</span><br><span class="line">          <span class="string">"_score"</span>:   <span class="number">1</span>,</span><br><span class="line">          <span class="string">"_source"</span>: &#123;</span><br><span class="line">             <span class="string">"date"</span>:    <span class="string">"2014-09-17"</span>,</span><br><span class="line">             <span class="string">"name"</span>:    <span class="string">"John Smith"</span>,</span><br><span class="line">             <span class="string">"tweet"</span>:   <span class="string">"The Query DSL is really powerful and flexible"</span>,</span><br><span class="line">             <span class="string">"user_id"</span>: <span class="number">2</span></span><br><span class="line">          &#125;</span><br><span class="line">       &#125;,</span><br><span class="line">        ... <span class="number">9</span> RESULTS REMOVED ...</span><br><span class="line">      ],</span><br><span class="line">      <span class="string">"max_score"</span> :   <span class="number">1</span></span><br><span class="line">   &#125;,</span><br><span class="line">   <span class="string">"took"</span> :           <span class="number">4</span>,</span><br><span class="line">   <span class="string">"_shards"</span> : &#123;</span><br><span class="line">      <span class="string">"failed"</span> :      <span class="number">0</span>,</span><br><span class="line">      <span class="string">"successful"</span> :  <span class="number">10</span>,</span><br><span class="line">      <span class="string">"total"</span> :       <span class="number">10</span></span><br><span class="line">   &#125;,</span><br><span class="line">   <span class="string">"timed_out"</span> :      <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>hits</strong></p>
<p>返回结果中最重要的部分是 <code>hits</code> ，它 包含 <code>total</code> 字段来表示匹配到的文档总数，并且一个 <code>hits</code> 数组包含所查询结果的前十个文档。</p>
<p>在 <code>hits</code> 数组中每个结果包含文档的 <code>_index</code> 、 <code>_type</code> 、 <code>_id</code> ，加上 <code>_source</code> 字段。这意味着我们可以直接从返回的搜索结果中使用整个文档。这不像其他的搜索引擎，仅仅返回文档的ID，需要你单独去获取文档。</p>
<p>每个结果还有一个 <code>_score</code> ，它衡量了文档与查询的匹配程度。默认情况下，首先返回最相关的文档结果，就是说，返回的文档是按照 <code>_score</code> 降序排列的。在这个例子中，我们没有指定任何查询，故所有的文档具有相同的相关性，因此对所有的结果而言 <code>1</code> 是中性的 <code>_score</code> 。</p>
<p><code>max_score</code> 值是与查询所匹配文档的 <code>_score</code> 的最大值。</p>
</li>
<li><p><strong>took</strong></p>
<p><code>took</code> 值告诉我们执行整个搜索请求耗费了多少毫秒。</p>
</li>
<li><p><strong>shards</strong></p>
<p><code>_shards</code> 部分 告诉我们在查询中参与分片的总数，以及这些分片成功了多少个失败了多少个。正常情况下我们不希望分片失败，但是分片失败是可能发生的。如果我们遭遇到一种灾难级别的故障，在这个故障中丢失了相同分片的原始数据和副本，那么对这个分片将没有可用副本来对搜索请求作出响应。假若这样，Elasticsearch 将报告这个分片是失败的，但是会继续返回剩余分片的结果。</p>
</li>
<li><p><strong>timeout</strong></p>
<p><code>timed_out</code> 值告诉我们查询是否超时。默认情况下，搜索请求不会超时。 如果低响应时间比完成结果更重要，你可以指定 <code>timeout</code> 为 10 或者 10ms（10毫秒），或者 1s（1秒）：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">GET /_search?timeout=<span class="number">10</span>ms</span><br></pre></td></tr></table></figure>

<p>在请求超时之前，Elasticsearch 将会返回已经成功从每个分片获取的结果。</p>
</li>
</ul>
<h3 id="3-5-多索引，多类型"><a href="#3-5-多索引，多类型" class="headerlink" title="3.5.多索引，多类型"></a>3.5.多索引，多类型</h3><ul>
<li><p>想在一个或多个特殊的索引并且在一个或者多个特殊的类型中进行搜索。我们可以通过在URL中指定特殊的索引和类型达到这种效果，如下所示：</p>
</li>
<li><p><strong><code>/_search</code></strong>：在所有的索引中搜索所有的类型</p>
</li>
<li><p><strong><code>/gb/_search</code></strong>：在 <code>gb</code> 索引中搜索所有的类型</p>
</li>
<li><p><strong><code>/gb,us/_search</code></strong>：在 <code>gb</code> 和 <code>us</code> 索引中搜索所有的文档</p>
</li>
<li><p><strong><code>/g\*,u\*/_search</code></strong>：在任何以 <code>g</code> 或者 <code>u</code> 开头的索引中搜索所有的类型</p>
</li>
<li><p><strong><code>/gb/user/_search</code></strong>：在 <code>gb</code> 索引中搜索 <code>user</code> 类型</p>
</li>
<li><p><strong><code>/gb,us/user,tweet/_search</code></strong>：在 <code>gb</code> 和 <code>us</code> 索引中搜索 <code>user</code> 和 <code>tweet</code> 类型</p>
</li>
<li><p><strong><code>/_all/user,tweet/_search</code></strong>：在所有的索引中搜索 <code>user</code> 和 <code>tweet</code> 类型</p>
</li>
</ul>
<h2 id="聚合-aggregations"><a href="#聚合-aggregations" class="headerlink" title="聚合(aggregations)"></a>聚合(<strong>aggregations</strong>)</h2><ul>
<li><p>允许你在数据上生成复杂的分析统计</p>
<p>举个例子，让我们找到所有职员中最大的共同点（兴趣爱好）是什么</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">GET /megacorp/employee/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"aggs"</span>: &#123;</span><br><span class="line">    <span class="string">"all_interests"</span>: &#123;</span><br><span class="line">      <span class="string">"terms"</span>: &#123; <span class="string">"field"</span>: <span class="string">"interests"</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>返回结果</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   ...</span><br><span class="line">   <span class="string">"hits"</span>: &#123; ... &#125;,</span><br><span class="line">   <span class="string">"aggregations"</span>: &#123;</span><br><span class="line">      <span class="string">"all_interests"</span>: &#123;</span><br><span class="line">         <span class="string">"buckets"</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">               <span class="string">"key"</span>:       <span class="string">"music"</span>,</span><br><span class="line">               <span class="string">"doc_count"</span>: <span class="number">2</span></span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">               <span class="string">"key"</span>:       <span class="string">"forestry"</span>,</span><br><span class="line">               <span class="string">"doc_count"</span>: <span class="number">1</span></span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">               <span class="string">"key"</span>:       <span class="string">"sports"</span>,</span><br><span class="line">               <span class="string">"doc_count"</span>: <span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">         ]</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

</li>
</ul>
<h2 id="索引知识"><a href="#索引知识" class="headerlink" title="索引知识"></a>索引知识</h2><blockquote>
<p>其他的字段可以查阅 第9章中 链接中内容</p>
</blockquote>
<p>ElasticSearch的对象模型，跟关系型数据库模型相比：</p>
<ul>
<li><strong>索引（Index）</strong>：相当于数据库，用于定义文档类型的存储；在同一个索引中，同一个字段只能定义一个数据类型；</li>
<li><strong>文档类型（Type）</strong>：相当于关系表，用于描述文档中的各个字段的定义；不同的文档类型，能够存储不同的字段，服务于不同的查询请求；</li>
<li><strong>文档（Document）</strong>：相当于关系表的数据行，存储数据的载体，包含一个或多个存有数据的字段；<ul>
<li><strong>字段（Field）</strong>：文档的一个Key/Value对；</li>
<li><strong>词（Term）</strong>：表示文本中的一个单词；</li>
<li><strong>标记（Token）</strong>：表示在字段中出现的词，由该词的文本、偏移量（开始和结束）以及类型组成；</li>
</ul>
</li>
</ul>
<p>索引是由段（Segment）组成的，段存储在硬盘（Disk）文件中，段不是实时更新的，这意味着，段在写入磁盘后，就不再被更新。ElasticSearch引擎把被删除的文档的信息存储在一个单独的文件中，在搜索数据时，ElasticSearch引擎首先从段中查询，再从查询结果中过滤被删除的文档，这意味着，段中存储着“被删除”的文档，这使得段中含有”正常文档“的密度降低。多个段可以通过段合并（Segment Merge）操作把“已删除”的文档将从段中物理删除，把未删除的文档合并到一个新段中，新段中没有”已删除文档“，因此，段合并操作能够提高索引的查找速度，但段合并是IO密集型的操作，需要消耗大量的硬盘IO。</p>
<h3 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h3><p>在创建索引之前，首先了解<strong>REST</strong>ful API的调用风格，在管理和使用ElasticSearch服务时，常用的HTTP动词有下面五个：</p>
<ul>
<li><p><strong>GET 请求：获取服务器中的对象</strong></p>
<ul>
<li>相当于SQL的Select命令</li>
<li>GET /blogs：列出所有博客</li>
</ul>
</li>
<li><p>POST 请求：在服务器上更新对象</p>
<ul>
<li>相当于SQL的Update命令</li>
<li>POST /blogs/ID：更新指定的博客</li>
</ul>
</li>
<li><p><strong>PUT 请求：在服务器上创建对象</strong></p>
<ul>
<li>相当于SQL的Create命令</li>
<li>PUT /blogs/ID：新建一个博客　　</li>
</ul>
</li>
<li><p><strong>DELETE 请求：删除服务器中的对象</strong></p>
</li>
<li><ul>
<li>相当于SQL的Delete命令</li>
<li>DELETE /blogs/ID：删除指定的博客</li>
</ul>
</li>
<li><p><strong>HEAD 请求：仅仅用于获取对象的基础信息</strong></p>
</li>
</ul>
<ol>
<li><p><strong>禁用自动创建索引</strong></p>
<p>推荐设置：在全局配置文件 elasticsearch.yml 中，禁用自动创建索引：</p>
<figure class="highlight html"><table><tr><td class="code"><pre><span class="line">action.auto_create_index:false</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="2">
<li><p><strong>手动创建索引</strong></p>
<p>创建索引的语法是：<code>PUT http://host:port/index_name/+index_configuration</code></p>
<p>其中，<strong><code>index_name</code></strong>是创建的索引的名字，<strong><code>indiex_configuration</code></strong> 是向ElasticSearch服务器传递的请求负载的主体，数据格式<strong>是json</strong>，用于定义索引的配置信息：<strong>映射节（mappings）和配置节（settings）</strong>。</p>
<p>在创建索引时，需要精心设计索引的映射节（mappings）和配置节（settings），本例创建<strong>blog索引和articles文档类型，</strong>创建索引的语法是：<code>PUT http://localhost:9200/blog/</code></p>
</li>
</ol>
<h3 id="索引映射节（mappings）"><a href="#索引映射节（mappings）" class="headerlink" title="索引映射节（mappings）"></a>索引映射节（mappings）</h3><ol>
<li><p><strong>索引结构</strong></p>
<p>索引是由文档类型构成的，在mappings字段中定义索引的文档类型，示例代码中为blog索引定义了三个文档类型：articles，followers和comments</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;  </span><br><span class="line">   <span class="attr">"mappings"</span>:&#123;  </span><br><span class="line">      <span class="attr">"articles"</span>:&#123; &#125;,</span><br><span class="line">      <span class="attr">"followers"</span>:&#123; &#125;,</span><br><span class="line">      <span class="attr">"comments"</span>:&#123; &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>



</li>
</ol>
<ol start="2">
<li><p><strong>文档属性</strong></p>
<p><strong>==文档属性定义了文档类型的共用属性，适用于文档的所有字段:==</strong></p>
</li>
</ol>
<ul>
<li><strong>dynamic_date_formats</strong>属性：该属性定义可以识别的日期格式列表；</li>
<li><strong>dynamic</strong>属性：默认值为true，允许动态地向文档类型中加入新的字段。推荐设置为false，禁止向文档中添加字段，这样，文档类型的所有字段必须在索引映射的properties属性中显式定义，在properties字段中未定义的字段都将会ElasticSearch忽略。<ul>
<li>dynamic设置为ture：默认值，新增加的字段被添加到索引映射中；</li>
<li>dynamic设置为false：新增加的字段会被忽略；</li>
<li>dynamic设置为strict：当向文档中新增字段时，ElasticSearch引擎抛出异常；</li>
</ul>
</li>
</ul>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;  </span><br><span class="line">   <span class="attr">"mappings"</span>:&#123;  </span><br><span class="line">      <span class="attr">"articles"</span>:&#123;  <span class="attr">"dynamic"</span>:<span class="literal">false</span>,</span><br><span class="line">         <span class="attr">"dynamic_date_formats"</span>:[<span class="string">"yyyy-MM-dd hh:mm:ss"</span>, <span class="string">"yyyy-MM-dd"</span> ],</span><br><span class="line">         <span class="attr">"properties"</span>:&#123;  </span><br><span class="line">            <span class="attr">"id"</span>:&#123;&#125;,</span><br><span class="line">            <span class="attr">"title"</span>:&#123;&#125;,</span><br><span class="line">            <span class="attr">"author"</span>:&#123;&#125;,</span><br><span class="line">            <span class="attr">"content"</span>:&#123;&#125;,</span><br><span class="line">            <span class="attr">"postedat"</span>:&#123;&#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="文档的字段属性"><a href="#文档的字段属性" class="headerlink" title="文档的字段属性"></a>文档的字段属性</h3><h4 id="字段的数据类型"><a href="#字段的数据类型" class="headerlink" title="字段的数据类型"></a>字段的数据类型</h4><p>字段的数据类型由字段的属性type指定，ElasticSearch支持的基础数据类型主要有：</p>
<ul>
<li><p><strong>字符串类型</strong>：string；</p>
</li>
<li><p><strong>数值类型</strong>：字节（byte）、2字节（short）、4字节（integer）、8字节（long）、float、double；</p>
</li>
<li><p><strong>布尔类型</strong>：boolean，值是true或false；</p>
</li>
<li><p><strong>时间/日期类型</strong>：date，用于存储日期和时间；</p>
</li>
<li><p><strong>二进制类型</strong>：binary；</p>
</li>
<li><p><strong>IP地址类型</strong>：ip，以字符串形式存储IPv4地址；</p>
</li>
<li><p><strong>特殊数据类型</strong>：token_count，用于存储索引的字数信息</p>
<p>在文档类型的properties属性中，定义字段的type属性，指定字段的数据类型，属性properties 用于定义文档类型的字段属性，或字段对象的属性：</p>
<figure class="highlight"><table><tr><td class="code"><pre><span class="line">"properties":&#123;  </span><br><span class="line">           "id":&#123;"type":"long"&#125;</span><br><span class="line">           &#125;</span><br></pre></td></tr></table></figure>



</li>
</ul>
<h4 id="字段的公共属性"><a href="#字段的公共属性" class="headerlink" title="字段的公共属性"></a>字段的公共属性</h4><ul>
<li><p><strong>index</strong>：该属性控制字段是否编入索引被搜索，该属性共有三个有效值：analyzed、no和not_analyzed：</p>
<ul>
<li><p>analyzed：表示该字段被分析，编入索引，产生的token能被搜索到；</p>
</li>
<li><p>not_analyzed：表示该字段不会被分析，使用原始值编入索引，在索引中作为单个词；</p>
</li>
<li><p>no：不编入索引，无法搜索该字段；</p>
<p>其中analyzed是分析，分解的意思，默认值是analyzed，表示将该字段编入索引，以供搜索。</p>
</li>
</ul>
</li>
<li><p><strong>store</strong>：指定是否将字段的原始值写入索引，默认值是no，字段值被分析，能够被搜索，但是，字段值不会存储，这意味着，该字段能够被查询，但是不会存储字段的原始值。</p>
</li>
<li><p><strong>boost</strong>：字段级别的助推，默认值是1，定义了字段在文档中的重要性/权重；</p>
</li>
<li><p><strong>include_in_all</strong>：该属性指定当前字段是否包括在_all字段中，默认值是ture，所有的字段都会包含_all字段中；如果index=no，那么属性include_in_all无效，这意味着当前字段无法包含在_all字段中。</p>
</li>
<li><p><strong>copy_to</strong>：该属性指定一个字段名称，ElasticSearch引擎将当前字段的值复制到该属性指定的字段中；</p>
</li>
<li><p><strong>doc_values</strong>：文档值是存储在硬盘上的索引时（indexing time）数据结构，对于not_analyzed字段，默认值是true，analyzed string字段不支持文档值;</p>
</li>
<li><p><strong>fielddata</strong>：字段数据是存储在内存中的查询时（querying time）数据结构，只支持analyzed string字段；</p>
</li>
<li><p><strong>null_value</strong>：该属性指定一个值，当字段的值为NULL时，该字段使用null_value代替NULL值；在ElasticSearch中，NULL 值不能被索引和搜索，当一个字段设置为NULL值，ElasticSearch引擎认为该字段没有任何值，使用该属性为NULL字段设置一个指定的值，使该字段能够被索引和搜索。</p>
</li>
</ul>
<h4 id="字符串类型常用的其他属性"><a href="#字符串类型常用的其他属性" class="headerlink" title="字符串类型常用的其他属性"></a>字符串类型常用的其他属性</h4><ul>
<li><strong>analyzer</strong>：该属性定义用于建立索引和搜索的分析器名称，默认值是全局定义的分析器名称，该属性可以引用在配置结点（settings）中自定义的分析器；</li>
<li><strong>search_analyzer</strong>：该属性定义的分析器，用于处理发送到特定字段的查询字符串；</li>
<li><strong>ignore_above</strong>：该属性指定一个整数值，当字符串字段（analyzed string field）的字节数量大于该数值之后，超过长度的部分字符数据将不能被analyzer处理，不能被编入索引；对于 not analyzed string字段，超过长度的部分字符将被忽略，不会被编入索引。默认值是0，禁用该属性；</li>
<li><strong>position_increment_gap</strong>：该属性指定在相同词的位置上增加的gap，默认值是100；</li>
<li><strong>index_options</strong>：索引选项控制添加到倒排索引（Inverted Index）的信息，这些信息用于搜索（Search）和高亮显示：<ul>
<li>docs：只索引文档编号(Doc Number)</li>
<li>freqs：索引文档编号和词频率（term frequency）</li>
<li>positions：索引文档编号，词频率和词位置（序号）</li>
<li>offsets：索引文档编号，词频率，词偏移量（开始和结束位置）和词位置（序号）</li>
<li>默认情况下，被分析的字符串（analyzed string）字段使用positions，其他字段使用docs; </li>
</ul>
</li>
</ul>
<p>分析器（analyzer）把analyzed string 字段的值，转换成标记流（Token stream），例如，字符串”The quick Brown Foxes”，可能被分解成的标记（Token）是：quick,brown,fox。这些词（term）是该字段的索引值，这使用对索引文本的查找更有效率。字段的属性 analyzer 用于指定在index-time和search-time时，ElasticSearch引擎分解字段值的分析器名称。</p>
<h4 id="数值类型的其他属性"><a href="#数值类型的其他属性" class="headerlink" title="数值类型的其他属性"></a>数值类型的其他属性</h4><ul>
<li><strong>precision_step</strong>：该属性指定为数值字段每个值生成的term数量，值越低，产生的term数量越高，范围查询越快，索引越大，默认值是4；</li>
<li><strong>ignore_malformed</strong>：忽略格式错误的数值，默认值是false，不忽略错误格式，对整个文档不处理，并且抛出异常；</li>
<li><strong>coerce</strong>：默认值是true，尝试将字符串转换为数值，如果字段类型是整数，那么将小数取整；</li>
</ul>
<h4 id="日期类型的其他属性"><a href="#日期类型的其他属性" class="headerlink" title="日期类型的其他属性"></a>日期类型的其他属性</h4><ul>
<li><strong>format</strong>：指定日期的格式，例如：“yyyy-MM-dd hh:mm:ss”</li>
<li><strong>precision_step</strong>：该属性指定数值字段每隔多少数值，生成一个词（term）；step值越低，产生的词数量越高，范围查询越快，索引越大，占用存储空间越大；</li>
<li><strong>ignore_malformed</strong>：忽略错误格式，默认值是false，不忽略错误格式；</li>
</ul>
<h4 id="多字段（fields）"><a href="#多字段（fields）" class="headerlink" title="多字段（fields）"></a>多字段（fields）</h4><p>在fields属性中定义一个或多个字段，该字段的值和当前字段值相同，可以设置一个字段用于搜索，一个字段用于排序等。</p>
<figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;properties&quot;:</span><br><span class="line">&#123;  </span><br><span class="line">    &quot;id&quot;:&#123;  &quot;type&quot;:&quot;long&quot;,</span><br><span class="line">         &quot;fields&quot;:&#123;  &quot;id2&quot;:&#123;&quot;type&quot;:&quot;long&quot;,&quot;index&quot;:&quot;not_analyzed&quot;&#125; &#125;</span><br><span class="line">      &#125;,</span><br></pre></td></tr></table></figure>

<h4 id="文档值（doc-values）"><a href="#文档值（doc-values）" class="headerlink" title="文档值（doc_values）"></a>文档值（doc_values）</h4><p>默认情况下，多数字段都被一起编入索引，用户使用倒排索引（Inverted Index）可以搜索到相应的词（Term），倒排索引支持在唯一的有序词列表中查找特定词，或检查文档中是否包含某个词，但是，对于排序（Sort），聚合和在脚本中访问特定字段的值（Field value)，这三个操作需要执行不同的数据访问模式，即单字段数据访问：在文档中查找特定的字段，检查该字段是否包含指定的词。</p>
<p>文档值（doc_values）属性指定将字段的值写入到<strong>硬盘上</strong>的列式结构，实现了单个字段的数据访问模式，能够高效执行排序和聚合搜索。使用文档值的字段将有专属的字段数据缓存实例，无需像普通字段一样倒排。是存储在硬盘上的数据结构，在文档索引时创建。文档值数据存在硬盘上，在<strong>文档索引时</strong>创建，存储的数据和字段存储在_source 字段的数据相同，文档值支持所有的字段类型，除了analyzed string 字段之外。</p>
<p>默认情况下，所有的字段都支持文档值，默认是启用的（enabled），如果不需要在单个字段上执行排序或聚合操作，或者从脚本中访问指定字段的值，那么，可以禁用文档值，字段的值将不会存储在硬盘空间中。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">"properties"</span>: &#123;</span><br><span class="line">    <span class="string">"status_code"</span>: &#123; </span><br><span class="line">        <span class="string">"type"</span>:       <span class="string">"string"</span>,</span><br><span class="line">        <span class="string">"index"</span>:      <span class="string">"not_analyzed"</span></span><br><span class="line">        <span class="string">"doc_values"</span>: <span class="literal">true</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">"session_id"</span>: &#123; </span><br><span class="line">        <span class="string">"type"</span>:       <span class="string">"string"</span>,</span><br><span class="line">        <span class="string">"index"</span>:      <span class="string">"not_analyzed"</span>,</span><br><span class="line">        <span class="string">"doc_values"</span>: <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="字段数据（Fielddata）"><a href="#字段数据（Fielddata）" class="headerlink" title="字段数据（Fielddata）"></a>字段数据（Fielddata）</h4><p>字段数据（Fielddata）是存储在内存中的查询时数据结构，只支持analyzed string字段。该数据结构在字段第一次执行聚合，排序或被脚本访问时创建。创建的过程是：在读取整个倒排索引（Inverted Index）时，ElasticSearch从硬盘上加载倒排索引的每个段（Segment），倒转词（Term）和文档的关系，并将其存储在JVM堆内存中。加载字段数据的过程是非常消耗IO资源的，一旦被加载，就被存储在内存中，直到段的生命周期结束。</p>
<p>对于analyzed string字段，fielddata字段是默认启用的，</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">"text"</span>:&#123;  </span><br><span class="line">   <span class="string">"type"</span>:<span class="string">"string"</span>,</span><br><span class="line">   <span class="string">"fielddata"</span>:&#123;  <span class="string">"loading"</span>:<span class="string">"lazy"</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="存储（store）"><a href="#存储（store）" class="headerlink" title="存储（store）"></a>存储（store）</h4><p>存储（store）属性指定是否将字段的原始值写入索引，默认值是no，字段值被分析，能够被搜索，但是，字段的原始值不会存储，这意味着，该字段能够被查询，但是无法获取字段的原始值。默认情况下，该字段的值会被存储到_source字段中，如果想要获取单个或多个字段的值，而不是整个_source字段，可以使用 <a href="https://www.elastic.co/guide/en/elasticsearch/reference/2.4/search-request-source-filtering.html" target="_blank" rel="noopener">source filtering</a> 来实现；但是在特定的条件下，只存储一个字段的值是有意义的（make sense），例如，一个article文档包含：title，postdate和content字段，从文档中只获取title和postdate字段，并且使_source 字段包含content字段，必须通过store属性来控制：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">"mappings"</span>: &#123;</span><br><span class="line">    <span class="string">"my_type"</span>: &#123;</span><br><span class="line">      <span class="string">"properties"</span>: &#123;</span><br><span class="line">        <span class="string">"title"</span>: &#123;</span><br><span class="line">          <span class="string">"type"</span>: <span class="string">"string"</span>,</span><br><span class="line">          <span class="string">"store"</span>: <span class="literal">true</span> </span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">"date"</span>: &#123;</span><br><span class="line">          <span class="string">"type"</span>: <span class="string">"date"</span>,</span><br><span class="line">          <span class="string">"store"</span>: <span class="literal">true</span> </span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">"content"</span>: &#123;</span><br><span class="line">          <span class="string">"type"</span>: <span class="string">"string"</span>,</span><br><span class="line">          <span class="string">"store"</span>: <span class="literal">false</span>   </span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>

<h4 id="位置增加间隔（position-increment-gap）"><a href="#位置增加间隔（position-increment-gap）" class="headerlink" title="位置增加间隔（position_increment_gap）"></a>位置增加间隔（position_increment_gap）</h4><p>对于analyzed string字段，都会考虑把词的位置信息，用于支持位置和短语匹配查询（<a href="https://www.elastic.co/guide/en/elasticsearch/reference/2.4/query-dsl-match-query.html#query-dsl-match-query-phrase" target="_blank" rel="noopener">proximity or phrase queries</a>），例如，有一个字符串字段，该字段中存在多个词“fake”，ElasticSearch引擎会在每个值之间增加一个gap，以防止短语匹配或位置匹配查询出现跨越多个词的异常，这个gap的值就是属性position_increment_gap，默认值是100；</p>
<h3 id="元字段"><a href="#元字段" class="headerlink" title="元字段"></a>元字段</h3><p>在索引的映射中，元字段（Meta-field）是以下划线开头的字段，部分元字段可以配置，部分元字段不可配置，只能用于返回信息。</p>
<h4 id="all-字段，可以配置"><a href="#all-字段，可以配置" class="headerlink" title="_all 字段，可以配置"></a>_all 字段，可以配置</h4><p>ElasticSearch使用_all字段存储其他字段的数据以便搜索，默认情况下，_all字段是启用的，包含了索引中所有字段的数据，然而这一字段使索引变大，如果不需要，请禁用该字段，或排除某些字段。为了在_all字段中不包括某个特定字段，在字段中设置“include_in_all”属性为false。</p>
<p>禁用_all字段，需要修改映射配置：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;  </span><br><span class="line">   <span class="string">"articles"</span>:&#123;  <span class="string">"_all"</span>:&#123;  </span><br><span class="line">         <span class="string">"enabled"</span>:<span class="literal">false</span></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="source-字段，可以配置"><a href="#source-字段，可以配置" class="headerlink" title="_source 字段，可以配置"></a>_source 字段，可以配置</h4><p>_source字段表示在生成索引的过程中，存储发送到ElasticSearch的原始JSON文档，默认情况下，该字段会被启用，因为索引的局部更新功能依赖该字段。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;  </span><br><span class="line">   <span class="string">"articles"</span>:&#123;  </span><br><span class="line">      <span class="string">"_source"</span>:&#123;  </span><br><span class="line">         <span class="string">"enabled"</span>:<span class="literal">true</span></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;  </span><br><span class="line">   <span class="string">"articles"</span>:&#123;  </span><br><span class="line">      <span class="string">"_source"</span>:&#123;  </span><br><span class="line">         <span class="string">"excludes"</span>:[<span class="string">"Content"</span>,<span class="string">"Comments"</span>],</span><br><span class="line">         <span class="string">"includes"</span>:[<span class="string">"author"</span>]</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="routing-字段，可以配置"><a href="#routing-字段，可以配置" class="headerlink" title="_routing 字段，可以配置"></a>_routing 字段，可以配置</h4><p>路由字段，将一个文档值进行哈希映射，并将该文档路由到指定的分片，路由的公式是：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">shard_num = hash(_routing) % num_primary_shards</span><br></pre></td></tr></table></figure>

<p>在ElasticSearch 2.4 版本中，path参数被废弃，使用的默认字段是_id，设置required为true，表示路由字段在进行索引的CRUD操作时必需显式赋值。</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;  </span><br><span class="line">   <span class="string">"articles"</span>:&#123;  </span><br><span class="line">      <span class="string">"_routing"</span>:&#123;  </span><br><span class="line">         <span class="string">"required"</span>:<span class="literal">true</span></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在put 命令中，使用自定义的路由字段，以下示例使用 user1字段作为路由字段更新和查询文档：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">PUT my_index/my_type/<span class="number">1</span>?routing=user1 </span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"title"</span>: <span class="string">"This is a document"</span></span><br><span class="line">&#125;</span><br><span class="line">GET my_index/my_type/<span class="number">1</span>?routing=user1</span><br></pre></td></tr></table></figure>

<h4 id="不可配置的元字段"><a href="#不可配置的元字段" class="headerlink" title="不可配置的元字段"></a>不可配置的元字段</h4><ul>
<li><code>_index</code>：返回文档所属的索引</li>
<li><code>_uid</code>：返回文档的type和id</li>
<li><code>_type</code>：返回文档类型（type）</li>
<li><code>_id</code>：返回文档的ID；</li>
<li><code>_size</code>：返回文档的_source字段中函数的字节数量；</li>
<li><code>_field_names</code>：返回文档中不包含null值的字段名称；</li>
</ul>
<h3 id="索引配置节（settings）"><a href="#索引配置节（settings）" class="headerlink" title="索引配置节（settings）"></a>索引配置节（settings）</h3><h4 id="配置索引的分片和副本数量"><a href="#配置索引的分片和副本数量" class="headerlink" title="配置索引的分片和副本数量"></a>配置索引的分片和副本数量</h4><p>ElasticSearch索引是有一个或多个分片组成的，每个分片是索引的一个水平分区，包含了文档数据的一部分；每个分片有0，1或多个副本，分片的副本和分片存储相同的数据。</p>
<p>示例代码，为索引创建5个分片，分片没有副本：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">"settings"</span>:&#123;</span><br><span class="line">    <span class="string">"number_of_shards"</span>:<span class="number">5</span>,</span><br><span class="line">    <span class="string">"number_of_replicas"</span>:<span class="number">0</span>,</span><br></pre></td></tr></table></figure>

<h4 id="配置分析器（analyzer）"><a href="#配置分析器（analyzer）" class="headerlink" title="配置分析器（analyzer）"></a>配置分析器（analyzer）</h4><p>在配置结点的analysis属性中配置分析器，参考<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis.html" target="_blank" rel="noopener">官方文档</a>了解更多，</p>
<p><strong>分词器（tokenizer）是系统预定义的，常用的分词器是：</strong></p>
<ul>
<li>standard：默认值，用于大多数欧洲语言的标准分词器</li>
<li>simple：基于非字母字符来分词，并将其转化为小写形式</li>
<li>whitespace：基于空格来分词</li>
<li>stop：除了simple的所有功能，还能基于停用词（stop words）过滤数据；</li>
<li>pattern：使用正则表达式分词；</li>
<li>snowball：除了standard提供的分词功能之外，还提供词干提取功能；</li>
</ul>
<p><strong>过滤器是系统预定义的，常用的过滤器是:</strong></p>
<ul>
<li>asciifolding</li>
<li>lowercase</li>
<li>kstem</li>
</ul>
<h2 id="ElasticSearch-High-Level-REST-文档基本操作"><a href="#ElasticSearch-High-Level-REST-文档基本操作" class="headerlink" title="ElasticSearch High Level REST  文档基本操作"></a>ElasticSearch High Level REST  文档基本操作</h2><blockquote>
<p>indexRequest：索引请求</p>
<p>GetRequest：获取请求</p>
<p>DeleteRequest：删除请求</p>
<p>UpdateRequest：更新请求</p>
<p>BulkRequest：容量请求，用来装上述所有请求</p>
</blockquote>
<h3 id="坐标依赖"><a href="#坐标依赖" class="headerlink" title="坐标依赖"></a>坐标依赖</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>elastic-lucene-snapshots<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>Elastic Lucene Snapshots<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://s3.amazonaws.com/download.elasticsearch.org/lucenesnapshots/00142c9<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">releases</span>&gt;</span><span class="tag">&lt;<span class="name">enabled</span>&gt;</span>true<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span><span class="tag">&lt;/<span class="name">releases</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">snapshots</span>&gt;</span><span class="tag">&lt;<span class="name">enabled</span>&gt;</span>false<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span><span class="tag">&lt;/<span class="name">snapshots</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="创建客户端"><a href="#创建客户端" class="headerlink" title="创建客户端"></a>创建客户端</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ElasticClient</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String host = <span class="string">"10.1.59.101"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> port = <span class="number">9200</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取Rest高级客户端</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RestHighLevelClient <span class="title">getRestHighLevelClient</span><span class="params">()</span></span>&#123;</span><br><span class="line">        RestClientBuilder builder = RestClient.builder(<span class="keyword">new</span> HttpHost(host, port));</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RestHighLevelClient(builder);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取Rest低级客户端</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RestClient <span class="title">getRestClient</span><span class="params">()</span></span>&#123;</span><br><span class="line">        RestClient build = RestClient.builder(<span class="keyword">new</span> HttpHost(host)).build();</span><br><span class="line">        <span class="keyword">return</span> build;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="索引操作"><a href="#索引操作" class="headerlink" title="索引操作"></a>索引操作</h3><p>索引即我们的新增操作，ES提供了三种形式的索引，分别为通过<em>Json字符串、Map集合、XContentBuilder实</em>现索引操作</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">        RestHighLevelClient client = elasticClient.getRestHighLevelClient();</span><br><span class="line">        <span class="comment">//Json字符串作为数据源</span></span><br><span class="line">        IndexRequest indexRequest1 = <span class="keyword">new</span> IndexRequest(<span class="string">"02"</span>,book<span class="string">","</span><span class="number">3</span><span class="string">");</span></span><br><span class="line"><span class="string">        String jsonString = "</span>&#123;<span class="string">" +</span></span><br><span class="line"><span class="string">                "</span>\<span class="string">"name\":\"生命的诞生\","</span> +</span><br><span class="line">                <span class="string">"\"type\":\"科学\","</span> +</span><br><span class="line">                <span class="string">"\"price\":\"170\""</span> +</span><br><span class="line">                <span class="string">"&#125;"</span>;</span><br><span class="line"></span><br><span class="line">        indexRequest1.source(jsonString, XContentType.JSON);</span><br><span class="line">                                                      </span><br><span class="line">        <span class="comment">//Map集合作为数据源</span></span><br><span class="line">        Map jsonMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        jsonMap.put(<span class="string">"user"</span>, <span class="string">"userByMap"</span>);</span><br><span class="line">        jsonMap.put(<span class="string">"postDate"</span>, <span class="keyword">new</span> Date());</span><br><span class="line">        jsonMap.put(<span class="string">"message"</span>, <span class="string">"messageByMap"</span>);</span><br><span class="line">        IndexRequest indexRequest2 = <span class="keyword">new</span> IndexRequest(<span class="string">"posts"</span>, <span class="string">"doc"</span>, <span class="string">"34"</span>).source(jsonMap);</span><br><span class="line">                                                      </span><br><span class="line">        <span class="comment">//XContentBuilder作为数据源</span></span><br><span class="line">        XContentBuilder builder = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            builder = XContentFactory.jsonBuilder();</span><br><span class="line">            builder.startObject();</span><br><span class="line">            builder.field(<span class="string">"user"</span>, <span class="string">"userXXX"</span>);</span><br><span class="line">            builder.timeField(<span class="string">"postDate"</span>, <span class="keyword">new</span> Date());</span><br><span class="line">            builder.field(<span class="string">"message"</span>, <span class="string">"messageXXX"</span>);</span><br><span class="line">            builder.endObject();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        IndexRequest indexRequest3 = <span class="keyword">new</span> IndexRequest(<span class="string">"posts"</span>, <span class="string">"doc"</span>, <span class="string">"1"</span>)</span><br><span class="line">                .source(builder);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            IndexResponse indexResponse1 = client.index(indexRequest1, RequestOptions.DEFAULT);</span><br><span class="line">            client.index(indexRequest2, RequestOptions.DEFAULT);</span><br><span class="line">            client.index(indexRequest3, RequestOptions.DEFAULT);</span><br><span class="line">            client.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>

<h3 id="获取操作"><a href="#获取操作" class="headerlink" title="获取操作"></a>获取操作</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">()</span></span>&#123;</span><br><span class="line">    RestHighLevelClient client = elasticClient.getRestHighLevelClient();</span><br><span class="line">    GetRequest getRequest = <span class="keyword">new</span> GetRequest(<span class="string">"posts"</span>,<span class="string">"doc"</span>,<span class="string">"1"</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        GetResponse getResponse = client.get(getRequest, RequestOptions.DEFAULT);</span><br><span class="line">        client.close();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">()</span></span>&#123;</span><br><span class="line">    RestHighLevelClient client = elasticClient.getRestHighLevelClient();</span><br><span class="line">    <span class="comment">//获取删除请求</span></span><br><span class="line">	DeleteRequest deleteRequest = <span class="keyword">new</span> DeleteRequest(<span class="string">"02"</span>, <span class="string">"book"</span>, <span class="string">"2"</span>);</span><br><span class="line">    deleteRequest.timeout(TimeValue.timeValueMinutes(<span class="number">10</span>));</span><br><span class="line">    deleteRequest.setRefreshPolicy(WriteRequest.RefreshPolicy.WAIT_UNTIL);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        client.delete(deleteRequest, RequestOptions.DEFAULT);</span><br><span class="line">        client.close();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(User user)</span></span>&#123;</span><br><span class="line">    RestHighLevelClient client = elasticClient.getRestHighLevelClient();</span><br><span class="line">    <span class="comment">//获取更新请求</span></span><br><span class="line">    UpdateRequest updateRequest = <span class="keyword">new</span> UpdateRequest(<span class="string">"posts"</span>, <span class="string">"doc"</span>, <span class="string">"35"</span>);</span><br><span class="line">    Map map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    map.put(<span class="string">"message"</span>, <span class="string">"message_update"</span>);</span><br><span class="line">    map.put(<span class="string">"user"</span>, <span class="string">"user_update"</span>);</span><br><span class="line">    updateRequest.doc(user.toJsonString(), XContentType.JSON);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        client.update(updateRequest, RequestOptions.DEFAULT);</span><br><span class="line">        client.close();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="查询文档是否存在"><a href="#查询文档是否存在" class="headerlink" title="查询文档是否存在"></a>查询文档是否存在</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exists</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    RestHighLevelClient client = elasticClient.getRestHighLevelClient();</span><br><span class="line">    GetRequest getRequest = <span class="keyword">new</span> GetRequest(<span class="string">"posts"</span>,<span class="string">"doc"</span>,<span class="string">"33"</span>);</span><br><span class="line">    GetResponse getResponse = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        getRequest.fetchSourceContext(<span class="keyword">new</span> FetchSourceContext(<span class="keyword">false</span>));<span class="comment">//禁用获取 _source字段</span></span><br><span class="line">        getRequest.storedFields(<span class="string">"_none_"</span>);<span class="comment">//禁用获取存储字段。</span></span><br><span class="line">        <span class="comment">//这里获取文档存在的状态</span></span><br><span class="line">        <span class="keyword">boolean</span> exists = client.exists(getRequest, RequestOptions.DEFAULT);</span><br><span class="line">        client.close();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Bulk批量操作"><a href="#Bulk批量操作" class="headerlink" title="Bulk批量操作"></a>Bulk批量操作</h3><ul>
<li><strong>BulkRequest</strong>：  批量请求（用于增删改操作）</li>
<li><strong>BulkResponse</strong>：批量请求（用于增删改操作）</li>
</ul>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bulk</span><span class="params">(User user)</span></span>&#123;</span><br><span class="line">    RestHighLevelClient client = elasticClient.getRestHighLevelClient();</span><br><span class="line">    User user2 = <span class="keyword">new</span> User();</span><br><span class="line">    user2.setName(<span class="string">"周大福"</span>);</span><br><span class="line">    user2.setAge(<span class="number">211</span>);</span><br><span class="line">    user2.setPosition(<span class="string">"珠宝"</span>);</span><br><span class="line">    <span class="comment">//批量请求（用于增删改操作）</span></span><br><span class="line">    BulkRequest bulkRequest = <span class="keyword">new</span> BulkRequest();</span><br><span class="line">    <span class="comment">//多种请求</span></span><br><span class="line">    IndexRequest indexRequest1 = </span><br><span class="line">        <span class="keyword">new</span> IndexRequest(<span class="string">"posts"</span>, <span class="string">"doc"</span>, <span class="string">"41"</span>).source(user.toJsonString(), XContentType.JSON);</span><br><span class="line">    IndexRequest indexRequest2 = </span><br><span class="line">        <span class="keyword">new</span> IndexRequest(<span class="string">"posts"</span>, <span class="string">"doc"</span>, <span class="string">"42"</span>).source(user2.toJsonString(), XContentType.JSON);</span><br><span class="line">    DeleteRequest deleteRequest = <span class="keyword">new</span> DeleteRequest(<span class="string">"01"</span>, <span class="string">"law"</span>, <span class="string">"3"</span>);</span><br><span class="line"></span><br><span class="line">    bulkRequest.add(indexRequest1);</span><br><span class="line">    bulkRequest.add(indexRequest2);</span><br><span class="line">    bulkRequest.add(deleteRequest);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">        client.bulk(bulkRequest, RequestOptions.DEFAULT);</span><br><span class="line">        client.close();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="ElasticSearch-High-Level-REST-搜索查询"><a href="#ElasticSearch-High-Level-REST-搜索查询" class="headerlink" title="ElasticSearch High Level REST 搜索查询"></a>ElasticSearch High Level REST 搜索查询</h2><h3 id="创建查询请求"><a href="#创建查询请求" class="headerlink" title="创建查询请求"></a>创建查询请求</h3><p>在search搜索中大部分的搜索条件添加都可通过设置SearchSourceBuilder来实现，然后将SearchSourceBuilder</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">RestHighLevelClient client = ElasticClient.getRestHighLevelClient();</span><br><span class="line"><span class="comment">//创建查询体</span></span><br><span class="line">SearchRequest searchRequest = <span class="keyword">new</span> SearchRequest();</span><br><span class="line">SearchSourceBuilder sourceBuilder = <span class="keyword">new</span> SearchSourceBuilder();</span><br><span class="line">sourceBuilder.query(QueryBuilders.termQuery(<span class="string">"user"</span>, <span class="string">"kimchy"</span>));</span><br><span class="line"><span class="comment">//分页查询</span></span><br><span class="line">sourceBuilder.from(<span class="number">0</span>);</span><br><span class="line">sourceBuilder.size(<span class="number">5</span>);</span><br><span class="line"><span class="comment">//设置一个可选的超时，控制允许搜索的时间</span></span><br><span class="line">sourceBuilder.timeout(<span class="keyword">new</span> TimeValue(<span class="number">60</span>, TimeUnit.SECONDS)); </span><br><span class="line"><span class="comment">//获取搜索请求</span></span><br><span class="line">searchRequest.source(sourceBuilder);</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//执行请求</span></span><br><span class="line">    SearchResponse search = client.search(searchRequest, RequestOptions.DEFAULT);</span><br><span class="line">    <span class="comment">//获取匹配的总数量</span></span><br><span class="line">    Long total = search.getHits().getTotalHits(); </span><br><span class="line">    System.out.println(<span class="string">"总记录数："</span> + total);</span><br><span class="line">    <span class="keyword">for</span> (SearchHit hit : search.getHits().getHits()) &#123;</span><br><span class="line">        <span class="comment">//获得分数，即匹配度 </span></span><br><span class="line">              <span class="keyword">float</span> score = hit.getScore(); </span><br><span class="line">          String source = hit.getSourceAsString();</span><br><span class="line">          System.out.println(source);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<ul>
<li><p><strong>search查询的返回值为SearchResponse</strong>，调用SearchResponse的<code>getHits()</code>方法会获取SearchHits对象，然后再通过SearchHits的getHits()方法即返回一个SearchHit[]数组。</p>
</li>
<li><p>遍历SearchHit[]数组获取每一个对象，通过hit.getScore()可获取分数，即搜索匹配度。通过hit.getSourceAsString()可得到对象的json字符串。</p>
<blockquote>
<p><strong>备注：</strong>在上述查询中用到了termQuery查询，ES还提供了matchQuery查询，不同的查询需求中需要选择不同的查询，在此需要了解这两个查询的区别：</p>
<ul>
<li><strong>termQuery</strong> : term为不使用分词器查找，类似精确查找。</li>
<li><strong>matchQuery</strong> : mactch为使用分词器进行查找，会查询到一些近似匹配的内容。</li>
</ul>
</blockquote>
</li>
</ul>
<h3 id="SearchHit使用汇总"><a href="#SearchHit使用汇总" class="headerlink" title="SearchHit使用汇总"></a>SearchHit使用汇总</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SearchHits hits = searchResponse.getHits();</span><br><span class="line"></span><br><span class="line"><span class="comment">//查询命中总数</span></span><br><span class="line"><span class="keyword">long</span> totalHits = hits.getTotalHits(); </span><br><span class="line"><span class="comment">//查询命中的最高分数</span></span><br><span class="line"><span class="keyword">float</span> maxScore = hits.getMaxScore();</span><br><span class="line"></span><br><span class="line"><span class="comment">//嵌套在SearchHits可以迭代获取单个搜索结果中</span></span><br><span class="line">SearchHit[] searchHits = hits.getHits();</span><br><span class="line"><span class="keyword">for</span> (SearchHit hit : searchHits) &#123;</span><br><span class="line">    <span class="comment">//使用SearchHit做一些事情</span></span><br><span class="line">    <span class="comment">//hit就是 文档内容</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//通过SearchHit还可以获取 返回数据 的索引、类型、docId和得分等基本信息</span></span><br><span class="line">String index = hit.getIndex(); </span><br><span class="line">String type = hit.getType();</span><br><span class="line">String id = hit.getId();</span><br><span class="line"><span class="keyword">float</span> score = hit.getScore();</span><br><span class="line"></span><br><span class="line"><span class="comment">//hit还可以以Json字符串或Map的形式返回数据</span></span><br><span class="line">String sourceAsString = hit.getSourceAsString();</span><br><span class="line">Map&lt;String, Object&gt; sourceAsMap = hit.getSourceAsMap();</span><br><span class="line">String documentTitle = (String) sourceAsMap.get(<span class="string">"title"</span>);</span><br><span class="line">List&lt;Object&gt; users = (List&lt;Object&gt;) sourceAsMap.get(<span class="string">"user"</span>);</span><br><span class="line">Map&lt;String, Object&gt; innerObject = (Map&lt;String, Object&gt;) sourceAsMap.get(<span class="string">"innerObject"</span>);</span><br></pre></td></tr></table></figure>

<p><strong>在Elasticsearch中 hit内容比对</strong></p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">"hits"</span> : [</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">"_index"</span> : <span class="string">"sku"</span>,</span><br><span class="line">        <span class="string">"_type"</span> : <span class="string">"doc"</span>,</span><br><span class="line">        <span class="string">"_id"</span> : <span class="string">"Tty-0WsB2H3IH4AiYGNu"</span>,</span><br><span class="line">        <span class="string">"_score"</span> : <span class="number">5.676614</span>,</span><br><span class="line">        <span class="string">"_source"</span> : &#123;</span><br><span class="line">            <span class="string">"brandName"</span> : <span class="literal">null</span>,</span><br><span class="line">            <span class="string">"num"</span> : <span class="number">10000</span>,</span><br><span class="line">            <span class="string">"weight"</span> : <span class="number">10</span>,</span><br><span class="line">            <span class="string">"updateTime"</span> : <span class="literal">null</span>,</span><br><span class="line">            <span class="string">"saleNum"</span> : <span class="literal">null</span>,</span><br><span class="line">            <span class="string">"categoryName"</span> : <span class="literal">null</span>,</span><br><span class="line">            <span class="string">"id"</span> : <span class="string">"34598992560"</span>,</span><br><span class="line">            <span class="string">"sn"</span> : <span class="string">""</span>,</span><br><span class="line">            <span class="string">"categoryId"</span> : <span class="literal">null</span>,</span><br><span class="line">            <span class="string">"status"</span> : <span class="string">"1"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    ……</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<ul>
<li>_index：索引</li>
<li>_type：类型</li>
<li>_id：唯一标识</li>
<li>_score：匹配分数</li>
<li>_source：数据内容</li>
</ul>
<h3 id="指定排序"><a href="#指定排序" class="headerlink" title="指定排序"></a>指定排序</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">sourceBuilder.sort(<span class="keyword">new</span> ScoreSortBuilder().order(SortOrder.DESC)); <span class="comment">//按分数（即匹配度）排序</span></span><br><span class="line">sourceBuilder.sort(<span class="keyword">new</span> FieldSortBuilder(<span class="string">"_uid"</span>).order(SortOrder.ASC)); <span class="comment">//通过指定字段来排序</span></span><br></pre></td></tr></table></figure>

<p>排序有两种排序方式，第一通过ScoreSortBuilder实现按分数（即匹配度）排序</p>
<p>第二种方式通过指定字段来排序，如上图所示通过“_uid”字段排序</p>
<h3 id="关闭检索"><a href="#关闭检索" class="headerlink" title="关闭检索"></a>关闭检索</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">sourceBuilder.fetchSource(<span class="keyword">false</span>);</span><br></pre></td></tr></table></figure>

<p>只返回了总记录数，遍历输出每条数据均为 null</p>
<p>另外还可以通过sourceBuilder接受一个或多个数组，来控制要要返回哪些字段，排除哪些字段。具体实现如下，第一个数组参数为要接受的字段，第二个数组参数为要排除的内容：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String[] includeFields = <span class="keyword">new</span> String[] &#123;<span class="string">"title"</span>, <span class="string">"user"</span>, <span class="string">"innerObject.*"</span>&#125;;</span><br><span class="line">String[] excludeFields = <span class="keyword">new</span> String[] &#123;<span class="string">"_type"</span>&#125;;</span><br><span class="line">sourceBuilder.fetchSource(includeFields, excludeFields);</span><br></pre></td></tr></table></figure>

<h3 id="高亮显示"><a href="#高亮显示" class="headerlink" title="高亮显示"></a>高亮显示</h3><p>通过向SearchSourceBuilder添加HighlightBuilder示例可添加高亮显示功能</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SearchSourceBuilder searchSourceBuilder = <span class="keyword">new</span> SearchSourceBuilder();</span><br><span class="line"><span class="comment">//高亮显示构造器</span></span><br><span class="line">HighlightBuilder highlightBuilder = <span class="keyword">new</span> HighlightBuilder(); </span><br><span class="line"><span class="comment">//Field：定义高亮的范围，在hit中的 title内容中</span></span><br><span class="line">HighlightBuilder.Field highlightTitle = <span class="keyword">new</span> HighlightBuilder.Field(<span class="string">"title"</span>); </span><br><span class="line"><span class="comment">//可以自定义高亮样式</span></span><br><span class="line"><span class="comment">//highlightTitle.preTags("&lt;font style='color:red'&gt;").postTags("&lt;/font&gt;");</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//字段高亮显示类型，默认用标签包裹高亮字词</span></span><br><span class="line">highlightTitle.highlighterType(<span class="string">"unified"</span>); </span><br><span class="line">highlightBuilder.field(highlightTitle);</span><br><span class="line">searchSourceBuilder.highlighter(highlightBuilder);</span><br></pre></td></tr></table></figure>

<p>通过SearchHit的<strong>getHighlightFields()</strong>方法获取我们需要高亮内容：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SearchHits hits = searchResponse.getHits();</span><br><span class="line"><span class="keyword">for</span> (SearchHit hit : hits.getHits()) &#123;</span><br><span class="line">    Map highlightFields = hit.getHighlightFields();</span><br><span class="line">    HighlightField highlight = highlightFields.get(<span class="string">"title"</span>); </span><br><span class="line">    Text[] fragments = highlight.fragments();  </span><br><span class="line">    String fragmentString = fragments[<span class="number">0</span>].string();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="聚合-分组-操作"><a href="#聚合-分组-操作" class="headerlink" title="聚合(分组)操作"></a>聚合(分组)操作</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">aggregation</span><span class="params">()</span></span>&#123;</span><br><span class="line">    RestHighLevelClient client = elasticClient.getRestHighLevelClient();</span><br><span class="line">    SearchRequest searchRequest = <span class="keyword">new</span> SearchRequest();</span><br><span class="line">    SearchSourceBuilder searchSourceBuilder = <span class="keyword">new</span> SearchSourceBuilder();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//若不加keyword,在text类型上进行聚合操作时会报错</span></span><br><span class="line">    TermsAggregationBuilder aggregation = AggregationBuilders.terms(<span class="string">"by_sex"</span>).field(<span class="string">"sex.keyword"</span>);   </span><br><span class="line">    <span class="comment">//avg_age 为子聚合名称，名称可随意</span></span><br><span class="line">    aggregation.subAggregation(AggregationBuilders.avg(<span class="string">"avg_age"</span>).field(<span class="string">"age"</span>));  </span><br><span class="line">    </span><br><span class="line">    searchSourceBuilder.aggregation(aggregation);</span><br><span class="line">    searchRequest.source(searchSourceBuilder);</span><br><span class="line">    SearchResponse searchResponse = <span class="keyword">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        searchResponse = client.search(searchRequest, RequestOptions.DEFAULT);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取到聚合查询后的内容</span></span><br><span class="line">    Aggregations aggregations = searchResponse.getAggregations();</span><br><span class="line">    Terms byCompanyAggregation = aggregations.get(<span class="string">"by_sex"</span>);</span><br><span class="line">    Terms.Bucket elasticBucket = byCompanyAggregation.getBucketByKey(<span class="string">"女性"</span>);</span><br><span class="line">    Avg averageAge = elasticBucket.getAggregations().get(<span class="string">"avg_age"</span>);</span><br><span class="line">    <span class="keyword">double</span> avg = averageAge.getValue();</span><br><span class="line">    System.out.println(<span class="string">"女性平均年龄："</span>+avg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="匹配查询"><a href="#匹配查询" class="headerlink" title="匹配查询"></a>匹配查询</h3><blockquote>
<p><strong>SearchRequest</strong>： 查询请求对象</p>
<p><strong>SearchResponse</strong>：查询响应对象</p>
<p><strong>SearchSourceBuilder</strong>：查询源构建器</p>
<p><strong>MatchQueryBuilder</strong>：匹配查询构建器</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.连接rest接口</span></span><br><span class="line">HttpHost http=<span class="keyword">new</span> HttpHost(<span class="string">"127.0.0.1"</span>,<span class="number">9200</span>,<span class="string">"http"</span>);</span><br><span class="line">RestClientBuilder builder= RestClient.builder(http);<span class="comment">//rest构建器</span></span><br><span class="line">RestHighLevelClient restHighLevelClient=<span class="keyword">new</span> RestHighLevelClient(builder);<span class="comment">//高级客户端对象 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2.封装查询请求</span></span><br><span class="line">SearchRequest searchRequest=<span class="keyword">new</span> SearchRequest(<span class="string">"sku"</span>); <span class="comment">//查询的索引值</span></span><br><span class="line">searchRequest.types(<span class="string">"doc"</span>); <span class="comment">//设置查询的类型</span></span><br><span class="line"><span class="comment">//定义查询的条件</span></span><br><span class="line">SearchSourceBuilder searchSourceBuilder=<span class="keyword">new</span> SearchSourceBuilder();</span><br><span class="line">MatchQueryBuilder matchQueryBuilder= QueryBuilders.matchQuery(<span class="string">"name"</span>,<span class="string">"手机"</span>);</span><br><span class="line">searchSourceBuilder.query(matchQueryBuilder);</span><br><span class="line">searchRequest.source(searchSourceBuilder);</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.获取查询结果</span></span><br><span class="line">SearchResponse searchResponse = restHighLevelClient.search(searchRequest, RequestOptions.DEFAULT);</span><br><span class="line">SearchHits searchHits = searchResponse.getHits();</span><br><span class="line"><span class="comment">//获取记录数</span></span><br><span class="line"><span class="keyword">long</span> totalHits = searchHits.getTotalHits();</span><br><span class="line">System.out.println(<span class="string">"记录数："</span>+totalHits);</span><br><span class="line"><span class="comment">//获取到搜索结果总览对象hits</span></span><br><span class="line">SearchHit[] hits = searchHits.getHits();</span><br><span class="line"><span class="keyword">for</span>(SearchHit hit:hits)&#123;</span><br><span class="line">    <span class="comment">//文档的源数据source</span></span><br><span class="line">	String source = hit.getSourceAsString();</span><br><span class="line">	System.out.println(source);</span><br><span class="line">&#125;</span><br><span class="line">restHighLevelClient.close();</span><br></pre></td></tr></table></figure>

<h3 id="布尔与词条查询"><a href="#布尔与词条查询" class="headerlink" title="布尔与词条查询"></a>布尔与词条查询</h3><blockquote>
<p><strong>BoolQueryBuilder</strong>：布尔查询构建器</p>
<p><strong>TermQueryBuilder</strong>：词条查询构建器</p>
<p><strong>QueryBuilders</strong>：查询构建器工厂</p>
</blockquote>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//2.封装查询请求</span></span><br><span class="line">SearchRequest searchRequest=<span class="keyword">new</span> SearchRequest(<span class="string">"sku"</span>);</span><br><span class="line"><span class="comment">//设置查询的类型</span></span><br><span class="line">searchRequest.types(<span class="string">"doc"</span>); </span><br><span class="line"><span class="comment">//定义查询的条件，创建搜索源</span></span><br><span class="line">SearchSourceBuilder searchSourceBuilder=<span class="keyword">new</span> SearchSourceBuilder();</span><br><span class="line"><span class="comment">//布尔查询构建器</span></span><br><span class="line">BoolQueryBuilder boolQueryBuilder = QueryBuilders.boolQuery();</span><br><span class="line"><span class="comment">//查询条件 -- 匹配</span></span><br><span class="line">MatchQueryBuilder matchQueryBuilder= QueryBuilders.matchQuery(<span class="string">"name"</span>,<span class="string">"手机"</span>);</span><br><span class="line"><span class="comment">//布尔查询构建器嵌套 与条件</span></span><br><span class="line">boolQueryBuilder.must(matchQueryBuilder);</span><br><span class="line"><span class="comment">//查询条件 -- 词条</span></span><br><span class="line">TermQueryBuilder termQueryBuilder = QueryBuilders.termQuery(<span class="string">"brandName"</span>, <span class="string">"小米"</span>);</span><br><span class="line"><span class="comment">//布尔查询构建器嵌套 与条件</span></span><br><span class="line">boolQueryBuilder.must(termQueryBuilder);</span><br><span class="line"><span class="comment">//布尔查询构建器嵌套 与条件</span></span><br><span class="line">searchSourceBuilder.query(boolQueryBuilder);</span><br><span class="line"><span class="comment">//搜索源嵌套布尔查询构建器</span></span><br><span class="line">searchRequest.source(searchSourceBuilder);</span><br></pre></td></tr></table></figure>

<h3 id="过滤查询"><a href="#过滤查询" class="headerlink" title="过滤查询"></a>过滤查询</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//2.封装查询请求</span></span><br><span class="line">SearchRequest searchRequest=<span class="keyword">new</span> SearchRequest(<span class="string">"sku"</span>);</span><br><span class="line"><span class="comment">//设置查询的类型</span></span><br><span class="line">searchRequest.types(<span class="string">"doc"</span>); </span><br><span class="line"><span class="comment">//创建搜索源</span></span><br><span class="line">SearchSourceBuilder searchSourceBuilder=<span class="keyword">new</span> SearchSourceBuilder();</span><br><span class="line"><span class="comment">//布尔查询构建器</span></span><br><span class="line">BoolQueryBuilder boolQueryBuilder = QueryBuilders.boolQuery();</span><br><span class="line">TermQueryBuilder termQueryBuilder = QueryBuilders.termQuery(<span class="string">"brandName"</span>, <span class="string">"小米"</span>);</span><br><span class="line">boolQueryBuilder.filter(termQueryBuilder);</span><br><span class="line">searchSourceBuilder.query(boolQueryBuilder);</span><br><span class="line">searchRequest.source(searchSourceBuilder);</span><br></pre></td></tr></table></figure>

<h2 id="ElasticSearch-High-Level-REST-其他功能"><a href="#ElasticSearch-High-Level-REST-其他功能" class="headerlink" title="ElasticSearch High Level REST 其他功能"></a>ElasticSearch High Level REST 其他功能</h2><h3 id="Scroll-滚屏"><a href="#Scroll-滚屏" class="headerlink" title="Scroll 滚屏"></a>Scroll 滚屏</h3><p>ES中提供了 FROM/SIZE 分页，但这种分页有性能瓶颈。</p>
<p>Scroll会以间隔时间滚屏的方式返回全部的查询数据，可以作为数据量很大的情况下，分页的一个替代方案</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">scroll</span><span class="params">()</span></span>&#123;</span><br><span class="line">    RestHighLevelClient client = elasticClient.getRestHighLevelClient();</span><br><span class="line">    <span class="comment">//初始化scroll</span></span><br><span class="line">    <span class="keyword">final</span> Scroll scroll = <span class="keyword">new</span> Scroll(TimeValue.timeValueMinutes(<span class="number">1L</span>)); <span class="comment">//设定滚动时间间隔</span></span><br><span class="line">    SearchRequest searchRequest = <span class="keyword">new</span> SearchRequest();</span><br><span class="line">    searchRequest.scroll(scroll);</span><br><span class="line">    SearchSourceBuilder searchSourceBuilder = <span class="keyword">new</span> SearchSourceBuilder();</span><br><span class="line">    searchSourceBuilder.query(matchAllQuery());</span><br><span class="line">    <span class="comment">//设定每次返回多少条数据</span></span><br><span class="line">    searchSourceBuilder.size(<span class="number">5</span>); </span><br><span class="line">    searchRequest.source(searchSourceBuilder);</span><br><span class="line"></span><br><span class="line">    SearchResponse searchResponse = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        searchResponse = client.search(searchRequest, RequestOptions.DEFAULT);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//滚屏设置</span></span><br><span class="line">    String scrollId = searchResponse.getScrollId();</span><br><span class="line">    SearchHit[] searchHits = searchResponse.getHits().getHits();</span><br><span class="line">    System.out.println(<span class="string">"-----首页-----"</span>);</span><br><span class="line">    <span class="keyword">for</span> (SearchHit searchHit : searchHits) &#123;</span><br><span class="line">        System.out.println(searchHit.getSourceAsString());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//遍历搜索命中的数据，直到没有数据</span></span><br><span class="line">    <span class="keyword">while</span> (searchHits != <span class="keyword">null</span> &amp;&amp; searchHits.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        SearchScrollRequest scrollRequest = <span class="keyword">new</span> SearchScrollRequest(scrollId);</span><br><span class="line">        scrollRequest.scroll(scroll);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            searchResponse = client.scroll(scrollRequest, RequestOptions.DEFAULT);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        scrollId = searchResponse.getScrollId();</span><br><span class="line">        searchHits = searchResponse.getHits().getHits();</span><br><span class="line">        <span class="keyword">if</span> (searchHits != <span class="keyword">null</span> &amp;&amp; searchHits.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"-----下一页-----"</span>);</span><br><span class="line">            <span class="keyword">for</span> (SearchHit searchHit : searchHits) &#123;</span><br><span class="line">                System.out.println(searchHit.getSourceAsString());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//清除滚屏</span></span><br><span class="line">    ClearScrollRequest clearScrollRequest = <span class="keyword">new</span> ClearScrollRequest();</span><br><span class="line">    clearScrollRequest.addScrollId(scrollId);<span class="comment">//也可以选择setScrollIds()将多个scrollId一起使用</span></span><br><span class="line">    ClearScrollResponse clearScrollResponse = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        clearScrollResponse = client.clearScroll(clearScrollRequest,RequestOptions.DEFAULT);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">boolean</span> succeeded = clearScrollResponse.isSucceeded();</span><br><span class="line">    System.out.println(<span class="string">"succeeded:"</span> + succeeded);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="多搜索"><a href="#多搜索" class="headerlink" title="多搜索"></a>多搜索</h3><p>Multi-Search可同时添加多个search搜索请求，并行地在一个http请求中执行多个搜索请求，相较多次单请求查询可提升查询效率。ES客户掉通过mget方法实现多请求搜索</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">multiSearch</span><span class="params">()</span></span>&#123;</span><br><span class="line">    RestHighLevelClient client = elasticClient.getRestHighLevelClient();</span><br><span class="line">    <span class="comment">//Multi-Search请求</span></span><br><span class="line">    MultiSearchRequest request = <span class="keyword">new</span> MultiSearchRequest();</span><br><span class="line">    SearchRequest firstSearchRequest = <span class="keyword">new</span> SearchRequest();</span><br><span class="line">    SearchSourceBuilder firstBuilder = <span class="keyword">new</span> SearchSourceBuilder();</span><br><span class="line">    </span><br><span class="line">    firstBuilder.query(matchQuery(<span class="string">"name"</span>,<span class="string">"潇潇"</span>));</span><br><span class="line">    firstSearchRequest.source(firstBuilder);</span><br><span class="line">    request.add(firstSearchRequest);</span><br><span class="line">    </span><br><span class="line">    SearchRequest secondRequest = <span class="keyword">new</span> SearchRequest();</span><br><span class="line">    SearchSourceBuilder secondBuild = <span class="keyword">new</span> SearchSourceBuilder();</span><br><span class="line">    secondBuild.query(matchQuery(<span class="string">"position"</span>,<span class="string">"建筑师"</span>));</span><br><span class="line">    secondRequest.source(secondBuild);</span><br><span class="line">    </span><br><span class="line">    request.add(secondRequest);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        MultiSearchResponse multiResponse = client.msearch(request, RequestOptions.DEFAULT);</span><br><span class="line">        MultiSearchResponse.Item firstItem  = multiResponse.getResponses()[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span> (firstItem.getFailure() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"第一个请求失败！"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        SearchResponse firstResponse = firstItem.getResponse();</span><br><span class="line">        <span class="keyword">for</span> (SearchHit documentFields : firstResponse.getHits().getHits()) &#123;</span><br><span class="line">            System.out.println(<span class="string">"第一个查询请求返回："</span>+documentFields.getSourceAsString());</span><br><span class="line">        &#125;</span><br><span class="line">        MultiSearchResponse.Item seconditem = multiResponse.getResponses()[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (seconditem.getFailure() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"第二个请求失败！"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        SearchResponse secondResponse = seconditem.getResponse();</span><br><span class="line">        <span class="keyword">for</span> (SearchHit documentFields : secondResponse.getHits().getHits()) &#123;</span><br><span class="line">            System.out.println(<span class="string">"第二的查询请求返回："</span> + documentFields.getSourceAsString());</span><br><span class="line">        &#125;</span><br><span class="line">        client.close();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="使用模板搜索"><a href="#使用模板搜索" class="headerlink" title="使用模板搜索"></a>使用模板搜索</h3><p>ElasticSearch 还提供了通过模板搜索查询</p>
<p>可以通过脚本预选注册模板，在注册模板时定义一个模板名称。在查询时通过模板名称调用该模板。首先演示下如何注册模板：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registTemplate</span><span class="params">()</span></span>&#123;</span><br><span class="line">    RestClient restClient = elasticClient.getRestClient();</span><br><span class="line">    String template = <span class="string">"&#123;\n"</span> +</span><br><span class="line">        <span class="string">"  \"script\":&#123;\n"</span> +</span><br><span class="line">        <span class="string">"    \"lang\":\"mustache\",\n"</span> +</span><br><span class="line">        <span class="string">"    \"source\":&#123;\n"</span> +</span><br><span class="line">        <span class="string">"      \"query\":&#123;\n"</span> +</span><br><span class="line">        <span class="string">"        \"match\":&#123;\n"</span> +</span><br><span class="line">        <span class="string">"          \"&#123;&#123;key&#125;&#125;\":\"&#123;&#123;value&#125;&#125;\"\n"</span> +</span><br><span class="line">        <span class="string">"        &#125;\n"</span> +</span><br><span class="line">        <span class="string">"      &#125;,\n"</span> +</span><br><span class="line">        <span class="string">"      \"size\":\"&#123;&#123;size&#125;&#125;\"\n"</span> +</span><br><span class="line">        <span class="string">"    &#125;\n"</span> +</span><br><span class="line">        <span class="string">"  &#125;\n"</span> +</span><br><span class="line">        <span class="string">"&#125;"</span>;</span><br><span class="line">    Request scriptRequest1 = <span class="keyword">new</span> Request(<span class="string">"POST"</span>, <span class="string">"_scripts/title_search"</span>);</span><br><span class="line">    scriptRequest1.setJsonEntity(template);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        restClient.performRequest(scriptRequest1);</span><br><span class="line">        restClient.close();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>由于ElasticSearch 6.5版本的高级Rest API中暂时还没有提供用于注册模板的存储脚本，所以本示例中使用的低级REST客户端。本示例中注册了一个名为“title_search”的模板</p>
<p>有了这个模板就可以通过“<strong>title_search</strong>”去调用，动态的将查询参数添加到模板中去。模板调用示例如下：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">templateSearch</span><span class="params">()</span></span>&#123;</span><br><span class="line">    RestHighLevelClient client = elasticClient.getRestHighLevelClient();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        SearchTemplateRequest request = <span class="keyword">new</span> SearchTemplateRequest();</span><br><span class="line">        request.setRequest(<span class="keyword">new</span> SearchRequest(<span class="string">"posts"</span>));</span><br><span class="line">        <span class="comment">//调用模板</span></span><br><span class="line">        request.setScriptType(ScriptType.STORED);</span><br><span class="line">        request.setScript(<span class="string">"title_search"</span>);</span><br><span class="line"></span><br><span class="line">        Map&lt;String, Object&gt; params = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        params.put(<span class="string">"key"</span>, <span class="string">"name"</span>);</span><br><span class="line">        params.put(<span class="string">"value"</span>, <span class="string">"福卖福"</span>);</span><br><span class="line">        params.put(<span class="string">"size"</span>, <span class="number">5</span>);</span><br><span class="line">        request.setScriptParams(params);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            SearchTemplateResponse searchTemplateResponse = client.searchTemplate(request, RequestOptions.DEFAULT);</span><br><span class="line">            SearchHit[] hits = searchTemplateResponse.getResponse().getHits().getHits();</span><br><span class="line">            <span class="keyword">for</span> (SearchHit hit : hits) &#123;</span><br><span class="line">                System.out.println(hit.getSourceAsString());</span><br><span class="line">            &#125;</span><br><span class="line">            client.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>针对每个模板我们执行一次搜索请求，如果我们工作中针对同一模板可能会有不止一次的请求，如果每个请求都去单独执行的话未免有点繁琐。我们可以通过msearchTemplate来实现一次请求实现多条搜索，示例如下</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">multiTemplateSearch</span><span class="params">()</span></span>&#123;</span><br><span class="line">    RestHighLevelClient client = elasticClient.getRestHighLevelClient();</span><br><span class="line">    String [] searchTerms = &#123;<span class="string">"周大福"</span>, <span class="string">"特博士"</span>, <span class="string">"詹姆斯"</span>&#125;; <span class="comment">// 要搜索的条件</span></span><br><span class="line">    MultiSearchTemplateRequest multiRequest = <span class="keyword">new</span> MultiSearchTemplateRequest();</span><br><span class="line">    <span class="keyword">for</span> (String searchTerm : searchTerms) &#123;</span><br><span class="line">        SearchTemplateRequest request = <span class="keyword">new</span> SearchTemplateRequest();</span><br><span class="line">        request.setRequest(<span class="keyword">new</span> SearchRequest(<span class="string">"posts"</span>)); <span class="comment">//指定为posts索引库</span></span><br><span class="line"></span><br><span class="line">        request.setScriptType(ScriptType.INLINE);</span><br><span class="line">        request.setScript(</span><br><span class="line">            <span class="string">"&#123;\n"</span> +</span><br><span class="line">            <span class="string">"  \"query\":&#123;\n"</span> +</span><br><span class="line">            <span class="string">"    \"match\":&#123;\n"</span> +</span><br><span class="line">            <span class="string">"      \"&#123;&#123;key&#125;&#125;\":\"&#123;&#123;value&#125;&#125;\"\n"</span> +</span><br><span class="line">            <span class="string">"    &#125;\n"</span> +</span><br><span class="line">            <span class="string">"  &#125;,\n"</span> +</span><br><span class="line">            <span class="string">"  \"size\":\"&#123;&#123;size&#125;&#125;\"\n"</span> +</span><br><span class="line">            <span class="string">"&#125;"</span>);</span><br><span class="line"></span><br><span class="line">        Map&lt;String, Object&gt; scriptParams = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="comment">//向模板中填充对应值</span></span><br><span class="line">        scriptParams.put(<span class="string">"key"</span>, <span class="string">"name"</span>);</span><br><span class="line">        scriptParams.put(<span class="string">"value"</span>, searchTerm);</span><br><span class="line">        scriptParams.put(<span class="string">"size"</span>, <span class="number">5</span>);</span><br><span class="line">        request.setScriptParams(scriptParams);</span><br><span class="line"></span><br><span class="line">        multiRequest.add(request);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//执行查询</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        MultiSearchTemplateResponse multiResponse = client.msearchTemplate(multiRequest, RequestOptions.DEFAULT);</span><br><span class="line">        <span class="comment">//返回一组响应 ，每个请求对应一个响应</span></span><br><span class="line">        <span class="keyword">for</span> (MultiSearchTemplateResponse.Item item : multiResponse.getResponses()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (item.isFailure()) &#123;</span><br><span class="line">                String error = item.getFailureMessage(); <span class="comment">//搜索请求失败返回错误信息</span></span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                SearchTemplateResponse searchTemplateResponse = item.getResponse();</span><br><span class="line">                SearchResponse response = searchTemplateResponse.getResponse();</span><br><span class="line">                SearchHits hits = response.getHits();</span><br><span class="line">                System.out.println(<span class="string">"----------"</span>);</span><br><span class="line">                <span class="keyword">for</span> (SearchHit hit : hits) &#123;</span><br><span class="line">                    System.out.println(hit.getSourceAsString());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="获取集群信息"><a href="#获取集群信息" class="headerlink" title="获取集群信息"></a>获取集群信息</h3><p> ElasticSearch 可以通过<code>info()</code>方法检索群集信息：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">info</span><span class="params">()</span></span>&#123;</span><br><span class="line">    RestHighLevelClient client = elasticClient.getRestHighLevelClient();</span><br><span class="line">    MainResponse response = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        response = client.info(RequestOptions.DEFAULT);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回集群的各种信息</span></span><br><span class="line">    ClusterName clusterName = response.getClusterName(); <span class="comment">//集群名称</span></span><br><span class="line">    String clusterUuid = response.getClusterUuid(); <span class="comment">//群集的唯一标识符</span></span><br><span class="line">    String nodeName = response.getNodeName(); <span class="comment">//已执行请求的节点的名称</span></span><br><span class="line">    Version version = response.getVersion(); <span class="comment">//已执行请求的节点的版本</span></span><br><span class="line">    Build build = response.getBuild(); <span class="comment">//已执行请求的节点的构建信息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>通过使用ping()</code>方法可以检查集群是否连接成功，并返回一个布尔值：</p>
<figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">boolean</span> response = client.ping（RequestOptions.DEFAULT）;</span><br></pre></td></tr></table></figure>

<h2 id="相关博客推荐"><a href="#相关博客推荐" class="headerlink" title="相关博客推荐"></a>相关博客推荐</h2><ul>
<li><a href="http://www.cnblogs.com/ljhdo/p/4887557.html" target="_blank" rel="noopener">ElasticSearch入门 第一篇：Windows下安装ElasticSearch</a></li>
<li><a href="http://www.cnblogs.com/ljhdo/p/4959412.html" target="_blank" rel="noopener">ElasticSearch入门 第二篇：集群配置</a></li>
<li><a href="http://www.cnblogs.com/ljhdo/p/4981928.html" target="_blank" rel="noopener">ElasticSearch入门 第三篇：索引</a></li>
<li><a href="http://www.cnblogs.com/ljhdo/p/5160329.html" target="_blank" rel="noopener">ElasticSearch入门 第四篇：使用C#添加和更新文档</a></li>
<li><a href="http://www.cnblogs.com/ljhdo/p/4550135.html" target="_blank" rel="noopener">ElasticSearch入门 第五篇：使用C#查询文档</a></li>
<li><a href="http://www.cnblogs.com/ljhdo/p/4904430.html" target="_blank" rel="noopener">ElasticSearch入门 第六篇：复合数据类型——数组，对象和嵌套</a></li>
<li><a href="http://www.cnblogs.com/ljhdo/p/5012510.html" target="_blank" rel="noopener">ElasticSearch入门 第七篇：分析器</a></li>
<li><a href="http://www.cnblogs.com/ljhdo/p/5016852.html" target="_blank" rel="noopener">ElasticSearch入门 第八篇：存储</a></li>
<li><a href="http://www.cnblogs.com/ljhdo/p/4911878.html" target="_blank" rel="noopener">ElasticSearch入门 第九篇：实现正则表达式查询的思路</a></li>
<li><a href="http://www.cnblogs.com/ljhdo/p/4486978.html" target="_blank" rel="noopener">ElasticSearch查询 第一篇：搜索API</a></li>
<li><a href="http://www.cnblogs.com/ljhdo/p/4885796.html" target="_blank" rel="noopener">ElasticSearch查询 第二篇：文档更新</a></li>
<li><a href="http://www.cnblogs.com/ljhdo/p/4551490.html" target="_blank" rel="noopener">ElasticSearch查询 第三篇：词条查询</a></li>
<li><a href="http://www.cnblogs.com/ljhdo/p/4577065.html" target="_blank" rel="noopener">ElasticSearch查询 第四篇：匹配查询（Match）</a></li>
<li><a href="http://www.cnblogs.com/ljhdo/p/5040252.html" target="_blank" rel="noopener">ElasticSearch查询 第五篇：布尔查询</a></li>
<li><a href="https://www.cnblogs.com/fnlingnzb-learner/p/10750868.html" target="_blank" rel="noopener">使用Java High Level REST Client操作elasticsearch</a></li>
<li><a href="https://www.cnblogs.com/ginb/p/8696090.html" target="_blank" rel="noopener">使用Java客户端操作elasticsearch（二）</a></li>
<li><a href="https://www.cnblogs.com/reycg-blog/p/9931482.html" target="_blank" rel="noopener">Elasticsearch Java Rest Client API 整理总结 (一)——Document API</a></li>
<li><a href="https://www.cnblogs.com/reycg-blog/p/9946821.html" target="_blank" rel="noopener">Elasticsearch Java Rest Client API 整理总结 (二) —— SearchAPI</a></li>
<li><a href="https://www.cnblogs.com/reycg-blog/p/9993094.html" target="_blank" rel="noopener">Elasticsearch Java Rest Client API 整理总结 (三)——Building Queries</a></li>
<li><a href="https://www.cnblogs.com/reycg-blog/p/10000052.html" target="_blank" rel="noopener">Elasticsearch Query DSL 整理总结（一）—— Query DSL 概要，MatchAllQuery，全文查询简述</a></li>
<li><a href="https://www.cnblogs.com/reycg-blog/p/10002794.html" target="_blank" rel="noopener">Elasticsearch Query DSL 整理总结（二）MatchAllQuery详解</a></li>
<li><a href="https://www.cnblogs.com/reycg-blog/p/10012238.html" target="_blank" rel="noopener">Elasticsearch Query DSL 整理总结（三）—— Match Phrase Query 和 Match Phrase Prefix Query</a></li>
<li><a href="https://www.cnblogs.com/reycg-blog/p/10055039.html" target="_blank" rel="noopener">Elasticsearch Query DSL 整理总结（四）—— Multi Match Query</a></li>
</ul>
<ul>
<li><p>官网链接</p>
<p>Elasticsearch: 权威指南：<a href="https://www.elastic.co/guide/cn/elasticsearch/guide/current/index.html" target="_blank" rel="noopener">https://www.elastic.co/guide/cn/elasticsearch/guide/current/index.html</a></p>
<p> Java REST Client： <a href="https://www.elastic.co/guide/en/elasticsearch/client/java-rest/6.3/index.html" target="_blank" rel="noopener">https://www.elastic.co/guide/en/elasticsearch/client/java-rest/6.3/index.html</a>：</p>
</li>
</ul>
<p>over</p>
</div></article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta">Author: </span><span class="post-copyright-info"><a href="mailto:undefined">Willis J</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta">Link: </span><span class="post-copyright-info"><a href="https://jigw24.github.io/2019/07/04/Elasticsearch学习备忘/">https://jigw24.github.io/2019/07/04/Elasticsearch学习备忘/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta">Copyright Notice: </span><span class="post-copyright-info">All articles in this blog are licensed under <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/">CC BY-NC-SA 4.0</a> unless stating additionally.</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/elasticsearch/">elasticsearch    </a></div><div class="post_share"><div class="social-share" data-image="https://i.loli.net/2019/07/17/5d2f0b56d170e62593.jpeg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/css/share.min.css"><script src="https://cdn.jsdelivr.net/npm/social-share.js@1.0.16/dist/js/social-share.min.js"></script></div></div><nav class="pagination_post" id="pagination"><div class="prev-post pull-left"><a href="/2019/07/04/消息和RabbitMQ/"><img class="prev_cover lozad" data-src="https://i.loli.net/2019/07/11/5d270ff6496b691756.jpg,https://i.loli.net/2019/07/11/5d270ff7b92f320805.jpg,https://i.loli.net/2019/07/11/5d270ffba6dbe36324.jpg,https://i.loli.net/2019/07/11/5d270ffc69d8a18039.jpg,https://i.loli.net/2019/07/14/5d2b07f573b4d29311.jpg,https://i.loli.net/2019/07/14/5d2b07f58667557623.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="label">Previous Post</div><div class="prev_info"><span>消息中间件和RabbitMQ相关备忘</span></div></a></div><div class="next-post pull-right"><a href="/2019/06/18/SpringDataRedis备忘/"><img class="next_cover lozad" data-src="https://i.loli.net/2019/07/11/5d270ff6496b691756.jpg,https://i.loli.net/2019/07/11/5d270ff7b92f320805.jpg,https://i.loli.net/2019/07/11/5d270ffba6dbe36324.jpg,https://i.loli.net/2019/07/11/5d270ffc69d8a18039.jpg,https://i.loli.net/2019/07/14/5d2b07f573b4d29311.jpg,https://i.loli.net/2019/07/14/5d2b07f58667557623.jpg" onerror="onerror=null;src='/img/404.jpg'"><div class="label">Next Post</div><div class="next_info"><span>SpringDataRedis实现缓存问题的解决</span></div></a></div></nav><div class="relatedPosts"><div class="relatedPosts_headline"><i class="fa fa-thumbs-up" aria-hidden="true"></i><span> Recommend</span></div><div class="relatedPosts_list"></div><div class="clear_both"></div></div><hr><div id="post-comment"><div class="comment_headling"><i class="fa fa-comments fa-fw" aria-hidden="true"></i> <span>Comment</span></div><div class="vcomment" id="vcomment"></div><script src="https://cdn.jsdelivr.net/npm/valine/dist/Valine.min.js"></script><script>var notify = 'false' == true ? true : false;
var verify = 'false' == true ? true : false;
var GUEST_INFO = ['nick','mail','link'];
var guest_info = 'nick,mail,link'.split(',').filter(function(item){
  return GUEST_INFO.indexOf(item) > -1
});
guest_info = guest_info.length == 0 ? GUEST_INFO :guest_info;

window.valine = new Valine({
  el:'#vcomment',
  notify:notify,
  verify:verify,
  appId:'XO0jozUWbKq88eANuQma5BKv-gzGzoHsz',
  appKey:'BQnAawulBKcFBNOB4Q7sHTTe',
  placeholder:'Please leave your footprints',
  avatar:'monsterid',
  guest_info:guest_info,
  pageSize:'10',
  lang:'en',
  recordIP: true
});</script></div></div></div><footer><div class="layout" id="footer"><div class="copyright">&copy;2017 - 2019 By Willis J</div><div class="framework-info"><span>Driven </span><a href="http://hexo.io"><span>Hexo</span></a><span class="footer-separator">|</span><span>Theme </span><a href="https://github.com/jerryc127/hexo-theme-butterfly"><span>Butterfly</span></a></div><div class="footer_custom_text">欢迎您呀</div></div></footer><i class="fa fa-arrow-up" id="go-up" aria-hidden="true"></i><section class="rightside" id="rightside"><i class="fa fa-book" id="readmode" title="Read Mode"> </i><i class="fa fa-plus" id="font_plus" title="Increase font size"></i><i class="fa fa-minus" id="font_minus" title="Decrease font size"></i><a class="translate_chn_to_cht" id="translateLink" href="javascript:translatePage();" title="Traditional Chinese and Simplified Chinese Conversion">簡</a><i class="fa fa-moon-o nightshift" id="nightshift" title="Dark Mode"></i></section><script src="https://cdn.jsdelivr.net/npm/jquery@latest/dist/jquery.min.js"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@latest/dist/jquery.fancybox.min.js"></script><script src="https://cdn.jsdelivr.net/npm/js-cookie@2/src/js.cookie.min.js"></script><script src="https://cdn.jsdelivr.net/npm/lozad/dist/lozad.min.js"></script><script src="/js/utils.js"></script><script src="/js/main.js"></script><script async src="/js/search/local-search.js"></script><script src="/js/nightshift.js"></script><script id="ribbon" src="https://cdn.jsdelivr.net/gh/jerryc127/CDN@latest/js/piao.js"></script><script src="/js/tw_cn.js"></script><script>translateInitilization()

</script><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script><script src="https://cdn.jsdelivr.net/npm/instant.page@1.2.2/instantpage.min.js" type="module"></script><div class="search-dialog" id="local-search"><div class="search-dialog__title" id="local-search-title">Local search</div><div id="local-input-panel"><div id="local-search-input"><div class="local-search-box"><input class="local-search-box--input" placeholder="Search for Posts"></div></div></div><hr><div id="local-search-results"><div id="local-hits"></div><div id="local-stats"><div class="local-search-stats__hr" id="hr"><span>Powered by</span> <a href="https://github.com/wzpan/hexo-generator-search" style="color:#49B1F5;">hexo-generator-search</a></div></div></div><span class="search-close-button"><i class="fa fa-times"></i></span></div><div class="search-mask"></div></body></html>