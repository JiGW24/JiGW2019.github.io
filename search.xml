<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Redis实现消息队列</title>
      <link href="/2019/07/10/Redis%E5%AE%9E%E7%8E%B0%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/"/>
      <url>/2019/07/10/Redis%E5%AE%9E%E7%8E%B0%E6%B6%88%E6%81%AF%E9%98%9F%E5%88%97/</url>
      
        <content type="html"><![CDATA[<p>既然Redis可以重当消息中间件，还去用RabbitMQ等干嘛，这里就试着学习下Redis实现消息队列。</p><h2 id="订阅与发布"><a href="#订阅与发布" class="headerlink" title="订阅与发布"></a>订阅与发布</h2><p>先来看一下redis发布和订阅(pub/sub)，它是一种消息通信模式。即发送者(pub)发送消息，订阅者(sub)接收消息。Redis 客户端可以订阅任意数量的频道。</p><p>这里可以参考<a href="https://redis.io/topics/pubsub" target="_blank" rel="noopener">官网</a>，放下命令行看下结果</p><pre><code>127.0.0.1:6379&gt; publish cctv &quot;nba&quot;(integer) 2127.0.0.1:6379&gt; subscribe cctvReading messages... (press Ctrl-C to quit)1) &quot;subscribe&quot;2) &quot;cctv&quot;3) (integer) 11) &quot;message&quot;2) &quot;cctv&quot;3) &quot;nba&quot;127.0.0.1:6379&gt; subscribe cctvReading messages... (press Ctrl-C to quit)1) &quot;subscribe&quot;2) &quot;cctv&quot;3) (integer) 11) &quot;message&quot;2) &quot;cctv&quot;3) &quot;nba&quot;</code></pre><h2 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h2><p>这个暂时不太了解，推荐一篇博文</p><p><a href="https://blog.csdn.net/zuoanyinxiang/article/details/50263945" target="_blank" rel="noopener">https://blog.csdn.net/zuoanyinxiang/article/details/50263945</a></p>]]></content>
      
      
      <categories>
          
          <category> 技术栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> MQ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>消息中间件和RabbitMQ相关备忘</title>
      <link href="/2019/07/04/%E6%B6%88%E6%81%AF%E5%92%8CRabbitMQ/"/>
      <url>/2019/07/04/%E6%B6%88%E6%81%AF%E5%92%8CRabbitMQ/</url>
      
        <content type="html"><![CDATA[<h2 id="消息中间件"><a href="#消息中间件" class="headerlink" title="消息中间件"></a>消息中间件</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>消息中间件（消息队列）是分布式系统中重要的组件，主要解决应用耦合，异步消息，流量削锋等问题实现高性能，高可用，可伸缩和最终一致性[架构]   使用较多的消息队列有ActiveMQ，RabbitMQ，ZeroMQ，Kafka，MetaMQ，RocketMQ</p><p>关于消息中间件的各种面试题：<a href="https://jsbintask.cn/2019/01/28/interview/interview-middleware-jms/" target="_blank" rel="noopener">https://jsbintask.cn/2019/01/28/interview/interview-middleware-jms/</a></p><h3 id="应用场景"><a href="#应用场景" class="headerlink" title="应用场景"></a>应用场景</h3><ul><li>异步处理</li><li>应用解耦</li><li>流量削锋</li><li>消息通讯<br>这里在网上看到一篇比较具体的<a href="https://www.cnblogs.com/ruiati/p/6649868.html" target="_blank" rel="noopener">博文</a>,有时间自己再写下来。</li></ul><h2 id="RabbitMQ"><a href="#RabbitMQ" class="headerlink" title="RabbitMQ"></a>RabbitMQ</h2><h3 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h3><p>RabbitMQ 是一个由 Erlang 语言开发的 AMQP 的开源实现。</p><blockquote><p>AMQP ：Advanced Message Queue，高级消息队列协议。它是应用层协议的一个开放标准，为面向消息的中间件设计，基于此协议的客户端与消息中间件可传递消息，并不受产品、开发语言等条件的限制。</p></blockquote><h3 id="主要概念"><a href="#主要概念" class="headerlink" title="主要概念"></a>主要概念</h3><p><strong>RabbitMQ Server：</strong> 也叫broker server，它是一种传输服务。 他的角色就是维护一条从Producer到Consumer的路线，保证数据能够按照指定的方式进行传输。</p><p><strong>Producer：</strong> 消息生产者，如图A、B、C，数据的发送方。消息生产者连接RabbitMQ服务器然后将消息投递到Exchange。</p><p><strong>Consumer：</strong>消息消费者，如图1、2、3，数据的接收方。消息消费者订阅队列，RabbitMQ将Queue中的消息发送到消息消费者。</p><p><strong>Exchange：</strong>生产者将消息发送到Exchange（交换器），由Exchange将消息路由到一个或多个Queue中（或者丢弃）。Exchange并不存储消息。RabbitMQ中的Exchange有direct、fanout、topic、headers四种类型，每种类型对应不同的路由规则。</p><p><strong>Queue：</strong>（队列）是RabbitMQ的内部对象，用于存储消息。消息消费者就是通过订阅队列来获取消息的，RabbitMQ中的消息都只能存储在Queue中，生产者生产消息并最终投递到Queue中，消费者可以从Queue中获取消息并消费。多个消费者可以订阅同一个Queue，这时Queue中的消息会被平均分摊给多个消费者进行处理，而不是每个消费者都收到所有的消息并处理。</p><p><strong>RoutingKey：</strong>生产者在将消息发送给Exchange的时候，一般会指定一个routing key，来指定这个消息的路由规则，而这个routing key需要与Exchange Type及binding key联合使用才能最终生效。在Exchange Type与binding key固定的情况下（在正常使用时一般这些内容都是固定配置好的），我们的生产者就可以在发送消息给Exchange时，通过指定routing key来决定消息流向哪里。RabbitMQ为routing key设定的长度限制为255 bytes。</p><p><strong>Connection： （连接）</strong>：Producer和Consumer都是通过TCP连接到RabbitMQ Server的。以后我们可以看到，程序的起始处就是建立这个TCP连接。</p><p><strong>Channels： （信道）</strong>：它建立在上述的TCP连接中。数据流动都是在Channel中进行的。也就是说，一般情况是程序起始建立TCP连接，第二步就是建立这个Channel。</p><p><strong>VirtualHost：</strong>权限控制的基本单位，一个VirtualHost里面有若干Exchange和MessageQueue，以及指定被哪些user使用</p><h3 id="RabbitMQ发送和接收消息"><a href="#RabbitMQ发送和接收消息" class="headerlink" title="RabbitMQ发送和接收消息"></a>RabbitMQ发送和接收消息</h3><p>这里有三种模式</p><h4 id="直接模式-Direct"><a href="#直接模式-Direct" class="headerlink" title="直接模式 Direct"></a>直接模式 Direct</h4><blockquote><p>我们需要将消息发送给唯一一个节点时使用这种模式</p></blockquote><p><img src="https://i.loli.net/2019/07/13/5d29b6822c16f95212.jpg" alt></p><p>任何发送到Direct Exchange的消息都会被转发到RouteKey中指定的Queue。</p><p>1.一般情况可以使用rabbitMQ自带的Exchange：””(该Exchange的名字为空字符串，下文称其为default Exchange)。</p><p>2.这种模式下可以不需要将Exchange进行任何绑定(binding)操作</p><p>3.消息传递时需要一个“RouteKey”，可以简单的理解为要发送到的队列名字。</p><p>4.如果vhost中不存在RouteKey中指定的队列名，则该消息会被抛弃。</p><h4 id="分列模式-Fanout"><a href="#分列模式-Fanout" class="headerlink" title="分列模式 Fanout"></a>分列模式 Fanout</h4><blockquote><p>我们需要将消息一次发给多个队列时需要使用这种模式</p></blockquote><p><img src="https://i.loli.net/2019/07/13/5d29b68598a1e48249.jpg" alt></p><p>任何发送到Fanout Exchange的消息都会被转发到与该Exchange绑定(Binding)的所有Queue上。</p><p>1.这种模式需要提前将Exchange与Queue进行绑定，一个Exchange可以绑定多个Queue，一个Queue可以同多个Exchange进行绑定(点击你的exchange—Bindings绑定即可)</p><p>2.这种模式不需要RouteKey</p><p>3.如果接受到消息的Exchange没有与任何Queue绑定，则消息会被抛弃。</p><h4 id="主题模式-Topic"><a href="#主题模式-Topic" class="headerlink" title="主题模式 Topic"></a>主题模式 Topic</h4><p>了解到还有第三种</p><blockquote><p>任何发送到Topic Exchange的消息都会被转发到所有关心RouteKey中指定话题的Queue上</p></blockquote><p><img src="https://i.loli.net/2019/07/13/5d29b713f300e95499.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> 技术栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MQ </tag>
            
            <tag> RabbitMQ </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Elasticsearch学习备忘</title>
      <link href="/2019/07/04/Elasticsearch%E5%AD%A6%E4%B9%A0%E5%A4%87%E5%BF%98/"/>
      <url>/2019/07/04/Elasticsearch%E5%AD%A6%E4%B9%A0%E5%A4%87%E5%BF%98/</url>
      
        <content type="html"><![CDATA[<p>本文由zhoulu整理，感谢</p><h2 id="Elasticsearch学习记录"><a href="#Elasticsearch学习记录" class="headerlink" title="Elasticsearch学习记录"></a>Elasticsearch学习记录</h2><blockquote><p>1、Elasticsearch的特点</p><ul><li>可以分布式集群，对海量数据进行近实时的处理；</li><li>对用户而言，开箱即用,非常简单。如果数据量不大，操作不会太复杂；</li><li>具有关系型数据库没有的功能，比如全文检索，同义词处理，相关度排名，复杂数据分析，海量数据的近实时处理；</li><li>基于lucene，隐藏了复杂性，提供简单易用的restful api接口、java api接口</li></ul><p>2、elasticsearch的核心概念</p><ul><li>Cluster：集群包含多个节点，每个节点属于哪个集群是通过配置来决定的（默认是elasticsearch）</li><li>Node：集群中的一个节点，节点默认会自动加入名叫”elasticsearch”的集群。一个elasticsearch服务就是一个节点，比如一台机器启动两个es服务，就有两个节点。</li><li>Index:索引，相当于mysql的数据库，包含一堆有相似结构的文档数据。</li><li>Type:类型，相当于mysql的表，index中的一个逻辑数据分类。</li><li>document:文档，相当于mysql表中的一行记录，是es中的最小数据单元。</li><li>shard:分片，单台机器无法存储大量数据，es可以将一个索引中的数据切分为多个shard，分布在多台服务器上存储。</li><li>replica:副本，为了防止宕机，shard丢失，所以最小的高可用配置，是2台服务器。</li></ul></blockquote><h2 id="与Elasticsearch交互"><a href="#与Elasticsearch交互" class="headerlink" title="与Elasticsearch交互"></a>与Elasticsearch交互</h2><h3 id="Java-API"><a href="#Java-API" class="headerlink" title="Java API"></a>Java API</h3><ul><li><p><strong>节点客户端(node client)：</strong></p><p>节点客户端以无数据节点(none data node)身份加入集群，换言之，它自己不存储任何数据，但是它知道数据在集群中的具体位置，并且能够直接转发请求到对应的节点上。</p></li><li><p><strong>传输客户端(Transport client)：</strong></p><p>这个更轻量的传输客户端能够发送请求到远程集群。它自己不加入集群，只是简单转发请求给集群中的节点。</p><p>两个Java客户端都通过9300端口与集群交互，使用Elasticsearch传输协议(Elasticsearch Transport Protocol)。集群中的节点之间也通过9300端口进行通信。如果此端口未开放，你的节点将不能组成集群。</p><blockquote><p><strong>TIP</strong></p><p>Java客户端所在的Elasticsearch版本必须与集群中其他节点一致，否则，它们可能互相无法识别。</p></blockquote><p>关于Java API的更多信息请查看相关章节：<a href="http://www.elasticsearch.org/guide/" target="_blank" rel="noopener">Java API</a></p></li></ul><h3 id="基于HTTP协议"><a href="#基于HTTP协议" class="headerlink" title="基于HTTP协议"></a>基于HTTP协议</h3><ul><li><p>==以<strong>JSON</strong>为数据交互格式的<strong>RESTful API</strong>==，通过9200端口的与Elasticsearch进行通信，</p><blockquote><p>Elasticsearch官方提供了多种程序语言的客户端——Groovy，Javascript， .NET，PHP，Perl，Python，以及Ruby——还有很多由社区提供的客户端和插件，所有这些可以在<a href="http://www.elasticsearch.org/guide/" target="_blank" rel="noopener">文档</a>中找到。</p></blockquote></li><li><p>向Elasticsearch发出的请求的组成部分与其它普通的HTTP请求是一样的：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">curl -X&lt;VERB&gt; <span class="string">'&lt;PROTOCOL&gt;://&lt;HOST&gt;:&lt;PORT&gt;/&lt;PATH&gt;?&lt;QUERY_STRING&gt;'</span> -d <span class="string">'&lt;BODY&gt;'</span></span><br></pre></td></tr></table></figure><ul><li>VERB HTTP方法：<code>GET</code>, <code>POST</code>, <code>PUT</code>, <code>HEAD</code>,<code>DELETE</code></li><li>PROTOCOL http或者https协议（只有在Elasticsearch前面有https代理的时候可用）</li><li>HOST Elasticsearch集群中的任何一个节点的主机名，如果是在本地的节点，那么就叫localhost</li><li>PORT Elasticsearch HTTP服务所在的端口，默认为9200</li><li>PATH API路径（例如_count将返回集群中文档的数量），PATH可以包含多个组件，例如_cluster/stats或者_nodes/stats/jvm</li><li>QUERY_STRING一些可选的查询请求参数，例如<code>?pretty</code>参数将使请求返回更加美观易读的JSON数据</li><li>BODY 一个JSON格式的请求主体（如果请求需要的话）</li></ul></li></ul><p>  举例说明，为了计算集群中的文档数量，我们可以这样做：</p>  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">curl -XGET <span class="string">'http://localhost:9200/_count?pretty'</span> -d <span class="string">'</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">    "query": &#123;</span></span><br><span class="line"><span class="string">        "match_all": &#123;&#125;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br><span class="line"><span class="string">'</span></span><br></pre></td></tr></table></figure><p>  Elasticsearch返回一个类似<code>200 OK</code>的HTTP状态码和JSON格式的响应主体（除了<code>HEAD</code>请求）。上面的请求会得到如下的JSON格式的响应主体：</p>  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="string">"count"</span> : <span class="number">0</span>,</span><br><span class="line">    <span class="string">"_shards"</span> : &#123;</span><br><span class="line">        <span class="string">"total"</span> : <span class="number">5</span>,</span><br><span class="line">        <span class="string">"successful"</span> : <span class="number">5</span>,</span><br><span class="line">        <span class="string">"failed"</span> : <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>  我们看不到HTTP头是因为我们没有让<code>curl</code>显示它们，如果要显示，使用<code>curl</code>命令后跟<code>-i</code>参数:</p>  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">curl -i -XGET <span class="string">'localhost:9200/'</span></span><br></pre></td></tr></table></figure><p>  一个完整的请求形如：</p>  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">curl -XGET <span class="string">'localhost:9200/_count?pretty'</span> -d <span class="string">'</span></span><br><span class="line"><span class="string">&#123;</span></span><br><span class="line"><span class="string">    "query": &#123;</span></span><br><span class="line"><span class="string">        "match_all": &#123;&#125;</span></span><br><span class="line"><span class="string">    &#125;</span></span><br><span class="line"><span class="string">&#125;'</span></span><br></pre></td></tr></table></figure><p>  我们将<strong>简写</strong>成这样：</p>  <figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">GET /_count</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"query"</span>: &#123;</span><br><span class="line">        <span class="string">"match_all"</span>: &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="索引-文档"><a href="#索引-文档" class="headerlink" title="索引/文档"></a>索引/文档</h2><ul><li><p>在Elasticsearch中存储数据的行为就叫做<strong>索引(indexing)</strong>，不过在索引之前，我们需要明确数据应该存储在哪里。</p></li><li><p>在Elasticsearch中，文档归属于一种<strong>类型(type)</strong> ,而这些类型存在于<strong>索引(index)</strong>中，我们可以画一些简单的对比图来类比传统关系型数据库：</p><figure class="highlight tex"><table><tr><td class="code"><pre><span class="line">Relational DB -&gt; Databases -&gt; Tables -&gt; Rows -&gt; Columns</span><br><span class="line">Elasticsearch -&gt; Indices   -&gt; Types  -&gt; Documents -&gt; Fields</span><br></pre></td></tr></table></figure></li><li><p>Elasticsearch集群可以包含多个<strong>索引(indices)</strong>（数据库），每一个索引可以包含多个<strong>类型(types)</strong>（表），每一个类型包含多个<strong>文档(documents)</strong>（行），然后每个文档包含多个<strong>字段(Fields)</strong>（列）。</p><blockquote><p>「索引」含义的区分</p><ul><li>索引（名词），一个<strong>索引(index)</strong>就像是传统关系数据库中的<strong>数据库</strong>，它是相关文档存储的地方，index的复数是<strong>indices</strong>或<strong>indexes</strong>。</li><li>索引（动词） <strong>「索引一个文档」</strong>表示把一个文档存储到<strong>索引（名词）</strong>里，以便它可以被检索或者查询。这很像SQL中的<code>INSERT</code>关键字，差别是，如果文档已经存在，新的文档将覆盖旧的文档。</li><li>倒排索引传统数据库为特定列增加一个索引，例如B-Tree索引来加速检索。Elasticsearch和Lucene使用一种叫做<strong>倒排索引(inverted index)</strong>的数据结构来达到相同目的。</li></ul></blockquote></li></ul><ul><li><p>如果创建员工目录，我们将进行如下操作：</p><ul><li>为每个员工的<strong>文档(document)</strong>建立索引，每个文档包含了相应员工的所有信息。</li><li>每个文档的类型为<code>employee</code>。</li><li><code>employee</code>类型归属于索引<code>megacorp</code>。</li><li><code>megacorp</code>索引存储在Elasticsearch集群中。</li></ul><p>我们能通过一个命令来完成对一个员工的文档存储：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">PUT /megacorp/employee/<span class="number">1</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"first_name"</span> : <span class="string">"John"</span>,</span><br><span class="line">    <span class="string">"last_name"</span> :  <span class="string">"Smith"</span>,</span><br><span class="line">    <span class="string">"age"</span> :        <span class="number">25</span>,</span><br><span class="line">    <span class="string">"about"</span> :      <span class="string">"I love to go rock climbing"</span>,</span><br><span class="line">    <span class="string">"interests"</span>: [ <span class="string">"sports"</span>, <span class="string">"music"</span> ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中：path: <code>/megacorp/employee/1</code>包含三部分信息：</p><table><thead><tr><th>名字</th><th>说明</th></tr></thead><tbody><tr><td>megacorp</td><td>索引名</td></tr><tr><td>employee</td><td>类型名</td></tr><tr><td>1</td><td>这个员工的ID</td></tr></tbody></table></li><li><p>返回新</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"_index"</span>: <span class="string">"customer"</span>,</span><br><span class="line">  <span class="string">"_type"</span>: <span class="string">"external"</span>,</span><br><span class="line">  <span class="string">"_id"</span>: <span class="string">"AVyc9L6dtgHksqXKpTlM"</span>,</span><br><span class="line">  <span class="string">"_version"</span>: <span class="number">1</span>,</span><br><span class="line">  <span class="string">"result"</span>: <span class="string">"created"</span>,</span><br><span class="line">  <span class="string">"_shards"</span>: &#123;</span><br><span class="line">    <span class="string">"total"</span>: <span class="number">2</span>,</span><br><span class="line">    <span class="string">"successful"</span>: <span class="number">1</span>,</span><br><span class="line">    <span class="string">"failed"</span>: <span class="number">0</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">"created"</span>: <span class="literal">true</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>_index：文档存储的地方</li><li>_type： 文档代表的对象的类</li><li>_id：文档的唯一标识，是 URL-safe、 基于 Base64 编码且长度为20个字符的 GUID 字符串</li><li>_version：版本控制</li></ul></li></ul><h3 id="文档元数据"><a href="#文档元数据" class="headerlink" title="文档元数据"></a>文档元数据</h3><ul><li><p>一个文档不只有数据。它还包含了<strong>元数据(metadata)</strong> —— <strong>关于</strong>文档的信息。三个必须的元数据节点是：</p><table><thead><tr><th>节点</th><th>说明</th></tr></thead><tbody><tr><td><code>_index</code></td><td>文档存储的地方</td></tr><tr><td><code>_type</code></td><td>文档代表的对象的类</td></tr><tr><td><code>_id</code></td><td>文档的唯一标识</td></tr></tbody></table></li><li><p><code>_index</code></p><p><strong>索引(index)</strong>类似于关系型数据库里的“数据库”——它是我们存储和索引关联数据的地方。</p><blockquote><p>事实上，我们的数据被存储和索引在<strong>分片(shards)</strong>中，索引只是一个把一个或多个分片分组在一起的逻辑空间。然而，这只是一些内部细节——我们的程序完全不用关心分片。对于我们的程序而言，文档存储在<strong>索引(index)</strong>中。剩下的细节由Elasticsearch关心既可。</p></blockquote></li><li><p><code>_type</code></p><p>在Elasticsearch中，我们使用相同<strong>类型(type)</strong>的文档表示相同的“事物”，因为他们的数据结构也是相同的。</p><p>每个<strong>类型(type)</strong>都有自己的<strong>映射(mapping)</strong>或者结构定义，就像传统数据库表中的列一样。所有类型下的文档被存储在同一个索引下，但是类型的<strong>映射(mapping)</strong>会告诉Elasticsearch不同的文档如何被索引。我们将会在《映射》章节探讨如何定义和管理映射，但是现在我们将依赖Elasticsearch去自动处理数据结构。</p><p><code>_type</code>的名字可以是大写或小写，不能包含下划线或逗号。我们将使用<code>blog</code>做为类型名。</p></li><li><p><code>_id</code></p><p><strong>id</strong>仅仅是一个字符串，它与<code>_index</code>和<code>_type</code>组合时，就可以在Elasticsearch中唯一标识一个文档。当创建一个文档，你可以自定义<code>_id</code>，也可以让Elasticsearch帮你自动生成。</p></li></ul><h2 id="检索文档"><a href="#检索文档" class="headerlink" title="检索文档"></a>检索文档</h2><h3 id="检索"><a href="#检索" class="headerlink" title="检索"></a>检索</h3><ul><li><p>我们只要执行HTTP GET请求并指出文档的“地址”——<strong>索引、类型和ID既可</strong>。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">GET /megacorp/employee/<span class="number">1</span></span><br></pre></td></tr></table></figure><blockquote><p>我们通过HTTP方法<code>GET</code>来检索文档，同样的，我们可以使用<code>DELETE</code>方法删除文档，使用<code>HEAD</code>方法检查某文档是否存在。如果想更新已存在的文档，我们只需再<code>PUT</code>一次。</p></blockquote></li></ul><h3 id="简单搜索"><a href="#简单搜索" class="headerlink" title="简单搜索"></a>简单搜索</h3><ul><li><p>使用<code>GET</code>请求 获取全部员工请求</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">GET /megacorp/employee/_search</span><br></pre></td></tr></table></figure></li><li><p>我们搜索姓氏中包含<strong>“Smith”</strong>的员工。要做到这一点，我们将在命令行中使用轻量级的搜索方法。这种方法常被称作<strong>查询字符串(query string)</strong>搜索，因为我们像传递URL参数一样去传递查询语句：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">GET /megacorp/employee/_search?q=last_name:Smith</span><br></pre></td></tr></table></figure></li></ul><h3 id="使用DSL语句查询"><a href="#使用DSL语句查询" class="headerlink" title="使用DSL语句查询"></a>使用DSL语句查询</h3><ul><li><p>Elasticsearch提供丰富且灵活的查询语言叫做<strong>DSL查询(Query DSL)</strong> ,它允许你构建更加复杂、强大的查询。</p><p><strong>DSL(Domain Specific Language特定领域语言)</strong>以JSON请求体的形式出现</p></li><li><p>如查询姓氏中包含<strong>“Smith”</strong>的员工</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">GET /megacorp/employee/_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"query"</span> : &#123;</span><br><span class="line">        <span class="string">"match"</span> : &#123;</span><br><span class="line">            <span class="string">"last_name"</span> : <span class="string">"Smith"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>找到姓氏为“Smith”的员工，但是我们只想得到年龄大于30岁的员工。我们的语句将添加<strong>过滤器(filter)</strong> </p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">GET /megacorp/employee/_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"query"</span> : &#123;</span><br><span class="line">        <span class="string">"filtered"</span> : &#123;</span><br><span class="line">            <span class="string">"filter"</span> : &#123;</span><br><span class="line">                <span class="string">"range"</span> : &#123;</span><br><span class="line">                    <span class="string">"age"</span> : &#123; <span class="string">"gt"</span> : <span class="number">30</span> &#125; &lt;<span class="number">1</span>&gt;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="string">"query"</span> : &#123;</span><br><span class="line">                <span class="string">"match"</span> : &#123;</span><br><span class="line">                    <span class="string">"last_name"</span> : <span class="string">"smith"</span> &lt;<span class="number">2</span>&gt;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>&lt;1&gt;这部分查询属于<strong>区间过滤器(range filter)</strong> ,它用于查找所有年龄大于30岁的数据—— <code>gt</code>为”greater than”的缩写。</li><li>&lt;2&gt;这部分查询与之前的<code>match</code><strong>语句(query)</strong>一致。</li></ul></li><li><p>高亮搜索</p><p>之前的语句上增加<code>highlight</code>参数</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">GET /megacorp/employee/_search</span><br><span class="line">&#123;</span><br><span class="line">    <span class="string">"query"</span> : &#123;</span><br><span class="line">        <span class="string">"match_phrase"</span> : &#123;</span><br><span class="line">            <span class="string">"about"</span> : <span class="string">"rock climbing"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">"highlight"</span>: &#123;</span><br><span class="line">        <span class="string">"fields"</span> : &#123;</span><br><span class="line">            <span class="string">"about"</span> : &#123;&#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在返回结果中会有一个新的部分叫做<code>highlight</code>，这里包含了来自<code>about</code>字段中的文本，并且用<code>&lt;em&gt;&lt;/em&gt;</code>来标识匹配到的单词。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   ...</span><br><span class="line">   <span class="string">"hits"</span>: &#123;</span><br><span class="line">      <span class="string">"total"</span>:      <span class="number">1</span>,</span><br><span class="line">      <span class="string">"max_score"</span>:  <span class="number">0.23013961</span>,</span><br><span class="line">      <span class="string">"hits"</span>: [</span><br><span class="line">         &#123;</span><br><span class="line">            ...</span><br><span class="line">            <span class="string">"_score"</span>:         <span class="number">0.23013961</span>,</span><br><span class="line">            <span class="string">"_source"</span>: &#123;</span><br><span class="line">               <span class="string">"first_name"</span>:  <span class="string">"John"</span>,</span><br><span class="line">               <span class="string">"last_name"</span>:   <span class="string">"Smith"</span>,</span><br><span class="line">               <span class="string">"age"</span>:         <span class="number">25</span>,</span><br><span class="line">               <span class="string">"about"</span>:       <span class="string">"I love to go rock climbing"</span>,</span><br><span class="line">               <span class="string">"interests"</span>: [ <span class="string">"sports"</span>, <span class="string">"music"</span> ]</span><br><span class="line">            &#125;,</span><br><span class="line">            <span class="string">"highlight"</span>: &#123;</span><br><span class="line">               <span class="string">"about"</span>: [</span><br><span class="line">                  <span class="string">"I love to go &lt;em&gt;rock&lt;/em&gt; &lt;em&gt;climbing&lt;/em&gt;"</span> &lt;<span class="number">1</span>&gt;</span><br><span class="line">               ]</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br><span class="line">      ]</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>total</code>：返回记录数</li><li><code>max_score</code>：最高的匹配程度</li><li><code>hits</code>：返回的记录组成的数组。</li></ul></li></ul><h3 id="空搜索"><a href="#空搜索" class="headerlink" title="空搜索"></a>空搜索</h3><ul><li><p>输入</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">GET /_search</span><br></pre></td></tr></table></figure></li><li><p>返回</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="string">"hits"</span> : &#123;</span><br><span class="line">      <span class="string">"total"</span> :       <span class="number">14</span>,</span><br><span class="line">      <span class="string">"hits"</span> : [</span><br><span class="line">        &#123;</span><br><span class="line">          <span class="string">"_index"</span>:   <span class="string">"us"</span>,</span><br><span class="line">          <span class="string">"_type"</span>:    <span class="string">"tweet"</span>,</span><br><span class="line">          <span class="string">"_id"</span>:      <span class="string">"7"</span>,</span><br><span class="line">          <span class="string">"_score"</span>:   <span class="number">1</span>,</span><br><span class="line">          <span class="string">"_source"</span>: &#123;</span><br><span class="line">             <span class="string">"date"</span>:    <span class="string">"2014-09-17"</span>,</span><br><span class="line">             <span class="string">"name"</span>:    <span class="string">"John Smith"</span>,</span><br><span class="line">             <span class="string">"tweet"</span>:   <span class="string">"The Query DSL is really powerful and flexible"</span>,</span><br><span class="line">             <span class="string">"user_id"</span>: <span class="number">2</span></span><br><span class="line">          &#125;</span><br><span class="line">       &#125;,</span><br><span class="line">        ... <span class="number">9</span> RESULTS REMOVED ...</span><br><span class="line">      ],</span><br><span class="line">      <span class="string">"max_score"</span> :   <span class="number">1</span></span><br><span class="line">   &#125;,</span><br><span class="line">   <span class="string">"took"</span> :           <span class="number">4</span>,</span><br><span class="line">   <span class="string">"_shards"</span> : &#123;</span><br><span class="line">      <span class="string">"failed"</span> :      <span class="number">0</span>,</span><br><span class="line">      <span class="string">"successful"</span> :  <span class="number">10</span>,</span><br><span class="line">      <span class="string">"total"</span> :       <span class="number">10</span></span><br><span class="line">   &#125;,</span><br><span class="line">   <span class="string">"timed_out"</span> :      <span class="literal">false</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p><strong>hits</strong></p><p>返回结果中最重要的部分是 <code>hits</code> ，它 包含 <code>total</code> 字段来表示匹配到的文档总数，并且一个 <code>hits</code> 数组包含所查询结果的前十个文档。</p><p>在 <code>hits</code> 数组中每个结果包含文档的 <code>_index</code> 、 <code>_type</code> 、 <code>_id</code> ，加上 <code>_source</code> 字段。这意味着我们可以直接从返回的搜索结果中使用整个文档。这不像其他的搜索引擎，仅仅返回文档的ID，需要你单独去获取文档。</p><p>每个结果还有一个 <code>_score</code> ，它衡量了文档与查询的匹配程度。默认情况下，首先返回最相关的文档结果，就是说，返回的文档是按照 <code>_score</code> 降序排列的。在这个例子中，我们没有指定任何查询，故所有的文档具有相同的相关性，因此对所有的结果而言 <code>1</code> 是中性的 <code>_score</code> 。</p><p><code>max_score</code> 值是与查询所匹配文档的 <code>_score</code> 的最大值。</p></li><li><p><strong>took</strong></p><p><code>took</code> 值告诉我们执行整个搜索请求耗费了多少毫秒。</p></li><li><p><strong>shards</strong></p><p><code>_shards</code> 部分 告诉我们在查询中参与分片的总数，以及这些分片成功了多少个失败了多少个。正常情况下我们不希望分片失败，但是分片失败是可能发生的。如果我们遭遇到一种灾难级别的故障，在这个故障中丢失了相同分片的原始数据和副本，那么对这个分片将没有可用副本来对搜索请求作出响应。假若这样，Elasticsearch 将报告这个分片是失败的，但是会继续返回剩余分片的结果。</p></li><li><p><strong>timeout</strong></p><p><code>timed_out</code> 值告诉我们查询是否超时。默认情况下，搜索请求不会超时。 如果低响应时间比完成结果更重要，你可以指定 <code>timeout</code> 为 10 或者 10ms（10毫秒），或者 1s（1秒）：</p><figure class="highlight js"><table><tr><td class="code"><pre><span class="line">GET /_search?timeout=<span class="number">10</span>ms</span><br></pre></td></tr></table></figure><p>在请求超时之前，Elasticsearch 将会返回已经成功从每个分片获取的结果。</p></li></ul><h3 id="3-5-多索引，多类型"><a href="#3-5-多索引，多类型" class="headerlink" title="3.5.多索引，多类型"></a>3.5.多索引，多类型</h3><ul><li><p>想在一个或多个特殊的索引并且在一个或者多个特殊的类型中进行搜索。我们可以通过在URL中指定特殊的索引和类型达到这种效果，如下所示：</p></li><li><p><strong><code>/_search</code></strong>：在所有的索引中搜索所有的类型</p></li><li><p><strong><code>/gb/_search</code></strong>：在 <code>gb</code> 索引中搜索所有的类型</p></li><li><p><strong><code>/gb,us/_search</code></strong>：在 <code>gb</code> 和 <code>us</code> 索引中搜索所有的文档</p></li><li><p><strong><code>/g\*,u\*/_search</code></strong>：在任何以 <code>g</code> 或者 <code>u</code> 开头的索引中搜索所有的类型</p></li><li><p><strong><code>/gb/user/_search</code></strong>：在 <code>gb</code> 索引中搜索 <code>user</code> 类型</p></li><li><p><strong><code>/gb,us/user,tweet/_search</code></strong>：在 <code>gb</code> 和 <code>us</code> 索引中搜索 <code>user</code> 和 <code>tweet</code> 类型</p></li><li><p><strong><code>/_all/user,tweet/_search</code></strong>：在所有的索引中搜索 <code>user</code> 和 <code>tweet</code> 类型</p></li></ul><h2 id="聚合-aggregations"><a href="#聚合-aggregations" class="headerlink" title="聚合(aggregations)"></a>聚合(<strong>aggregations</strong>)</h2><ul><li><p>允许你在数据上生成复杂的分析统计</p><p>举个例子，让我们找到所有职员中最大的共同点（兴趣爱好）是什么</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">GET /megacorp/employee/_search</span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"aggs"</span>: &#123;</span><br><span class="line">    <span class="string">"all_interests"</span>: &#123;</span><br><span class="line">      <span class="string">"terms"</span>: &#123; <span class="string">"field"</span>: <span class="string">"interests"</span> &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>返回结果</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   ...</span><br><span class="line">   <span class="string">"hits"</span>: &#123; ... &#125;,</span><br><span class="line">   <span class="string">"aggregations"</span>: &#123;</span><br><span class="line">      <span class="string">"all_interests"</span>: &#123;</span><br><span class="line">         <span class="string">"buckets"</span>: [</span><br><span class="line">            &#123;</span><br><span class="line">               <span class="string">"key"</span>:       <span class="string">"music"</span>,</span><br><span class="line">               <span class="string">"doc_count"</span>: <span class="number">2</span></span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">               <span class="string">"key"</span>:       <span class="string">"forestry"</span>,</span><br><span class="line">               <span class="string">"doc_count"</span>: <span class="number">1</span></span><br><span class="line">            &#125;,</span><br><span class="line">            &#123;</span><br><span class="line">               <span class="string">"key"</span>:       <span class="string">"sports"</span>,</span><br><span class="line">               <span class="string">"doc_count"</span>: <span class="number">1</span></span><br><span class="line">            &#125;</span><br><span class="line">         ]</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="索引知识"><a href="#索引知识" class="headerlink" title="索引知识"></a>索引知识</h2><blockquote><p>其他的字段可以查阅 第9章中 链接中内容</p></blockquote><p>ElasticSearch的对象模型，跟关系型数据库模型相比：</p><ul><li><strong>索引（Index）</strong>：相当于数据库，用于定义文档类型的存储；在同一个索引中，同一个字段只能定义一个数据类型；</li><li><strong>文档类型（Type）</strong>：相当于关系表，用于描述文档中的各个字段的定义；不同的文档类型，能够存储不同的字段，服务于不同的查询请求；</li><li><strong>文档（Document）</strong>：相当于关系表的数据行，存储数据的载体，包含一个或多个存有数据的字段；<ul><li><strong>字段（Field）</strong>：文档的一个Key/Value对；</li><li><strong>词（Term）</strong>：表示文本中的一个单词；</li><li><strong>标记（Token）</strong>：表示在字段中出现的词，由该词的文本、偏移量（开始和结束）以及类型组成；</li></ul></li></ul><p>索引是由段（Segment）组成的，段存储在硬盘（Disk）文件中，段不是实时更新的，这意味着，段在写入磁盘后，就不再被更新。ElasticSearch引擎把被删除的文档的信息存储在一个单独的文件中，在搜索数据时，ElasticSearch引擎首先从段中查询，再从查询结果中过滤被删除的文档，这意味着，段中存储着“被删除”的文档，这使得段中含有”正常文档“的密度降低。多个段可以通过段合并（Segment Merge）操作把“已删除”的文档将从段中物理删除，把未删除的文档合并到一个新段中，新段中没有”已删除文档“，因此，段合并操作能够提高索引的查找速度，但段合并是IO密集型的操作，需要消耗大量的硬盘IO。</p><h3 id="创建索引"><a href="#创建索引" class="headerlink" title="创建索引"></a>创建索引</h3><p>在创建索引之前，首先了解<strong>REST</strong>ful API的调用风格，在管理和使用ElasticSearch服务时，常用的HTTP动词有下面五个：</p><ul><li><p><strong>GET 请求：获取服务器中的对象</strong></p><ul><li>相当于SQL的Select命令</li><li>GET /blogs：列出所有博客</li></ul></li><li><p>POST 请求：在服务器上更新对象</p><ul><li>相当于SQL的Update命令</li><li>POST /blogs/ID：更新指定的博客</li></ul></li><li><p><strong>PUT 请求：在服务器上创建对象</strong></p><ul><li>相当于SQL的Create命令</li><li>PUT /blogs/ID：新建一个博客　　</li></ul></li><li><p><strong>DELETE 请求：删除服务器中的对象</strong></p></li><li><ul><li>相当于SQL的Delete命令</li><li>DELETE /blogs/ID：删除指定的博客</li></ul></li><li><p><strong>HEAD 请求：仅仅用于获取对象的基础信息</strong></p></li></ul><ol><li><p><strong>禁用自动创建索引</strong></p><p>推荐设置：在全局配置文件 elasticsearch.yml 中，禁用自动创建索引：</p><figure class="highlight html"><table><tr><td class="code"><pre><span class="line">action.auto_create_index:false</span><br></pre></td></tr></table></figure></li></ol><ol start="2"><li><p><strong>手动创建索引</strong></p><p>创建索引的语法是：<code>PUT http://host:port/index_name/+index_configuration</code></p><p>其中，<strong><code>index_name</code></strong>是创建的索引的名字，<strong><code>indiex_configuration</code></strong> 是向ElasticSearch服务器传递的请求负载的主体，数据格式<strong>是json</strong>，用于定义索引的配置信息：<strong>映射节（mappings）和配置节（settings）</strong>。</p><p>在创建索引时，需要精心设计索引的映射节（mappings）和配置节（settings），本例创建<strong>blog索引和articles文档类型，</strong>创建索引的语法是：<code>PUT http://localhost:9200/blog/</code></p></li></ol><h3 id="索引映射节（mappings）"><a href="#索引映射节（mappings）" class="headerlink" title="索引映射节（mappings）"></a>索引映射节（mappings）</h3><ol><li><p><strong>索引结构</strong></p><p>索引是由文档类型构成的，在mappings字段中定义索引的文档类型，示例代码中为blog索引定义了三个文档类型：articles，followers和comments</p><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;  </span><br><span class="line">   <span class="attr">"mappings"</span>:&#123;  </span><br><span class="line">      <span class="attr">"articles"</span>:&#123; &#125;,</span><br><span class="line">      <span class="attr">"followers"</span>:&#123; &#125;,</span><br><span class="line">      <span class="attr">"comments"</span>:&#123; &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ol><ol start="2"><li><p><strong>文档属性</strong></p><p><strong>==文档属性定义了文档类型的共用属性，适用于文档的所有字段:==</strong></p></li></ol><ul><li><strong>dynamic_date_formats</strong>属性：该属性定义可以识别的日期格式列表；</li><li><strong>dynamic</strong>属性：默认值为true，允许动态地向文档类型中加入新的字段。推荐设置为false，禁止向文档中添加字段，这样，文档类型的所有字段必须在索引映射的properties属性中显式定义，在properties字段中未定义的字段都将会ElasticSearch忽略。<ul><li>dynamic设置为ture：默认值，新增加的字段被添加到索引映射中；</li><li>dynamic设置为false：新增加的字段会被忽略；</li><li>dynamic设置为strict：当向文档中新增字段时，ElasticSearch引擎抛出异常；</li></ul></li></ul><figure class="highlight json"><table><tr><td class="code"><pre><span class="line">&#123;  </span><br><span class="line">   <span class="attr">"mappings"</span>:&#123;  </span><br><span class="line">      <span class="attr">"articles"</span>:&#123;  <span class="attr">"dynamic"</span>:<span class="literal">false</span>,</span><br><span class="line">         <span class="attr">"dynamic_date_formats"</span>:[<span class="string">"yyyy-MM-dd hh:mm:ss"</span>, <span class="string">"yyyy-MM-dd"</span> ],</span><br><span class="line">         <span class="attr">"properties"</span>:&#123;  </span><br><span class="line">            <span class="attr">"id"</span>:&#123;&#125;,</span><br><span class="line">            <span class="attr">"title"</span>:&#123;&#125;,</span><br><span class="line">            <span class="attr">"author"</span>:&#123;&#125;,</span><br><span class="line">            <span class="attr">"content"</span>:&#123;&#125;,</span><br><span class="line">            <span class="attr">"postedat"</span>:&#123;&#125;</span><br><span class="line">         &#125;</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="文档的字段属性"><a href="#文档的字段属性" class="headerlink" title="文档的字段属性"></a>文档的字段属性</h3><h4 id="字段的数据类型"><a href="#字段的数据类型" class="headerlink" title="字段的数据类型"></a>字段的数据类型</h4><p>字段的数据类型由字段的属性type指定，ElasticSearch支持的基础数据类型主要有：</p><ul><li><p><strong>字符串类型</strong>：string；</p></li><li><p><strong>数值类型</strong>：字节（byte）、2字节（short）、4字节（integer）、8字节（long）、float、double；</p></li><li><p><strong>布尔类型</strong>：boolean，值是true或false；</p></li><li><p><strong>时间/日期类型</strong>：date，用于存储日期和时间；</p></li><li><p><strong>二进制类型</strong>：binary；</p></li><li><p><strong>IP地址类型</strong>：ip，以字符串形式存储IPv4地址；</p></li><li><p><strong>特殊数据类型</strong>：token_count，用于存储索引的字数信息</p><p>在文档类型的properties属性中，定义字段的type属性，指定字段的数据类型，属性properties 用于定义文档类型的字段属性，或字段对象的属性：</p><figure class="highlight"><table><tr><td class="code"><pre><span class="line">"properties":&#123;  </span><br><span class="line">           "id":&#123;"type":"long"&#125;</span><br><span class="line">           &#125;</span><br></pre></td></tr></table></figure></li></ul><h4 id="字段的公共属性"><a href="#字段的公共属性" class="headerlink" title="字段的公共属性"></a>字段的公共属性</h4><ul><li><p><strong>index</strong>：该属性控制字段是否编入索引被搜索，该属性共有三个有效值：analyzed、no和not_analyzed：</p><ul><li><p>analyzed：表示该字段被分析，编入索引，产生的token能被搜索到；</p></li><li><p>not_analyzed：表示该字段不会被分析，使用原始值编入索引，在索引中作为单个词；</p></li><li><p>no：不编入索引，无法搜索该字段；</p><p>其中analyzed是分析，分解的意思，默认值是analyzed，表示将该字段编入索引，以供搜索。</p></li></ul></li><li><p><strong>store</strong>：指定是否将字段的原始值写入索引，默认值是no，字段值被分析，能够被搜索，但是，字段值不会存储，这意味着，该字段能够被查询，但是不会存储字段的原始值。</p></li><li><p><strong>boost</strong>：字段级别的助推，默认值是1，定义了字段在文档中的重要性/权重；</p></li><li><p><strong>include_in_all</strong>：该属性指定当前字段是否包括在_all字段中，默认值是ture，所有的字段都会包含_all字段中；如果index=no，那么属性include_in_all无效，这意味着当前字段无法包含在_all字段中。</p></li><li><p><strong>copy_to</strong>：该属性指定一个字段名称，ElasticSearch引擎将当前字段的值复制到该属性指定的字段中；</p></li><li><p><strong>doc_values</strong>：文档值是存储在硬盘上的索引时（indexing time）数据结构，对于not_analyzed字段，默认值是true，analyzed string字段不支持文档值;</p></li><li><p><strong>fielddata</strong>：字段数据是存储在内存中的查询时（querying time）数据结构，只支持analyzed string字段；</p></li><li><p><strong>null_value</strong>：该属性指定一个值，当字段的值为NULL时，该字段使用null_value代替NULL值；在ElasticSearch中，NULL 值不能被索引和搜索，当一个字段设置为NULL值，ElasticSearch引擎认为该字段没有任何值，使用该属性为NULL字段设置一个指定的值，使该字段能够被索引和搜索。</p></li></ul><h4 id="字符串类型常用的其他属性"><a href="#字符串类型常用的其他属性" class="headerlink" title="字符串类型常用的其他属性"></a>字符串类型常用的其他属性</h4><ul><li><strong>analyzer</strong>：该属性定义用于建立索引和搜索的分析器名称，默认值是全局定义的分析器名称，该属性可以引用在配置结点（settings）中自定义的分析器；</li><li><strong>search_analyzer</strong>：该属性定义的分析器，用于处理发送到特定字段的查询字符串；</li><li><strong>ignore_above</strong>：该属性指定一个整数值，当字符串字段（analyzed string field）的字节数量大于该数值之后，超过长度的部分字符数据将不能被analyzer处理，不能被编入索引；对于 not analyzed string字段，超过长度的部分字符将被忽略，不会被编入索引。默认值是0，禁用该属性；</li><li><strong>position_increment_gap</strong>：该属性指定在相同词的位置上增加的gap，默认值是100；</li><li><strong>index_options</strong>：索引选项控制添加到倒排索引（Inverted Index）的信息，这些信息用于搜索（Search）和高亮显示：<ul><li>docs：只索引文档编号(Doc Number)</li><li>freqs：索引文档编号和词频率（term frequency）</li><li>positions：索引文档编号，词频率和词位置（序号）</li><li>offsets：索引文档编号，词频率，词偏移量（开始和结束位置）和词位置（序号）</li><li>默认情况下，被分析的字符串（analyzed string）字段使用positions，其他字段使用docs; </li></ul></li></ul><p>分析器（analyzer）把analyzed string 字段的值，转换成标记流（Token stream），例如，字符串”The quick Brown Foxes”，可能被分解成的标记（Token）是：quick,brown,fox。这些词（term）是该字段的索引值，这使用对索引文本的查找更有效率。字段的属性 analyzer 用于指定在index-time和search-time时，ElasticSearch引擎分解字段值的分析器名称。</p><h4 id="数值类型的其他属性"><a href="#数值类型的其他属性" class="headerlink" title="数值类型的其他属性"></a>数值类型的其他属性</h4><ul><li><strong>precision_step</strong>：该属性指定为数值字段每个值生成的term数量，值越低，产生的term数量越高，范围查询越快，索引越大，默认值是4；</li><li><strong>ignore_malformed</strong>：忽略格式错误的数值，默认值是false，不忽略错误格式，对整个文档不处理，并且抛出异常；</li><li><strong>coerce</strong>：默认值是true，尝试将字符串转换为数值，如果字段类型是整数，那么将小数取整；</li></ul><h4 id="日期类型的其他属性"><a href="#日期类型的其他属性" class="headerlink" title="日期类型的其他属性"></a>日期类型的其他属性</h4><ul><li><strong>format</strong>：指定日期的格式，例如：“yyyy-MM-dd hh:mm:ss”</li><li><strong>precision_step</strong>：该属性指定数值字段每隔多少数值，生成一个词（term）；step值越低，产生的词数量越高，范围查询越快，索引越大，占用存储空间越大；</li><li><strong>ignore_malformed</strong>：忽略错误格式，默认值是false，不忽略错误格式；</li></ul><h4 id="多字段（fields）"><a href="#多字段（fields）" class="headerlink" title="多字段（fields）"></a>多字段（fields）</h4><p>在fields属性中定义一个或多个字段，该字段的值和当前字段值相同，可以设置一个字段用于搜索，一个字段用于排序等。</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">&quot;properties&quot;:</span><br><span class="line">&#123;  </span><br><span class="line">    &quot;id&quot;:&#123;  &quot;type&quot;:&quot;long&quot;,</span><br><span class="line">         &quot;fields&quot;:&#123;  &quot;id2&quot;:&#123;&quot;type&quot;:&quot;long&quot;,&quot;index&quot;:&quot;not_analyzed&quot;&#125; &#125;</span><br><span class="line">      &#125;,</span><br></pre></td></tr></table></figure><h4 id="文档值（doc-values）"><a href="#文档值（doc-values）" class="headerlink" title="文档值（doc_values）"></a>文档值（doc_values）</h4><p>默认情况下，多数字段都被一起编入索引，用户使用倒排索引（Inverted Index）可以搜索到相应的词（Term），倒排索引支持在唯一的有序词列表中查找特定词，或检查文档中是否包含某个词，但是，对于排序（Sort），聚合和在脚本中访问特定字段的值（Field value)，这三个操作需要执行不同的数据访问模式，即单字段数据访问：在文档中查找特定的字段，检查该字段是否包含指定的词。</p><p>文档值（doc_values）属性指定将字段的值写入到<strong>硬盘上</strong>的列式结构，实现了单个字段的数据访问模式，能够高效执行排序和聚合搜索。使用文档值的字段将有专属的字段数据缓存实例，无需像普通字段一样倒排。是存储在硬盘上的数据结构，在文档索引时创建。文档值数据存在硬盘上，在<strong>文档索引时</strong>创建，存储的数据和字段存储在_source 字段的数据相同，文档值支持所有的字段类型，除了analyzed string 字段之外。</p><p>默认情况下，所有的字段都支持文档值，默认是启用的（enabled），如果不需要在单个字段上执行排序或聚合操作，或者从脚本中访问指定字段的值，那么，可以禁用文档值，字段的值将不会存储在硬盘空间中。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">"properties"</span>: &#123;</span><br><span class="line">    <span class="string">"status_code"</span>: &#123; </span><br><span class="line">        <span class="string">"type"</span>:       <span class="string">"string"</span>,</span><br><span class="line">        <span class="string">"index"</span>:      <span class="string">"not_analyzed"</span></span><br><span class="line">        <span class="string">"doc_values"</span>: <span class="literal">true</span></span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="string">"session_id"</span>: &#123; </span><br><span class="line">        <span class="string">"type"</span>:       <span class="string">"string"</span>,</span><br><span class="line">        <span class="string">"index"</span>:      <span class="string">"not_analyzed"</span>,</span><br><span class="line">        <span class="string">"doc_values"</span>: <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="字段数据（Fielddata）"><a href="#字段数据（Fielddata）" class="headerlink" title="字段数据（Fielddata）"></a>字段数据（Fielddata）</h4><p>字段数据（Fielddata）是存储在内存中的查询时数据结构，只支持analyzed string字段。该数据结构在字段第一次执行聚合，排序或被脚本访问时创建。创建的过程是：在读取整个倒排索引（Inverted Index）时，ElasticSearch从硬盘上加载倒排索引的每个段（Segment），倒转词（Term）和文档的关系，并将其存储在JVM堆内存中。加载字段数据的过程是非常消耗IO资源的，一旦被加载，就被存储在内存中，直到段的生命周期结束。</p><p>对于analyzed string字段，fielddata字段是默认启用的，</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">"text"</span>:&#123;  </span><br><span class="line">   <span class="string">"type"</span>:<span class="string">"string"</span>,</span><br><span class="line">   <span class="string">"fielddata"</span>:&#123;  <span class="string">"loading"</span>:<span class="string">"lazy"</span></span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="存储（store）"><a href="#存储（store）" class="headerlink" title="存储（store）"></a>存储（store）</h4><p>存储（store）属性指定是否将字段的原始值写入索引，默认值是no，字段值被分析，能够被搜索，但是，字段的原始值不会存储，这意味着，该字段能够被查询，但是无法获取字段的原始值。默认情况下，该字段的值会被存储到_source字段中，如果想要获取单个或多个字段的值，而不是整个_source字段，可以使用 <a href="https://www.elastic.co/guide/en/elasticsearch/reference/2.4/search-request-source-filtering.html" target="_blank" rel="noopener">source filtering</a> 来实现；但是在特定的条件下，只存储一个字段的值是有意义的（make sense），例如，一个article文档包含：title，postdate和content字段，从文档中只获取title和postdate字段，并且使_source 字段包含content字段，必须通过store属性来控制：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">"mappings"</span>: &#123;</span><br><span class="line">    <span class="string">"my_type"</span>: &#123;</span><br><span class="line">      <span class="string">"properties"</span>: &#123;</span><br><span class="line">        <span class="string">"title"</span>: &#123;</span><br><span class="line">          <span class="string">"type"</span>: <span class="string">"string"</span>,</span><br><span class="line">          <span class="string">"store"</span>: <span class="literal">true</span> </span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">"date"</span>: &#123;</span><br><span class="line">          <span class="string">"type"</span>: <span class="string">"date"</span>,</span><br><span class="line">          <span class="string">"store"</span>: <span class="literal">true</span> </span><br><span class="line">        &#125;,</span><br><span class="line">        <span class="string">"content"</span>: &#123;</span><br><span class="line">          <span class="string">"type"</span>: <span class="string">"string"</span>,</span><br><span class="line">          <span class="string">"store"</span>: <span class="literal">false</span>   </span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h4 id="位置增加间隔（position-increment-gap）"><a href="#位置增加间隔（position-increment-gap）" class="headerlink" title="位置增加间隔（position_increment_gap）"></a>位置增加间隔（position_increment_gap）</h4><p>对于analyzed string字段，都会考虑把词的位置信息，用于支持位置和短语匹配查询（<a href="https://www.elastic.co/guide/en/elasticsearch/reference/2.4/query-dsl-match-query.html#query-dsl-match-query-phrase" target="_blank" rel="noopener">proximity or phrase queries</a>），例如，有一个字符串字段，该字段中存在多个词“fake”，ElasticSearch引擎会在每个值之间增加一个gap，以防止短语匹配或位置匹配查询出现跨越多个词的异常，这个gap的值就是属性position_increment_gap，默认值是100；</p><h3 id="元字段"><a href="#元字段" class="headerlink" title="元字段"></a>元字段</h3><p>在索引的映射中，元字段（Meta-field）是以下划线开头的字段，部分元字段可以配置，部分元字段不可配置，只能用于返回信息。</p><h4 id="all-字段，可以配置"><a href="#all-字段，可以配置" class="headerlink" title="_all 字段，可以配置"></a>_all 字段，可以配置</h4><p>ElasticSearch使用_all字段存储其他字段的数据以便搜索，默认情况下，_all字段是启用的，包含了索引中所有字段的数据，然而这一字段使索引变大，如果不需要，请禁用该字段，或排除某些字段。为了在_all字段中不包括某个特定字段，在字段中设置“include_in_all”属性为false。</p><p>禁用_all字段，需要修改映射配置：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;  </span><br><span class="line">   <span class="string">"articles"</span>:&#123;  <span class="string">"_all"</span>:&#123;  </span><br><span class="line">         <span class="string">"enabled"</span>:<span class="literal">false</span></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="source-字段，可以配置"><a href="#source-字段，可以配置" class="headerlink" title="_source 字段，可以配置"></a>_source 字段，可以配置</h4><p>_source字段表示在生成索引的过程中，存储发送到ElasticSearch的原始JSON文档，默认情况下，该字段会被启用，因为索引的局部更新功能依赖该字段。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;  </span><br><span class="line">   <span class="string">"articles"</span>:&#123;  </span><br><span class="line">      <span class="string">"_source"</span>:&#123;  </span><br><span class="line">         <span class="string">"enabled"</span>:<span class="literal">true</span></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#123;  </span><br><span class="line">   <span class="string">"articles"</span>:&#123;  </span><br><span class="line">      <span class="string">"_source"</span>:&#123;  </span><br><span class="line">         <span class="string">"excludes"</span>:[<span class="string">"Content"</span>,<span class="string">"Comments"</span>],</span><br><span class="line">         <span class="string">"includes"</span>:[<span class="string">"author"</span>]</span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="routing-字段，可以配置"><a href="#routing-字段，可以配置" class="headerlink" title="_routing 字段，可以配置"></a>_routing 字段，可以配置</h4><p>路由字段，将一个文档值进行哈希映射，并将该文档路由到指定的分片，路由的公式是：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">shard_num = hash(_routing) % num_primary_shards</span><br></pre></td></tr></table></figure><p>在ElasticSearch 2.4 版本中，path参数被废弃，使用的默认字段是_id，设置required为true，表示路由字段在进行索引的CRUD操作时必需显式赋值。</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">&#123;  </span><br><span class="line">   <span class="string">"articles"</span>:&#123;  </span><br><span class="line">      <span class="string">"_routing"</span>:&#123;  </span><br><span class="line">         <span class="string">"required"</span>:<span class="literal">true</span></span><br><span class="line">      &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在put 命令中，使用自定义的路由字段，以下示例使用 user1字段作为路由字段更新和查询文档：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line">PUT my_index/my_type/<span class="number">1</span>?routing=user1 </span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">"title"</span>: <span class="string">"This is a document"</span></span><br><span class="line">&#125;</span><br><span class="line">GET my_index/my_type/<span class="number">1</span>?routing=user1</span><br></pre></td></tr></table></figure><h4 id="不可配置的元字段"><a href="#不可配置的元字段" class="headerlink" title="不可配置的元字段"></a>不可配置的元字段</h4><ul><li><code>_index</code>：返回文档所属的索引</li><li><code>_uid</code>：返回文档的type和id</li><li><code>_type</code>：返回文档类型（type）</li><li><code>_id</code>：返回文档的ID；</li><li><code>_size</code>：返回文档的_source字段中函数的字节数量；</li><li><code>_field_names</code>：返回文档中不包含null值的字段名称；</li></ul><h3 id="索引配置节（settings）"><a href="#索引配置节（settings）" class="headerlink" title="索引配置节（settings）"></a>索引配置节（settings）</h3><h4 id="配置索引的分片和副本数量"><a href="#配置索引的分片和副本数量" class="headerlink" title="配置索引的分片和副本数量"></a>配置索引的分片和副本数量</h4><p>ElasticSearch索引是有一个或多个分片组成的，每个分片是索引的一个水平分区，包含了文档数据的一部分；每个分片有0，1或多个副本，分片的副本和分片存储相同的数据。</p><p>示例代码，为索引创建5个分片，分片没有副本：</p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">"settings"</span>:&#123;</span><br><span class="line">    <span class="string">"number_of_shards"</span>:<span class="number">5</span>,</span><br><span class="line">    <span class="string">"number_of_replicas"</span>:<span class="number">0</span>,</span><br></pre></td></tr></table></figure><h4 id="配置分析器（analyzer）"><a href="#配置分析器（analyzer）" class="headerlink" title="配置分析器（analyzer）"></a>配置分析器（analyzer）</h4><p>在配置结点的analysis属性中配置分析器，参考<a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/analysis.html" target="_blank" rel="noopener">官方文档</a>了解更多，</p><p><strong>分词器（tokenizer）是系统预定义的，常用的分词器是：</strong></p><ul><li>standard：默认值，用于大多数欧洲语言的标准分词器</li><li>simple：基于非字母字符来分词，并将其转化为小写形式</li><li>whitespace：基于空格来分词</li><li>stop：除了simple的所有功能，还能基于停用词（stop words）过滤数据；</li><li>pattern：使用正则表达式分词；</li><li>snowball：除了standard提供的分词功能之外，还提供词干提取功能；</li></ul><p><strong>过滤器是系统预定义的，常用的过滤器是:</strong></p><ul><li>asciifolding</li><li>lowercase</li><li>kstem</li></ul><h2 id="ElasticSearch-High-Level-REST-文档基本操作"><a href="#ElasticSearch-High-Level-REST-文档基本操作" class="headerlink" title="ElasticSearch High Level REST  文档基本操作"></a>ElasticSearch High Level REST  文档基本操作</h2><blockquote><p>indexRequest：索引请求</p><p>GetRequest：获取请求</p><p>DeleteRequest：删除请求</p><p>UpdateRequest：更新请求</p><p>BulkRequest：容量请求，用来装上述所有请求</p></blockquote><h3 id="坐标依赖"><a href="#坐标依赖" class="headerlink" title="坐标依赖"></a>坐标依赖</h3><figure class="highlight xml"><table><tr><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">repository</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">id</span>&gt;</span>elastic-lucene-snapshots<span class="tag">&lt;/<span class="name">id</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">name</span>&gt;</span>Elastic Lucene Snapshots<span class="tag">&lt;/<span class="name">name</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">url</span>&gt;</span>http://s3.amazonaws.com/download.elasticsearch.org/lucenesnapshots/00142c9<span class="tag">&lt;/<span class="name">url</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">releases</span>&gt;</span><span class="tag">&lt;<span class="name">enabled</span>&gt;</span>true<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span><span class="tag">&lt;/<span class="name">releases</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">snapshots</span>&gt;</span><span class="tag">&lt;<span class="name">enabled</span>&gt;</span>false<span class="tag">&lt;/<span class="name">enabled</span>&gt;</span><span class="tag">&lt;/<span class="name">snapshots</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">repository</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="创建客户端"><a href="#创建客户端" class="headerlink" title="创建客户端"></a>创建客户端</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ElasticClient</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String host = <span class="string">"10.1.59.101"</span>;</span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">int</span> port = <span class="number">9200</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取Rest高级客户端</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RestHighLevelClient <span class="title">getRestHighLevelClient</span><span class="params">()</span></span>&#123;</span><br><span class="line">        RestClientBuilder builder = RestClient.builder(<span class="keyword">new</span> HttpHost(host, port));</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RestHighLevelClient(builder);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 获取Rest低级客户端</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RestClient <span class="title">getRestClient</span><span class="params">()</span></span>&#123;</span><br><span class="line">        RestClient build = RestClient.builder(<span class="keyword">new</span> HttpHost(host)).build();</span><br><span class="line">        <span class="keyword">return</span> build;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="索引操作"><a href="#索引操作" class="headerlink" title="索引操作"></a>索引操作</h3><p>索引即我们的新增操作，ES提供了三种形式的索引，分别为通过<em>Json字符串、Map集合、XContentBuilder实</em>现索引操作</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">(User user)</span> </span>&#123;</span><br><span class="line">        RestHighLevelClient client = elasticClient.getRestHighLevelClient();</span><br><span class="line">        <span class="comment">//Json字符串作为数据源</span></span><br><span class="line">        IndexRequest indexRequest1 = <span class="keyword">new</span> IndexRequest(<span class="string">"02"</span>,book<span class="string">","</span><span class="number">3</span><span class="string">");</span></span><br><span class="line"><span class="string">        String jsonString = "</span>&#123;<span class="string">" +</span></span><br><span class="line"><span class="string">                "</span>\<span class="string">"name\":\"生命的诞生\","</span> +</span><br><span class="line">                <span class="string">"\"type\":\"科学\","</span> +</span><br><span class="line">                <span class="string">"\"price\":\"170\""</span> +</span><br><span class="line">                <span class="string">"&#125;"</span>;</span><br><span class="line"></span><br><span class="line">        indexRequest1.source(jsonString, XContentType.JSON);</span><br><span class="line">                                                      </span><br><span class="line">        <span class="comment">//Map集合作为数据源</span></span><br><span class="line">        Map jsonMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        jsonMap.put(<span class="string">"user"</span>, <span class="string">"userByMap"</span>);</span><br><span class="line">        jsonMap.put(<span class="string">"postDate"</span>, <span class="keyword">new</span> Date());</span><br><span class="line">        jsonMap.put(<span class="string">"message"</span>, <span class="string">"messageByMap"</span>);</span><br><span class="line">        IndexRequest indexRequest2 = <span class="keyword">new</span> IndexRequest(<span class="string">"posts"</span>, <span class="string">"doc"</span>, <span class="string">"34"</span>).source(jsonMap);</span><br><span class="line">                                                      </span><br><span class="line">        <span class="comment">//XContentBuilder作为数据源</span></span><br><span class="line">        XContentBuilder builder = <span class="keyword">null</span>;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            builder = XContentFactory.jsonBuilder();</span><br><span class="line">            builder.startObject();</span><br><span class="line">            builder.field(<span class="string">"user"</span>, <span class="string">"userXXX"</span>);</span><br><span class="line">            builder.timeField(<span class="string">"postDate"</span>, <span class="keyword">new</span> Date());</span><br><span class="line">            builder.field(<span class="string">"message"</span>, <span class="string">"messageXXX"</span>);</span><br><span class="line">            builder.endObject();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        IndexRequest indexRequest3 = <span class="keyword">new</span> IndexRequest(<span class="string">"posts"</span>, <span class="string">"doc"</span>, <span class="string">"1"</span>)</span><br><span class="line">                .source(builder);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            IndexResponse indexResponse1 = client.index(indexRequest1, RequestOptions.DEFAULT);</span><br><span class="line">            client.index(indexRequest2, RequestOptions.DEFAULT);</span><br><span class="line">            client.index(indexRequest3, RequestOptions.DEFAULT);</span><br><span class="line">            client.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="获取操作"><a href="#获取操作" class="headerlink" title="获取操作"></a>获取操作</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">get</span><span class="params">()</span></span>&#123;</span><br><span class="line">    RestHighLevelClient client = elasticClient.getRestHighLevelClient();</span><br><span class="line">    GetRequest getRequest = <span class="keyword">new</span> GetRequest(<span class="string">"posts"</span>,<span class="string">"doc"</span>,<span class="string">"1"</span>);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        GetResponse getResponse = client.get(getRequest, RequestOptions.DEFAULT);</span><br><span class="line">        client.close();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="删除操作"><a href="#删除操作" class="headerlink" title="删除操作"></a>删除操作</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">delete</span><span class="params">()</span></span>&#123;</span><br><span class="line">    RestHighLevelClient client = elasticClient.getRestHighLevelClient();</span><br><span class="line">    <span class="comment">//获取删除请求</span></span><br><span class="line">DeleteRequest deleteRequest = <span class="keyword">new</span> DeleteRequest(<span class="string">"02"</span>, <span class="string">"book"</span>, <span class="string">"2"</span>);</span><br><span class="line">    deleteRequest.timeout(TimeValue.timeValueMinutes(<span class="number">10</span>));</span><br><span class="line">    deleteRequest.setRefreshPolicy(WriteRequest.RefreshPolicy.WAIT_UNTIL);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        client.delete(deleteRequest, RequestOptions.DEFAULT);</span><br><span class="line">        client.close();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="更新"><a href="#更新" class="headerlink" title="更新"></a>更新</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">update</span><span class="params">(User user)</span></span>&#123;</span><br><span class="line">    RestHighLevelClient client = elasticClient.getRestHighLevelClient();</span><br><span class="line">    <span class="comment">//获取更新请求</span></span><br><span class="line">    UpdateRequest updateRequest = <span class="keyword">new</span> UpdateRequest(<span class="string">"posts"</span>, <span class="string">"doc"</span>, <span class="string">"35"</span>);</span><br><span class="line">    Map map = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    map.put(<span class="string">"message"</span>, <span class="string">"message_update"</span>);</span><br><span class="line">    map.put(<span class="string">"user"</span>, <span class="string">"user_update"</span>);</span><br><span class="line">    updateRequest.doc(user.toJsonString(), XContentType.JSON);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        client.update(updateRequest, RequestOptions.DEFAULT);</span><br><span class="line">        client.close();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="查询文档是否存在"><a href="#查询文档是否存在" class="headerlink" title="查询文档是否存在"></a>查询文档是否存在</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">exists</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    RestHighLevelClient client = elasticClient.getRestHighLevelClient();</span><br><span class="line">    GetRequest getRequest = <span class="keyword">new</span> GetRequest(<span class="string">"posts"</span>,<span class="string">"doc"</span>,<span class="string">"33"</span>);</span><br><span class="line">    GetResponse getResponse = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        getRequest.fetchSourceContext(<span class="keyword">new</span> FetchSourceContext(<span class="keyword">false</span>));<span class="comment">//禁用获取 _source字段</span></span><br><span class="line">        getRequest.storedFields(<span class="string">"_none_"</span>);<span class="comment">//禁用获取存储字段。</span></span><br><span class="line">        <span class="comment">//这里获取文档存在的状态</span></span><br><span class="line">        <span class="keyword">boolean</span> exists = client.exists(getRequest, RequestOptions.DEFAULT);</span><br><span class="line">        client.close();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="Bulk批量操作"><a href="#Bulk批量操作" class="headerlink" title="Bulk批量操作"></a>Bulk批量操作</h3><ul><li><strong>BulkRequest</strong>：  批量请求（用于增删改操作）</li><li><strong>BulkResponse</strong>：批量请求（用于增删改操作）</li></ul><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">bulk</span><span class="params">(User user)</span></span>&#123;</span><br><span class="line">    RestHighLevelClient client = elasticClient.getRestHighLevelClient();</span><br><span class="line">    User user2 = <span class="keyword">new</span> User();</span><br><span class="line">    user2.setName(<span class="string">"周大福"</span>);</span><br><span class="line">    user2.setAge(<span class="number">211</span>);</span><br><span class="line">    user2.setPosition(<span class="string">"珠宝"</span>);</span><br><span class="line">    <span class="comment">//批量请求（用于增删改操作）</span></span><br><span class="line">    BulkRequest bulkRequest = <span class="keyword">new</span> BulkRequest();</span><br><span class="line">    <span class="comment">//多种请求</span></span><br><span class="line">    IndexRequest indexRequest1 = </span><br><span class="line">        <span class="keyword">new</span> IndexRequest(<span class="string">"posts"</span>, <span class="string">"doc"</span>, <span class="string">"41"</span>).source(user.toJsonString(), XContentType.JSON);</span><br><span class="line">    IndexRequest indexRequest2 = </span><br><span class="line">        <span class="keyword">new</span> IndexRequest(<span class="string">"posts"</span>, <span class="string">"doc"</span>, <span class="string">"42"</span>).source(user2.toJsonString(), XContentType.JSON);</span><br><span class="line">    DeleteRequest deleteRequest = <span class="keyword">new</span> DeleteRequest(<span class="string">"01"</span>, <span class="string">"law"</span>, <span class="string">"3"</span>);</span><br><span class="line"></span><br><span class="line">    bulkRequest.add(indexRequest1);</span><br><span class="line">    bulkRequest.add(indexRequest2);</span><br><span class="line">    bulkRequest.add(deleteRequest);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line"></span><br><span class="line">        client.bulk(bulkRequest, RequestOptions.DEFAULT);</span><br><span class="line">        client.close();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="ElasticSearch-High-Level-REST-搜索查询"><a href="#ElasticSearch-High-Level-REST-搜索查询" class="headerlink" title="ElasticSearch High Level REST 搜索查询"></a>ElasticSearch High Level REST 搜索查询</h2><h3 id="创建查询请求"><a href="#创建查询请求" class="headerlink" title="创建查询请求"></a>创建查询请求</h3><p>在search搜索中大部分的搜索条件添加都可通过设置SearchSourceBuilder来实现，然后将SearchSourceBuilder</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">RestHighLevelClient client = ElasticClient.getRestHighLevelClient();</span><br><span class="line"><span class="comment">//创建查询体</span></span><br><span class="line">SearchRequest searchRequest = <span class="keyword">new</span> SearchRequest();</span><br><span class="line">SearchSourceBuilder sourceBuilder = <span class="keyword">new</span> SearchSourceBuilder();</span><br><span class="line">sourceBuilder.query(QueryBuilders.termQuery(<span class="string">"user"</span>, <span class="string">"kimchy"</span>));</span><br><span class="line"><span class="comment">//分页查询</span></span><br><span class="line">sourceBuilder.from(<span class="number">0</span>);</span><br><span class="line">sourceBuilder.size(<span class="number">5</span>);</span><br><span class="line"><span class="comment">//设置一个可选的超时，控制允许搜索的时间</span></span><br><span class="line">sourceBuilder.timeout(<span class="keyword">new</span> TimeValue(<span class="number">60</span>, TimeUnit.SECONDS)); </span><br><span class="line"><span class="comment">//获取搜索请求</span></span><br><span class="line">searchRequest.source(sourceBuilder);</span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="comment">//执行请求</span></span><br><span class="line">    SearchResponse search = client.search(searchRequest, RequestOptions.DEFAULT);</span><br><span class="line">    <span class="comment">//获取匹配的总数量</span></span><br><span class="line">    Long total = search.getHits().getTotalHits(); </span><br><span class="line">    System.out.println(<span class="string">"总记录数："</span> + total);</span><br><span class="line">    <span class="keyword">for</span> (SearchHit hit : search.getHits().getHits()) &#123;</span><br><span class="line">        <span class="comment">//获得分数，即匹配度 </span></span><br><span class="line">              <span class="keyword">float</span> score = hit.getScore(); </span><br><span class="line">          String source = hit.getSourceAsString();</span><br><span class="line">          System.out.println(source);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">    e.printStackTrace();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p><strong>search查询的返回值为SearchResponse</strong>，调用SearchResponse的<code>getHits()</code>方法会获取SearchHits对象，然后再通过SearchHits的getHits()方法即返回一个SearchHit[]数组。</p></li><li><p>遍历SearchHit[]数组获取每一个对象，通过hit.getScore()可获取分数，即搜索匹配度。通过hit.getSourceAsString()可得到对象的json字符串。</p><blockquote><p><strong>备注：</strong>在上述查询中用到了termQuery查询，ES还提供了matchQuery查询，不同的查询需求中需要选择不同的查询，在此需要了解这两个查询的区别：</p><ul><li><strong>termQuery</strong> : term为不使用分词器查找，类似精确查找。</li><li><strong>matchQuery</strong> : mactch为使用分词器进行查找，会查询到一些近似匹配的内容。</li></ul></blockquote></li></ul><h3 id="SearchHit使用汇总"><a href="#SearchHit使用汇总" class="headerlink" title="SearchHit使用汇总"></a>SearchHit使用汇总</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SearchHits hits = searchResponse.getHits();</span><br><span class="line"></span><br><span class="line"><span class="comment">//查询命中总数</span></span><br><span class="line"><span class="keyword">long</span> totalHits = hits.getTotalHits(); </span><br><span class="line"><span class="comment">//查询命中的最高分数</span></span><br><span class="line"><span class="keyword">float</span> maxScore = hits.getMaxScore();</span><br><span class="line"></span><br><span class="line"><span class="comment">//嵌套在SearchHits可以迭代获取单个搜索结果中</span></span><br><span class="line">SearchHit[] searchHits = hits.getHits();</span><br><span class="line"><span class="keyword">for</span> (SearchHit hit : searchHits) &#123;</span><br><span class="line">    <span class="comment">//使用SearchHit做一些事情</span></span><br><span class="line">    <span class="comment">//hit就是 文档内容</span></span><br><span class="line">    </span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//通过SearchHit还可以获取 返回数据 的索引、类型、docId和得分等基本信息</span></span><br><span class="line">String index = hit.getIndex(); </span><br><span class="line">String type = hit.getType();</span><br><span class="line">String id = hit.getId();</span><br><span class="line"><span class="keyword">float</span> score = hit.getScore();</span><br><span class="line"></span><br><span class="line"><span class="comment">//hit还可以以Json字符串或Map的形式返回数据</span></span><br><span class="line">String sourceAsString = hit.getSourceAsString();</span><br><span class="line">Map&lt;String, Object&gt; sourceAsMap = hit.getSourceAsMap();</span><br><span class="line">String documentTitle = (String) sourceAsMap.get(<span class="string">"title"</span>);</span><br><span class="line">List&lt;Object&gt; users = (List&lt;Object&gt;) sourceAsMap.get(<span class="string">"user"</span>);</span><br><span class="line">Map&lt;String, Object&gt; innerObject = (Map&lt;String, Object&gt;) sourceAsMap.get(<span class="string">"innerObject"</span>);</span><br></pre></td></tr></table></figure><p><strong>在Elasticsearch中 hit内容比对</strong></p><figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="string">"hits"</span> : [</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="string">"_index"</span> : <span class="string">"sku"</span>,</span><br><span class="line">        <span class="string">"_type"</span> : <span class="string">"doc"</span>,</span><br><span class="line">        <span class="string">"_id"</span> : <span class="string">"Tty-0WsB2H3IH4AiYGNu"</span>,</span><br><span class="line">        <span class="string">"_score"</span> : <span class="number">5.676614</span>,</span><br><span class="line">        <span class="string">"_source"</span> : &#123;</span><br><span class="line">            <span class="string">"brandName"</span> : <span class="literal">null</span>,</span><br><span class="line">            <span class="string">"num"</span> : <span class="number">10000</span>,</span><br><span class="line">            <span class="string">"weight"</span> : <span class="number">10</span>,</span><br><span class="line">            <span class="string">"updateTime"</span> : <span class="literal">null</span>,</span><br><span class="line">            <span class="string">"saleNum"</span> : <span class="literal">null</span>,</span><br><span class="line">            <span class="string">"categoryName"</span> : <span class="literal">null</span>,</span><br><span class="line">            <span class="string">"id"</span> : <span class="string">"34598992560"</span>,</span><br><span class="line">            <span class="string">"sn"</span> : <span class="string">""</span>,</span><br><span class="line">            <span class="string">"categoryId"</span> : <span class="literal">null</span>,</span><br><span class="line">            <span class="string">"status"</span> : <span class="string">"1"</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;,</span><br><span class="line">    ……</span><br><span class="line">]</span><br></pre></td></tr></table></figure><ul><li>_index：索引</li><li>_type：类型</li><li>_id：唯一标识</li><li>_score：匹配分数</li><li>_source：数据内容</li></ul><h3 id="指定排序"><a href="#指定排序" class="headerlink" title="指定排序"></a>指定排序</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">sourceBuilder.sort(<span class="keyword">new</span> ScoreSortBuilder().order(SortOrder.DESC)); <span class="comment">//按分数（即匹配度）排序</span></span><br><span class="line">sourceBuilder.sort(<span class="keyword">new</span> FieldSortBuilder(<span class="string">"_uid"</span>).order(SortOrder.ASC)); <span class="comment">//通过指定字段来排序</span></span><br></pre></td></tr></table></figure><p>排序有两种排序方式，第一通过ScoreSortBuilder实现按分数（即匹配度）排序</p><p>第二种方式通过指定字段来排序，如上图所示通过“_uid”字段排序</p><h3 id="关闭检索"><a href="#关闭检索" class="headerlink" title="关闭检索"></a>关闭检索</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">sourceBuilder.fetchSource(<span class="keyword">false</span>);</span><br></pre></td></tr></table></figure><p>只返回了总记录数，遍历输出每条数据均为 null</p><p>另外还可以通过sourceBuilder接受一个或多个数组，来控制要要返回哪些字段，排除哪些字段。具体实现如下，第一个数组参数为要接受的字段，第二个数组参数为要排除的内容：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">String[] includeFields = <span class="keyword">new</span> String[] &#123;<span class="string">"title"</span>, <span class="string">"user"</span>, <span class="string">"innerObject.*"</span>&#125;;</span><br><span class="line">String[] excludeFields = <span class="keyword">new</span> String[] &#123;<span class="string">"_type"</span>&#125;;</span><br><span class="line">sourceBuilder.fetchSource(includeFields, excludeFields);</span><br></pre></td></tr></table></figure><h3 id="高亮显示"><a href="#高亮显示" class="headerlink" title="高亮显示"></a>高亮显示</h3><p>通过向SearchSourceBuilder添加HighlightBuilder示例可添加高亮显示功能</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SearchSourceBuilder searchSourceBuilder = <span class="keyword">new</span> SearchSourceBuilder();</span><br><span class="line"><span class="comment">//高亮显示构造器</span></span><br><span class="line">HighlightBuilder highlightBuilder = <span class="keyword">new</span> HighlightBuilder(); </span><br><span class="line"><span class="comment">//Field：定义高亮的范围，在hit中的 title内容中</span></span><br><span class="line">HighlightBuilder.Field highlightTitle = <span class="keyword">new</span> HighlightBuilder.Field(<span class="string">"title"</span>); </span><br><span class="line"><span class="comment">//可以自定义高亮样式</span></span><br><span class="line"><span class="comment">//highlightTitle.preTags("&lt;font style='color:red'&gt;").postTags("&lt;/font&gt;");</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//字段高亮显示类型，默认用标签包裹高亮字词</span></span><br><span class="line">highlightTitle.highlighterType(<span class="string">"unified"</span>); </span><br><span class="line">highlightBuilder.field(highlightTitle);</span><br><span class="line">searchSourceBuilder.highlighter(highlightBuilder);</span><br></pre></td></tr></table></figure><p>通过SearchHit的<strong>getHighlightFields()</strong>方法获取我们需要高亮内容：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">SearchHits hits = searchResponse.getHits();</span><br><span class="line"><span class="keyword">for</span> (SearchHit hit : hits.getHits()) &#123;</span><br><span class="line">    Map highlightFields = hit.getHighlightFields();</span><br><span class="line">    HighlightField highlight = highlightFields.get(<span class="string">"title"</span>); </span><br><span class="line">    Text[] fragments = highlight.fragments();  </span><br><span class="line">    String fragmentString = fragments[<span class="number">0</span>].string();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="聚合-分组-操作"><a href="#聚合-分组-操作" class="headerlink" title="聚合(分组)操作"></a>聚合(分组)操作</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">aggregation</span><span class="params">()</span></span>&#123;</span><br><span class="line">    RestHighLevelClient client = elasticClient.getRestHighLevelClient();</span><br><span class="line">    SearchRequest searchRequest = <span class="keyword">new</span> SearchRequest();</span><br><span class="line">    SearchSourceBuilder searchSourceBuilder = <span class="keyword">new</span> SearchSourceBuilder();</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//若不加keyword,在text类型上进行聚合操作时会报错</span></span><br><span class="line">    TermsAggregationBuilder aggregation = AggregationBuilders.terms(<span class="string">"by_sex"</span>).field(<span class="string">"sex.keyword"</span>);   </span><br><span class="line">    <span class="comment">//avg_age 为子聚合名称，名称可随意</span></span><br><span class="line">    aggregation.subAggregation(AggregationBuilders.avg(<span class="string">"avg_age"</span>).field(<span class="string">"age"</span>));  </span><br><span class="line">    </span><br><span class="line">    searchSourceBuilder.aggregation(aggregation);</span><br><span class="line">    searchRequest.source(searchSourceBuilder);</span><br><span class="line">    SearchResponse searchResponse = <span class="keyword">null</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        searchResponse = client.search(searchRequest, RequestOptions.DEFAULT);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//获取到聚合查询后的内容</span></span><br><span class="line">    Aggregations aggregations = searchResponse.getAggregations();</span><br><span class="line">    Terms byCompanyAggregation = aggregations.get(<span class="string">"by_sex"</span>);</span><br><span class="line">    Terms.Bucket elasticBucket = byCompanyAggregation.getBucketByKey(<span class="string">"女性"</span>);</span><br><span class="line">    Avg averageAge = elasticBucket.getAggregations().get(<span class="string">"avg_age"</span>);</span><br><span class="line">    <span class="keyword">double</span> avg = averageAge.getValue();</span><br><span class="line">    System.out.println(<span class="string">"女性平均年龄："</span>+avg);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="匹配查询"><a href="#匹配查询" class="headerlink" title="匹配查询"></a>匹配查询</h3><blockquote><p><strong>SearchRequest</strong>： 查询请求对象</p><p><strong>SearchResponse</strong>：查询响应对象</p><p><strong>SearchSourceBuilder</strong>：查询源构建器</p><p><strong>MatchQueryBuilder</strong>：匹配查询构建器</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//1.连接rest接口</span></span><br><span class="line">HttpHost http=<span class="keyword">new</span> HttpHost(<span class="string">"127.0.0.1"</span>,<span class="number">9200</span>,<span class="string">"http"</span>);</span><br><span class="line">RestClientBuilder builder= RestClient.builder(http);<span class="comment">//rest构建器</span></span><br><span class="line">RestHighLevelClient restHighLevelClient=<span class="keyword">new</span> RestHighLevelClient(builder);<span class="comment">//高级客户端对象 </span></span><br><span class="line"></span><br><span class="line"><span class="comment">//2.封装查询请求</span></span><br><span class="line">SearchRequest searchRequest=<span class="keyword">new</span> SearchRequest(<span class="string">"sku"</span>); <span class="comment">//查询的索引值</span></span><br><span class="line">searchRequest.types(<span class="string">"doc"</span>); <span class="comment">//设置查询的类型</span></span><br><span class="line"><span class="comment">//定义查询的条件</span></span><br><span class="line">SearchSourceBuilder searchSourceBuilder=<span class="keyword">new</span> SearchSourceBuilder();</span><br><span class="line">MatchQueryBuilder matchQueryBuilder= QueryBuilders.matchQuery(<span class="string">"name"</span>,<span class="string">"手机"</span>);</span><br><span class="line">searchSourceBuilder.query(matchQueryBuilder);</span><br><span class="line">searchRequest.source(searchSourceBuilder);</span><br><span class="line"></span><br><span class="line"><span class="comment">//3.获取查询结果</span></span><br><span class="line">SearchResponse searchResponse = restHighLevelClient.search(searchRequest, RequestOptions.DEFAULT);</span><br><span class="line">SearchHits searchHits = searchResponse.getHits();</span><br><span class="line"><span class="comment">//获取记录数</span></span><br><span class="line"><span class="keyword">long</span> totalHits = searchHits.getTotalHits();</span><br><span class="line">System.out.println(<span class="string">"记录数："</span>+totalHits);</span><br><span class="line"><span class="comment">//获取到搜索结果总览对象hits</span></span><br><span class="line">SearchHit[] hits = searchHits.getHits();</span><br><span class="line"><span class="keyword">for</span>(SearchHit hit:hits)&#123;</span><br><span class="line">    <span class="comment">//文档的源数据source</span></span><br><span class="line">String source = hit.getSourceAsString();</span><br><span class="line">System.out.println(source);</span><br><span class="line">&#125;</span><br><span class="line">restHighLevelClient.close();</span><br></pre></td></tr></table></figure><h3 id="布尔与词条查询"><a href="#布尔与词条查询" class="headerlink" title="布尔与词条查询"></a>布尔与词条查询</h3><blockquote><p><strong>BoolQueryBuilder</strong>：布尔查询构建器</p><p><strong>TermQueryBuilder</strong>：词条查询构建器</p><p><strong>QueryBuilders</strong>：查询构建器工厂</p></blockquote><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//2.封装查询请求</span></span><br><span class="line">SearchRequest searchRequest=<span class="keyword">new</span> SearchRequest(<span class="string">"sku"</span>);</span><br><span class="line"><span class="comment">//设置查询的类型</span></span><br><span class="line">searchRequest.types(<span class="string">"doc"</span>); </span><br><span class="line"><span class="comment">//定义查询的条件，创建搜索源</span></span><br><span class="line">SearchSourceBuilder searchSourceBuilder=<span class="keyword">new</span> SearchSourceBuilder();</span><br><span class="line"><span class="comment">//布尔查询构建器</span></span><br><span class="line">BoolQueryBuilder boolQueryBuilder = QueryBuilders.boolQuery();</span><br><span class="line"><span class="comment">//查询条件 -- 匹配</span></span><br><span class="line">MatchQueryBuilder matchQueryBuilder= QueryBuilders.matchQuery(<span class="string">"name"</span>,<span class="string">"手机"</span>);</span><br><span class="line"><span class="comment">//布尔查询构建器嵌套 与条件</span></span><br><span class="line">boolQueryBuilder.must(matchQueryBuilder);</span><br><span class="line"><span class="comment">//查询条件 -- 词条</span></span><br><span class="line">TermQueryBuilder termQueryBuilder = QueryBuilders.termQuery(<span class="string">"brandName"</span>, <span class="string">"小米"</span>);</span><br><span class="line"><span class="comment">//布尔查询构建器嵌套 与条件</span></span><br><span class="line">boolQueryBuilder.must(termQueryBuilder);</span><br><span class="line"><span class="comment">//布尔查询构建器嵌套 与条件</span></span><br><span class="line">searchSourceBuilder.query(boolQueryBuilder);</span><br><span class="line"><span class="comment">//搜索源嵌套布尔查询构建器</span></span><br><span class="line">searchRequest.source(searchSourceBuilder);</span><br></pre></td></tr></table></figure><h3 id="过滤查询"><a href="#过滤查询" class="headerlink" title="过滤查询"></a>过滤查询</h3><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">//2.封装查询请求</span></span><br><span class="line">SearchRequest searchRequest=<span class="keyword">new</span> SearchRequest(<span class="string">"sku"</span>);</span><br><span class="line"><span class="comment">//设置查询的类型</span></span><br><span class="line">searchRequest.types(<span class="string">"doc"</span>); </span><br><span class="line"><span class="comment">//创建搜索源</span></span><br><span class="line">SearchSourceBuilder searchSourceBuilder=<span class="keyword">new</span> SearchSourceBuilder();</span><br><span class="line"><span class="comment">//布尔查询构建器</span></span><br><span class="line">BoolQueryBuilder boolQueryBuilder = QueryBuilders.boolQuery();</span><br><span class="line">TermQueryBuilder termQueryBuilder = QueryBuilders.termQuery(<span class="string">"brandName"</span>, <span class="string">"小米"</span>);</span><br><span class="line">boolQueryBuilder.filter(termQueryBuilder);</span><br><span class="line">searchSourceBuilder.query(boolQueryBuilder);</span><br><span class="line">searchRequest.source(searchSourceBuilder);</span><br></pre></td></tr></table></figure><h2 id="ElasticSearch-High-Level-REST-其他功能"><a href="#ElasticSearch-High-Level-REST-其他功能" class="headerlink" title="ElasticSearch High Level REST 其他功能"></a>ElasticSearch High Level REST 其他功能</h2><h3 id="Scroll-滚屏"><a href="#Scroll-滚屏" class="headerlink" title="Scroll 滚屏"></a>Scroll 滚屏</h3><p>ES中提供了 FROM/SIZE 分页，但这种分页有性能瓶颈。</p><p>Scroll会以间隔时间滚屏的方式返回全部的查询数据，可以作为数据量很大的情况下，分页的一个替代方案</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">scroll</span><span class="params">()</span></span>&#123;</span><br><span class="line">    RestHighLevelClient client = elasticClient.getRestHighLevelClient();</span><br><span class="line">    <span class="comment">//初始化scroll</span></span><br><span class="line">    <span class="keyword">final</span> Scroll scroll = <span class="keyword">new</span> Scroll(TimeValue.timeValueMinutes(<span class="number">1L</span>)); <span class="comment">//设定滚动时间间隔</span></span><br><span class="line">    SearchRequest searchRequest = <span class="keyword">new</span> SearchRequest();</span><br><span class="line">    searchRequest.scroll(scroll);</span><br><span class="line">    SearchSourceBuilder searchSourceBuilder = <span class="keyword">new</span> SearchSourceBuilder();</span><br><span class="line">    searchSourceBuilder.query(matchAllQuery());</span><br><span class="line">    <span class="comment">//设定每次返回多少条数据</span></span><br><span class="line">    searchSourceBuilder.size(<span class="number">5</span>); </span><br><span class="line">    searchRequest.source(searchSourceBuilder);</span><br><span class="line"></span><br><span class="line">    SearchResponse searchResponse = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        searchResponse = client.search(searchRequest, RequestOptions.DEFAULT);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//滚屏设置</span></span><br><span class="line">    String scrollId = searchResponse.getScrollId();</span><br><span class="line">    SearchHit[] searchHits = searchResponse.getHits().getHits();</span><br><span class="line">    System.out.println(<span class="string">"-----首页-----"</span>);</span><br><span class="line">    <span class="keyword">for</span> (SearchHit searchHit : searchHits) &#123;</span><br><span class="line">        System.out.println(searchHit.getSourceAsString());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//遍历搜索命中的数据，直到没有数据</span></span><br><span class="line">    <span class="keyword">while</span> (searchHits != <span class="keyword">null</span> &amp;&amp; searchHits.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        SearchScrollRequest scrollRequest = <span class="keyword">new</span> SearchScrollRequest(scrollId);</span><br><span class="line">        scrollRequest.scroll(scroll);</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            searchResponse = client.scroll(scrollRequest, RequestOptions.DEFAULT);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        scrollId = searchResponse.getScrollId();</span><br><span class="line">        searchHits = searchResponse.getHits().getHits();</span><br><span class="line">        <span class="keyword">if</span> (searchHits != <span class="keyword">null</span> &amp;&amp; searchHits.length &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"-----下一页-----"</span>);</span><br><span class="line">            <span class="keyword">for</span> (SearchHit searchHit : searchHits) &#123;</span><br><span class="line">                System.out.println(searchHit.getSourceAsString());</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//清除滚屏</span></span><br><span class="line">    ClearScrollRequest clearScrollRequest = <span class="keyword">new</span> ClearScrollRequest();</span><br><span class="line">    clearScrollRequest.addScrollId(scrollId);<span class="comment">//也可以选择setScrollIds()将多个scrollId一起使用</span></span><br><span class="line">    ClearScrollResponse clearScrollResponse = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        clearScrollResponse = client.clearScroll(clearScrollRequest,RequestOptions.DEFAULT);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">boolean</span> succeeded = clearScrollResponse.isSucceeded();</span><br><span class="line">    System.out.println(<span class="string">"succeeded:"</span> + succeeded);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="多搜索"><a href="#多搜索" class="headerlink" title="多搜索"></a>多搜索</h3><p>Multi-Search可同时添加多个search搜索请求，并行地在一个http请求中执行多个搜索请求，相较多次单请求查询可提升查询效率。ES客户掉通过mget方法实现多请求搜索</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">multiSearch</span><span class="params">()</span></span>&#123;</span><br><span class="line">    RestHighLevelClient client = elasticClient.getRestHighLevelClient();</span><br><span class="line">    <span class="comment">//Multi-Search请求</span></span><br><span class="line">    MultiSearchRequest request = <span class="keyword">new</span> MultiSearchRequest();</span><br><span class="line">    SearchRequest firstSearchRequest = <span class="keyword">new</span> SearchRequest();</span><br><span class="line">    SearchSourceBuilder firstBuilder = <span class="keyword">new</span> SearchSourceBuilder();</span><br><span class="line">    </span><br><span class="line">    firstBuilder.query(matchQuery(<span class="string">"name"</span>,<span class="string">"潇潇"</span>));</span><br><span class="line">    firstSearchRequest.source(firstBuilder);</span><br><span class="line">    request.add(firstSearchRequest);</span><br><span class="line">    </span><br><span class="line">    SearchRequest secondRequest = <span class="keyword">new</span> SearchRequest();</span><br><span class="line">    SearchSourceBuilder secondBuild = <span class="keyword">new</span> SearchSourceBuilder();</span><br><span class="line">    secondBuild.query(matchQuery(<span class="string">"position"</span>,<span class="string">"建筑师"</span>));</span><br><span class="line">    secondRequest.source(secondBuild);</span><br><span class="line">    </span><br><span class="line">    request.add(secondRequest);</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        MultiSearchResponse multiResponse = client.msearch(request, RequestOptions.DEFAULT);</span><br><span class="line">        MultiSearchResponse.Item firstItem  = multiResponse.getResponses()[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">if</span> (firstItem.getFailure() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"第一个请求失败！"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        SearchResponse firstResponse = firstItem.getResponse();</span><br><span class="line">        <span class="keyword">for</span> (SearchHit documentFields : firstResponse.getHits().getHits()) &#123;</span><br><span class="line">            System.out.println(<span class="string">"第一个查询请求返回："</span>+documentFields.getSourceAsString());</span><br><span class="line">        &#125;</span><br><span class="line">        MultiSearchResponse.Item seconditem = multiResponse.getResponses()[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (seconditem.getFailure() != <span class="keyword">null</span>) &#123;</span><br><span class="line">            System.out.println(<span class="string">"第二个请求失败！"</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        SearchResponse secondResponse = seconditem.getResponse();</span><br><span class="line">        <span class="keyword">for</span> (SearchHit documentFields : secondResponse.getHits().getHits()) &#123;</span><br><span class="line">            System.out.println(<span class="string">"第二的查询请求返回："</span> + documentFields.getSourceAsString());</span><br><span class="line">        &#125;</span><br><span class="line">        client.close();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="使用模板搜索"><a href="#使用模板搜索" class="headerlink" title="使用模板搜索"></a>使用模板搜索</h3><p>ElasticSearch 还提供了通过模板搜索查询</p><p>可以通过脚本预选注册模板，在注册模板时定义一个模板名称。在查询时通过模板名称调用该模板。首先演示下如何注册模板：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">registTemplate</span><span class="params">()</span></span>&#123;</span><br><span class="line">    RestClient restClient = elasticClient.getRestClient();</span><br><span class="line">    String template = <span class="string">"&#123;\n"</span> +</span><br><span class="line">        <span class="string">"  \"script\":&#123;\n"</span> +</span><br><span class="line">        <span class="string">"    \"lang\":\"mustache\",\n"</span> +</span><br><span class="line">        <span class="string">"    \"source\":&#123;\n"</span> +</span><br><span class="line">        <span class="string">"      \"query\":&#123;\n"</span> +</span><br><span class="line">        <span class="string">"        \"match\":&#123;\n"</span> +</span><br><span class="line">        <span class="string">"          \"&#123;&#123;key&#125;&#125;\":\"&#123;&#123;value&#125;&#125;\"\n"</span> +</span><br><span class="line">        <span class="string">"        &#125;\n"</span> +</span><br><span class="line">        <span class="string">"      &#125;,\n"</span> +</span><br><span class="line">        <span class="string">"      \"size\":\"&#123;&#123;size&#125;&#125;\"\n"</span> +</span><br><span class="line">        <span class="string">"    &#125;\n"</span> +</span><br><span class="line">        <span class="string">"  &#125;\n"</span> +</span><br><span class="line">        <span class="string">"&#125;"</span>;</span><br><span class="line">    Request scriptRequest1 = <span class="keyword">new</span> Request(<span class="string">"POST"</span>, <span class="string">"_scripts/title_search"</span>);</span><br><span class="line">    scriptRequest1.setJsonEntity(template);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        restClient.performRequest(scriptRequest1);</span><br><span class="line">        restClient.close();</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于ElasticSearch 6.5版本的高级Rest API中暂时还没有提供用于注册模板的存储脚本，所以本示例中使用的低级REST客户端。本示例中注册了一个名为“title_search”的模板</p><p>有了这个模板就可以通过“<strong>title_search</strong>”去调用，动态的将查询参数添加到模板中去。模板调用示例如下：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">templateSearch</span><span class="params">()</span></span>&#123;</span><br><span class="line">    RestHighLevelClient client = elasticClient.getRestHighLevelClient();</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        SearchTemplateRequest request = <span class="keyword">new</span> SearchTemplateRequest();</span><br><span class="line">        request.setRequest(<span class="keyword">new</span> SearchRequest(<span class="string">"posts"</span>));</span><br><span class="line">        <span class="comment">//调用模板</span></span><br><span class="line">        request.setScriptType(ScriptType.STORED);</span><br><span class="line">        request.setScript(<span class="string">"title_search"</span>);</span><br><span class="line"></span><br><span class="line">        Map&lt;String, Object&gt; params = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        params.put(<span class="string">"key"</span>, <span class="string">"name"</span>);</span><br><span class="line">        params.put(<span class="string">"value"</span>, <span class="string">"福卖福"</span>);</span><br><span class="line">        params.put(<span class="string">"size"</span>, <span class="number">5</span>);</span><br><span class="line">        request.setScriptParams(params);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            SearchTemplateResponse searchTemplateResponse = client.searchTemplate(request, RequestOptions.DEFAULT);</span><br><span class="line">            SearchHit[] hits = searchTemplateResponse.getResponse().getHits().getHits();</span><br><span class="line">            <span class="keyword">for</span> (SearchHit hit : hits) &#123;</span><br><span class="line">                System.out.println(hit.getSourceAsString());</span><br><span class="line">            &#125;</span><br><span class="line">            client.close();</span><br><span class="line">        &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>针对每个模板我们执行一次搜索请求，如果我们工作中针对同一模板可能会有不止一次的请求，如果每个请求都去单独执行的话未免有点繁琐。我们可以通过msearchTemplate来实现一次请求实现多条搜索，示例如下</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">multiTemplateSearch</span><span class="params">()</span></span>&#123;</span><br><span class="line">    RestHighLevelClient client = elasticClient.getRestHighLevelClient();</span><br><span class="line">    String [] searchTerms = &#123;<span class="string">"周大福"</span>, <span class="string">"特博士"</span>, <span class="string">"詹姆斯"</span>&#125;; <span class="comment">// 要搜索的条件</span></span><br><span class="line">    MultiSearchTemplateRequest multiRequest = <span class="keyword">new</span> MultiSearchTemplateRequest();</span><br><span class="line">    <span class="keyword">for</span> (String searchTerm : searchTerms) &#123;</span><br><span class="line">        SearchTemplateRequest request = <span class="keyword">new</span> SearchTemplateRequest();</span><br><span class="line">        request.setRequest(<span class="keyword">new</span> SearchRequest(<span class="string">"posts"</span>)); <span class="comment">//指定为posts索引库</span></span><br><span class="line"></span><br><span class="line">        request.setScriptType(ScriptType.INLINE);</span><br><span class="line">        request.setScript(</span><br><span class="line">            <span class="string">"&#123;\n"</span> +</span><br><span class="line">            <span class="string">"  \"query\":&#123;\n"</span> +</span><br><span class="line">            <span class="string">"    \"match\":&#123;\n"</span> +</span><br><span class="line">            <span class="string">"      \"&#123;&#123;key&#125;&#125;\":\"&#123;&#123;value&#125;&#125;\"\n"</span> +</span><br><span class="line">            <span class="string">"    &#125;\n"</span> +</span><br><span class="line">            <span class="string">"  &#125;,\n"</span> +</span><br><span class="line">            <span class="string">"  \"size\":\"&#123;&#123;size&#125;&#125;\"\n"</span> +</span><br><span class="line">            <span class="string">"&#125;"</span>);</span><br><span class="line"></span><br><span class="line">        Map&lt;String, Object&gt; scriptParams = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="comment">//向模板中填充对应值</span></span><br><span class="line">        scriptParams.put(<span class="string">"key"</span>, <span class="string">"name"</span>);</span><br><span class="line">        scriptParams.put(<span class="string">"value"</span>, searchTerm);</span><br><span class="line">        scriptParams.put(<span class="string">"size"</span>, <span class="number">5</span>);</span><br><span class="line">        request.setScriptParams(scriptParams);</span><br><span class="line"></span><br><span class="line">        multiRequest.add(request);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//执行查询</span></span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        MultiSearchTemplateResponse multiResponse = client.msearchTemplate(multiRequest, RequestOptions.DEFAULT);</span><br><span class="line">        <span class="comment">//返回一组响应 ，每个请求对应一个响应</span></span><br><span class="line">        <span class="keyword">for</span> (MultiSearchTemplateResponse.Item item : multiResponse.getResponses()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (item.isFailure()) &#123;</span><br><span class="line">                String error = item.getFailureMessage(); <span class="comment">//搜索请求失败返回错误信息</span></span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                SearchTemplateResponse searchTemplateResponse = item.getResponse();</span><br><span class="line">                SearchResponse response = searchTemplateResponse.getResponse();</span><br><span class="line">                SearchHits hits = response.getHits();</span><br><span class="line">                System.out.println(<span class="string">"----------"</span>);</span><br><span class="line">                <span class="keyword">for</span> (SearchHit hit : hits) &#123;</span><br><span class="line">                    System.out.println(hit.getSourceAsString());</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="获取集群信息"><a href="#获取集群信息" class="headerlink" title="获取集群信息"></a>获取集群信息</h3><p> ElasticSearch 可以通过<code>info()</code>方法检索群集信息：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">info</span><span class="params">()</span></span>&#123;</span><br><span class="line">    RestHighLevelClient client = elasticClient.getRestHighLevelClient();</span><br><span class="line">    MainResponse response = <span class="keyword">null</span>;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">        response = client.info(RequestOptions.DEFAULT);</span><br><span class="line">    &#125; <span class="keyword">catch</span> (IOException e) &#123;</span><br><span class="line">        e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//返回集群的各种信息</span></span><br><span class="line">    ClusterName clusterName = response.getClusterName(); <span class="comment">//集群名称</span></span><br><span class="line">    String clusterUuid = response.getClusterUuid(); <span class="comment">//群集的唯一标识符</span></span><br><span class="line">    String nodeName = response.getNodeName(); <span class="comment">//已执行请求的节点的名称</span></span><br><span class="line">    Version version = response.getVersion(); <span class="comment">//已执行请求的节点的版本</span></span><br><span class="line">    Build build = response.getBuild(); <span class="comment">//已执行请求的节点的构建信息</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>通过使用ping()</code>方法可以检查集群是否连接成功，并返回一个布尔值：</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="keyword">boolean</span> response = client.ping（RequestOptions.DEFAULT）;</span><br></pre></td></tr></table></figure><h2 id="相关博客推荐"><a href="#相关博客推荐" class="headerlink" title="相关博客推荐"></a>相关博客推荐</h2><ul><li><a href="http://www.cnblogs.com/ljhdo/p/4887557.html" target="_blank" rel="noopener">ElasticSearch入门 第一篇：Windows下安装ElasticSearch</a></li><li><a href="http://www.cnblogs.com/ljhdo/p/4959412.html" target="_blank" rel="noopener">ElasticSearch入门 第二篇：集群配置</a></li><li><a href="http://www.cnblogs.com/ljhdo/p/4981928.html" target="_blank" rel="noopener">ElasticSearch入门 第三篇：索引</a></li><li><a href="http://www.cnblogs.com/ljhdo/p/5160329.html" target="_blank" rel="noopener">ElasticSearch入门 第四篇：使用C#添加和更新文档</a></li><li><a href="http://www.cnblogs.com/ljhdo/p/4550135.html" target="_blank" rel="noopener">ElasticSearch入门 第五篇：使用C#查询文档</a></li><li><a href="http://www.cnblogs.com/ljhdo/p/4904430.html" target="_blank" rel="noopener">ElasticSearch入门 第六篇：复合数据类型——数组，对象和嵌套</a></li><li><a href="http://www.cnblogs.com/ljhdo/p/5012510.html" target="_blank" rel="noopener">ElasticSearch入门 第七篇：分析器</a></li><li><a href="http://www.cnblogs.com/ljhdo/p/5016852.html" target="_blank" rel="noopener">ElasticSearch入门 第八篇：存储</a></li><li><a href="http://www.cnblogs.com/ljhdo/p/4911878.html" target="_blank" rel="noopener">ElasticSearch入门 第九篇：实现正则表达式查询的思路</a></li><li><a href="http://www.cnblogs.com/ljhdo/p/4486978.html" target="_blank" rel="noopener">ElasticSearch查询 第一篇：搜索API</a></li><li><a href="http://www.cnblogs.com/ljhdo/p/4885796.html" target="_blank" rel="noopener">ElasticSearch查询 第二篇：文档更新</a></li><li><a href="http://www.cnblogs.com/ljhdo/p/4551490.html" target="_blank" rel="noopener">ElasticSearch查询 第三篇：词条查询</a></li><li><a href="http://www.cnblogs.com/ljhdo/p/4577065.html" target="_blank" rel="noopener">ElasticSearch查询 第四篇：匹配查询（Match）</a></li><li><a href="http://www.cnblogs.com/ljhdo/p/5040252.html" target="_blank" rel="noopener">ElasticSearch查询 第五篇：布尔查询</a></li><li><a href="https://www.cnblogs.com/fnlingnzb-learner/p/10750868.html" target="_blank" rel="noopener">使用Java High Level REST Client操作elasticsearch</a></li><li><a href="https://www.cnblogs.com/ginb/p/8696090.html" target="_blank" rel="noopener">使用Java客户端操作elasticsearch（二）</a></li><li><a href="https://www.cnblogs.com/reycg-blog/p/9931482.html" target="_blank" rel="noopener">Elasticsearch Java Rest Client API 整理总结 (一)——Document API</a></li><li><a href="https://www.cnblogs.com/reycg-blog/p/9946821.html" target="_blank" rel="noopener">Elasticsearch Java Rest Client API 整理总结 (二) —— SearchAPI</a></li><li><a href="https://www.cnblogs.com/reycg-blog/p/9993094.html" target="_blank" rel="noopener">Elasticsearch Java Rest Client API 整理总结 (三)——Building Queries</a></li><li><a href="https://www.cnblogs.com/reycg-blog/p/10000052.html" target="_blank" rel="noopener">Elasticsearch Query DSL 整理总结（一）—— Query DSL 概要，MatchAllQuery，全文查询简述</a></li><li><a href="https://www.cnblogs.com/reycg-blog/p/10002794.html" target="_blank" rel="noopener">Elasticsearch Query DSL 整理总结（二）MatchAllQuery详解</a></li><li><a href="https://www.cnblogs.com/reycg-blog/p/10012238.html" target="_blank" rel="noopener">Elasticsearch Query DSL 整理总结（三）—— Match Phrase Query 和 Match Phrase Prefix Query</a></li><li><a href="https://www.cnblogs.com/reycg-blog/p/10055039.html" target="_blank" rel="noopener">Elasticsearch Query DSL 整理总结（四）—— Multi Match Query</a></li></ul><ul><li><p>官网链接</p><p>Elasticsearch: 权威指南：<a href="https://www.elastic.co/guide/cn/elasticsearch/guide/current/index.html" target="_blank" rel="noopener">https://www.elastic.co/guide/cn/elasticsearch/guide/current/index.html</a></p><p> Java REST Client： <a href="https://www.elastic.co/guide/en/elasticsearch/client/java-rest/6.3/index.html" target="_blank" rel="noopener">https://www.elastic.co/guide/en/elasticsearch/client/java-rest/6.3/index.html</a>：</p></li></ul><p>over</p>]]></content>
      
      
      <categories>
          
          <category> 技术栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> elasticsearch </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>SpringDataRedis实现缓存问题的解决</title>
      <link href="/2019/06/18/SpringDataRedis%E5%A4%87%E5%BF%98/"/>
      <url>/2019/06/18/SpringDataRedis%E5%A4%87%E5%BF%98/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Spring Data是Spring的一个子项目。Spring官方提供一套数据层综合解决方案，用于简化数据库访问，支持NoSQL和关系数据库存储。包括Spring Data JPA 、Spring Data Redis 、SpringDataSolr、SpringDataElasticsearch 、Spring DataMongodb 等框架。</p><p><a href="https://spring.io/projects/spring-data-redis#overview" target="_blank" rel="noopener">Spring Data Redis（SDR）</a>提供Spring框架和Redis键值存储之间的集成！</p><h1 id="为什么SDR"><a href="#为什么SDR" class="headerlink" title="为什么SDR"></a>为什么SDR</h1><pre><code>Spring Framework是领先的全栈Java / JEE应用程序框架。它提供了一个轻量级容器和一个非侵入式编程模型，它通过使用依赖注入，AOP和便携式服务抽象来实现。NoSQL存储系统为经典RDBMS提供了水平可扩展性和速度的替代方案。在实现方面，键值存储代表NoSQL空间中最大（和最老）的成员之一。Spring Data Redis（SDR）框架通过Spring的优秀基础架构支持消除了与商店交互所需的冗余任务和样板代码，可以轻松编写使用Redis键值存储的Spring应用程序。</code></pre><p>这段文字来自官方文档。</p><p>在手上的项目中，选择了Jedis为客户端工具，它是Redis官方首选的Java客户端开发包，还有JRedis等多种。<br>spring-data-redis针对jedis提供了如下功能： </p><pre><code>1.连接池自动管理，提供了一个高度封装的“RedisTemplate”类，提供高级抽象，用于执行各种Redis操作，异常转换和序列化支持2.针对jedis客户端中大量api进行了归类封装,将同一类型操作封装为operation接口     ValueOperations：简单K-V操作    SetOperations：set类型数据操作    ZSetOperations：zset类型数据操作    HashOperations：针对map类型的数据操作    ListOperations：针对list类型的数据操作</code></pre><h1 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h1><p>0.命令</p><pre><code>redisTemplate.boundValueOps();//对字符串或值操作  set/get/deleteredisTemplate.boundListOps();//对List集合操作  lpush/rpush/range/index/remove redisTemplate.boundSetOps();//对Set集合操作  add/members/remove/deleteredisTemplate.boundHashOps();//对Hash操作  put/keys/values/get(key)/delete(key)redisTemplate.boundZSetOps();//对ZSet操作 add/range/reverseRange/incrementScore</code></pre><p>设置过期时间</p><figure class="highlight java"><table><tr><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">  * 存值</span></span><br><span class="line"><span class="comment">  */</span></span><br><span class="line"> <span class="meta">@Test</span></span><br><span class="line"> <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">setValue</span><span class="params">()</span></span>&#123;</span><br><span class="line">     redisTemplate.boundValueOps(<span class="string">"name"</span>).set(<span class="string">"aaaa"</span>);</span><br><span class="line">     redisTemplate.boundValueOps(<span class="string">"name"</span>).expire(<span class="number">10</span>,TimeUnit.SECONDS);</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>1.添加依赖</p><pre><code>&lt;!--缓存--&gt;&lt;dependency&gt;    &lt;groupId&gt;redis.clients&lt;/groupId&gt;    &lt;artifactId&gt;jedis&lt;/artifactId&gt;    &lt;version&gt;2.9.0&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt;    &lt;groupId&gt;org.springframework.data&lt;/groupId&gt;    &lt;artifactId&gt;spring-data-redis&lt;/artifactId&gt;    &lt;version&gt;2.0.5.RELEASE&lt;/version&gt;&lt;/dependency&gt;</code></pre><p>2.配置redis-config.properties</p><pre><code>redis.host=127.0.0.1redis.port=6379redis.pass=redis.database=0redis.maxIdle=300redis.maxWait=3000</code></pre><p>3.配置applicationContext-redis.xml</p><pre><code>   &lt;context:property-placeholder location=&quot;classpath:redis-config.properties&quot; /&gt;   &lt;!-- redis 相关配置 --&gt;    &lt;bean id=&quot;poolConfig&quot; class=&quot;redis.clients.jedis.JedisPoolConfig&quot;&gt;       &lt;property name=&quot;maxIdle&quot; value=&quot;${redis.maxIdle}&quot; /&gt;        &lt;property name=&quot;maxWaitMillis&quot; value=&quot;${redis.maxWait}&quot; /&gt;     &lt;/bean&gt;     &lt;bean id=&quot;jedisConnectionFactory&quot; class=&quot;org.springframework.data.redis.connection.jedis.JedisConnectionFactory&quot;       p:host-name=&quot;${redis.host}&quot; p:port=&quot;${redis.port}&quot; p:password=&quot;${redis.pass}&quot; p:pool-config-ref=&quot;poolConfig&quot;/&gt;     &lt;bean id=&quot;redisTemplate&quot; class=&quot;org.springframework.data.redis.core.RedisTemplate&quot;&gt;          &lt;property name=&quot;connectionFactory&quot; ref=&quot;jedisConnectionFactory&quot; /&gt;   &lt;/bean&gt;&lt;/beans&gt;  </code></pre><h1 id="业务场景分析"><a href="#业务场景分析" class="headerlink" title="业务场景分析"></a>业务场景分析</h1><ul><li>在做电商门户系统前台的分类导航和广告显示时，可能发生与数据库过于频繁的交互，或者恶意攻击的行为而导致数据库压力过大等问题，以致缓存穿透，缓存击穿和缓存雪崩问题。<blockquote><p>因此将这些数据在页面加载时就放到缓存中，定义一个Init类(实现InitializingBean)，重写方法。另外，在增删改的操作时，应该更新缓存。</p></blockquote></li></ul>]]></content>
      
      
      <categories>
          
          <category> 框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Redis </tag>
            
            <tag> Spring </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解决上传本地项目到码云的reject问题</title>
      <link href="/2019/06/11/%E8%A7%A3%E5%86%B3%E4%B8%8A%E4%BC%A0%E6%9C%AC%E5%9C%B0%E9%A1%B9%E7%9B%AE%E5%88%B0%E7%A0%81%E4%BA%91%E7%9A%84rejected%E9%97%AE%E9%A2%98/"/>
      <url>/2019/06/11/%E8%A7%A3%E5%86%B3%E4%B8%8A%E4%BC%A0%E6%9C%AC%E5%9C%B0%E9%A1%B9%E7%9B%AE%E5%88%B0%E7%A0%81%E4%BA%91%E7%9A%84rejected%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><pre><code>![rejected]master-&gt;master(fetch first)error: failed to push some refs to &apos;https://gitee.com/qhr1994/myproject1.git&apos;hint: Updates were rejected because the remote contains work that you dohint: not have locally. This is usually caused by another repository pushinghint: to the same ref. You may want to first integrate the remote changeshint: (e.g., &apos;git pull ...&apos;) before pushing again.hint: See the &apos;Note about fast-forwards&apos; in &apos;git push --help&apos; for details.</code></pre><h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>这是由于远程仓库上的md文件不在本地仓库中代码合并即可</p><pre><code>$ git pull --rebase origin master</code></pre><p>注意：这里的origin填你的</p><pre><code>$ git remote</code></pre><p>的结果</p>]]></content>
      
      
      <categories>
          
          <category> 技术栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>zookeeper问题</title>
      <link href="/2019/06/03/zookeeper%E9%97%AE%E9%A2%98/"/>
      <url>/2019/06/03/zookeeper%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="关于遇到的zookeeper问题以及尝试的解决方案"><a href="#关于遇到的zookeeper问题以及尝试的解决方案" class="headerlink" title="关于遇到的zookeeper问题以及尝试的解决方案"></a>关于遇到的zookeeper问题以及尝试的解决方案</h1><hr><p>在做(MacOS系统下)SSM+Dubbo(vesion 2.6.0)分模块开发项目时，使用的是zookeeper3.4.6<br>为注册服务器并以本地磁盘启动注册中心，idea控制台报错</p><pre><code>the zookeeper is not connecting yet!</code></pre><p>或者</p><pre><code>no provider...</code></pre><p>又或</p><pre><code>Exception: java.lang.NoClassDefFoundError thrown from the UncaughtExceptionHandler in thread &quot;DubboZkclientConnector-SendThread(127.0.0.1:2181)&quot;</code></pre><p>很显然是本地zookeeper的服务中断，但终端服务没有异常，考虑到请求超时，去修改/zookeeper…/conf中的zoo.cfg配置文件。</p><p>这里有许多参数，网上有很多解释，去官网看也没看到啥，这里参考一篇博客，<a href="https://www.cnblogs.com/likui360/p/5985588.html" target="_blank" rel="noopener">点此进入</a></p><p>比如：</p><blockquote><p>tickTime:ZK中的一个时间单元。ZK中所有时间都是以这个时间单元为基础，进行整数倍配置的。例如，session的最小超时时间是2*tickTime。</p><p>initLimit:Follower在启动过程中，会从Leader同步所有最新数据，然后确定自己能够对外服务的起始状态。Leader允许F在 initLimit 时间内完成这个工作。通常情况下，我们不用太在意这个参数的设置。如果ZK集群的数据量确实很大了，F在启动的时候，从Leader上同步数据的时间也会相应变长，因此在这种情况下，有必要适当调大这个参数了。</p><p>minSessionTimeoutmaxSessionTimeout:Session超时时间限制，如果客户端设置的超时时间不在这个范围，那么会被强制设置为最大或最小时间。默认的Session超时时间是在2 *  tickTime ~ 20 * tickTime 这个范围 New in 3.3.0</p></blockquote><p>网上有看到人将tickTime调大就解决了，开始我也这么做，但后来还是会发生这个问题，仔细看上面第三个参数，zookeeper还是挺智能的嘛。所以这个方法不是主要问题，修改回默认值2000毫秒。</p><p>再来，我将dubbo版本从2.6.0降低为2.5.6，同样的，问题也只能暂时解决。</p><h2 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h2><p>1.如果你是windows用户，请先保证你的网卡只留一个，这个不过多解释了。</p><p>2.遇到zookeeper以上或者其他问题，尝试降低dubbo依赖的版本。</p><p>3.能力有限，评论区欢迎补充。</p>]]></content>
      
      
      <categories>
          
          <category> 技术栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> zookeeper </tag>
            
            <tag> dubbo </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一个转账案例-Spring声明式事务全注解开发完成</title>
      <link href="/2019/05/31/Spring%E5%A3%B0%E6%98%8E%E5%BC%8F%E4%BA%8B%E5%8A%A1%E5%85%A8%E6%B3%A8%E8%A7%A3%E5%BC%80%E5%8F%91/"/>
      <url>/2019/05/31/Spring%E5%A3%B0%E6%98%8E%E5%BC%8F%E4%BA%8B%E5%8A%A1%E5%85%A8%E6%B3%A8%E8%A7%A3%E5%BC%80%E5%8F%91/</url>
      
        <content type="html"><![CDATA[<h2 id="xml配置文件"><a href="#xml配置文件" class="headerlink" title="xml配置文件"></a>xml配置文件</h2><p>在使用全注解形式去完成转账案例之前，我们先看看在使用纯xml配置的applicationConfiguration.xml</p><pre><code>&lt;bean id=&quot;accountDao&quot; class=&quot;com.xxx.dao.impl.AccountDaoImpl&quot;&gt;    &lt;property name=&quot;jdbcTemplate&quot; ref=&quot;jdbcTemplate&quot;/&gt;&lt;/bean&gt;&lt;bean id=&quot;jdbcTemplate&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt;    &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;&lt;/bean&gt;&lt;bean id=&quot;dataSource&quot; class=&quot;com.mchange.v2.c3p0.ComboPooledDataSource&quot;&gt;    &lt;property name=&quot;driverClass&quot; value=&quot;com.mysql.jdbc.Driver&quot;/&gt;    &lt;property name=&quot;jdbcUrl&quot; value=&quot;jdbc:mysql:///account_db&quot;/&gt;    &lt;property name=&quot;user&quot; value=&quot;root&quot;/&gt;    &lt;property name=&quot;password&quot; value=&quot;123456&quot;/&gt;&lt;/bean&gt;&lt;bean id=&quot;accountService&quot; class=&quot;com.xxx.service.impl.AccountServiceImpl&quot;&gt;    &lt;property name=&quot;accountDao&quot; ref=&quot;accountDao&quot;/&gt;&lt;/bean&gt;&lt;!--配置平台事务管理器 同样要依赖dataSource--&gt;&lt;bean id=&quot;transactionManager&quot; class=&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;&gt;    &lt;property name=&quot;dataSource&quot; ref=&quot;dataSource&quot;/&gt;&lt;/bean&gt;&lt;!--通知事务的增强--&gt;&lt;!--propagation 事务传播行为REQUIRED：指定当前方法必需在事务环境中运行，如果当前有事务环境就加入当前正在执行的事务环境，如果当前没有事务，就新建一个事务。这是默认值。isolation 事务隔离级别DEFAULT：采用数据库默认隔离级别--&gt;&lt;tx:advice id=&quot;tx&quot; transaction-manager=&quot;transactionManager&quot;&gt;    &lt;tx:attributes&gt;        &lt;tx:method name=&quot;transfer&quot; isolation=&quot;DEFAULT&quot; propagation=&quot;REQUIRED&quot; read-only=&quot;false&quot;/&gt;        &lt;tx:method name=&quot;find&quot; isolation=&quot;DEFAULT&quot; propagation=&quot;REQUIRED&quot; read-only=&quot;true&quot;/&gt;        &lt;tx:method name=&quot;*&quot;/&gt;    &lt;/tx:attributes&gt;&lt;/tx:advice&gt;&lt;!--事务的织入--&gt;&lt;aop:config proxy-target-class=&quot;true&quot;&gt;    &lt;aop:advisor advice-ref=&quot;tx&quot; pointcut=&quot;execution(* com.xxxservice.impl.*.*(..))&quot;/&gt;&lt;/aop:config&gt;</code></pre><h2 id="全注解形式源码"><a href="#全注解形式源码" class="headerlink" title="全注解形式源码"></a>全注解形式源码</h2><ol start="0"><li><p>建表</p><pre><code>CREATE TABLE account(    id INT PRIMARY KEY AUTO_INCREMENT,    NAME VARCHAR(20),    money DECIMAL);</code></pre></li><li><p>导入所需坐标</p><pre><code>&lt;dependencies&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework&lt;/groupId&gt;        &lt;artifactId&gt;spring-context&lt;/artifactId&gt;        &lt;version&gt;5.0.5.RELEASE&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.aspectj&lt;/groupId&gt;        &lt;artifactId&gt;aspectjweaver&lt;/artifactId&gt;        &lt;version&gt;1.8.4&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework&lt;/groupId&gt;        &lt;artifactId&gt;spring-jdbc&lt;/artifactId&gt;        &lt;version&gt;5.0.5.RELEASE&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework&lt;/groupId&gt;        &lt;artifactId&gt;spring-tx&lt;/artifactId&gt;        &lt;version&gt;5.0.5.RELEASE&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;org.springframework&lt;/groupId&gt;        &lt;artifactId&gt;spring-test&lt;/artifactId&gt;        &lt;version&gt;5.0.5.RELEASE&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;c3p0&lt;/groupId&gt;        &lt;artifactId&gt;c3p0&lt;/artifactId&gt;        &lt;version&gt;0.9.1.2&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;mysql&lt;/groupId&gt;        &lt;artifactId&gt;mysql-connector-java&lt;/artifactId&gt;        &lt;version&gt;5.1.32&lt;/version&gt;    &lt;/dependency&gt;    &lt;dependency&gt;        &lt;groupId&gt;junit&lt;/groupId&gt;        &lt;artifactId&gt;junit&lt;/artifactId&gt;        &lt;version&gt;4.12&lt;/version&gt;    &lt;/dependency&gt;&lt;/dependencies&gt;</code></pre></li><li><p>AccountDaoImpl.java</p><pre><code>@Repositorypublic class AccountDaoImpl implements AccountDao {@Autowiredprivate JdbcTemplate jdbcTemplate;</code></pre></li></ol><pre><code>    public void out(String outMan, double money) {        jdbcTemplate.update(&quot;update account set money=money-? where name=?&quot;,money,outMan);    }    public void in(String inMan, double money) {        jdbcTemplate.update(&quot;update account set money=money+? where name=?&quot;,money,inMan);    }}</code></pre><ol start="3"><li><p>AccountServiceImpl.java</p><pre><code>@Service@EnableTransactionManagementpublic class AccountServiceImpl implements AccountService {    @Autowired    private AccountDao accountDao;    @Transactional(isolation = Isolation.DEFAULT,propagation = Propagation.REQUIRED,readOnly = false)    public void transfer(String outMan, String inMan, double money) {        accountDao.out(outMan,money);//        int i = 1/0;        accountDao.in(inMan,money);    }}</code></pre></li><li><p>SpringConfiguration.java</p><p>@Configuration</p><pre><code>@ComponentScan(&quot;com.xxx&quot;)@Import(DataSourceConfiguration.class)public class SpringConfiguration {</code></pre></li></ol><pre><code>}</code></pre><ol start="5"><li><p>DataSourceConfiguration.java</p><pre><code>@Configuration@PropertySource(&quot;classpath:jdbc.properties&quot;)public class DataSourceConfiguration {</code></pre></li></ol><pre><code>    @Value(&quot;${jdbc.driver}&quot;)    private String driverClass;    @Value(&quot;${jdbc.url}&quot;)    private String url;    @Value(&quot;${jdbc.username}&quot;)    private String user;    @Value(&quot;${jdbc.password}&quot;)    private String password;    @Bean    public DataSource getDataSource() throws PropertyVetoException {        ComboPooledDataSource dataSource = new ComboPooledDataSource();        dataSource.setDriverClass(driverClass);        dataSource.setJdbcUrl(url);        dataSource.setUser(user);        dataSource.setPassword(password);        return dataSource;    }    @Bean    public JdbcTemplate getTemplate(DataSource dataSource){        return new JdbcTemplate(dataSource);    }    @Bean    public DataSourceTransactionManager getDSTM(DataSource dataSource){        return new DataSourceTransactionManager(dataSource);    }}</code></pre><ol start="6"><li><p>jdbc.properties</p><pre><code>jdbc.driver=com.mysql.jdbc.Driverjdbc.url=jdbc:mysql:///account_dbjdbc.username=rootjdbc.password=123456</code></pre></li><li><p>测试</p><pre><code>@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(classes = SpringConfiguration.class)public class AnnoTest {    @Autowired    private AccountService accountService;    @Test    public void test02(){        accountService.transfer(&quot;tom&quot;,&quot;lucy&quot;,500f);    }}</code></pre></li></ol>]]></content>
      
      
      <categories>
          
          <category> 框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> annotation </tag>
            
            <tag> transaction </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring注解</title>
      <link href="/2019/05/29/Spring%E6%B3%A8%E8%A7%A3/"/>
      <url>/2019/05/29/Spring%E6%B3%A8%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>初学Spring,相较于xml文件的配置，注解开发的确要简洁的多。但有时还是会忘了一些，故在此整合。</p><h2 id="一般注解列表"><a href="#一般注解列表" class="headerlink" title="一般注解列表"></a>一般注解列表</h2><pre><code>注解                                               说明@Component                                   使用在类上用于实例化Bean@Controller                             使用在web层类上用于实例化Bean@Service                                 使用在service层类上用于实例化Bean@Repository                         使用在dao层类上用于实例化Bean@Autowired                         使用在字段上用于根据类型依赖注入@Qualifier                             结合@Autowired一起使用用于根据名称进行依赖注入@Resource                         相当于@Autowired+@Qualifier，按照名称进行注入@Value                             注入普通属性@Scope                             标注Bean的作用范围@PostConstruct                     使用在方法上标注该方法是Bean的初始化方法@PreDestroy                         使用在方法上标注该方法是Bean的销毁方法</code></pre><p>配置组件扫描</p><pre><code> &lt;!--注解的组件扫描--&gt;&lt;context:component-scan base-package=&quot;com.xxx&quot;&gt;&lt;/context:component-scan&gt;</code></pre><hr><p>较新的</p><pre><code>@Configuration             用于指定当前类是一个 Spring 配置类，当创建容器时会从该类上加载注解@ComponentScan            用于指定 Spring 在初始化容器时要扫描的包。 作用和在 Spring 的 xml 配置文件中的 &lt;context:component-scan base-package=&quot;com.itheima&quot;/&gt;一样@Bean                     使用在方法上，标注将该方法的返回值存储到 Spring 容器中@PropertySource             用于加载.properties 文件中的配置@Import                     用于导入其他配置类</code></pre><p>这里注意非自定义的Bean的配置</p><pre><code>加载properties文件的配置：context:property-placeholder组件扫描的配置：context:component-scan</code></pre><hr><p>Spring集成<font color="red">Junit测试</font>注解</p><p>配置@Runwith、@ContextConfiguration注解<br>这里测试的基本流程为</p><ul><li>导入spring集成Junit的坐标</li><li>使用@Runwith注解替换原来的运行期</li><li>使用@ContextConfiguration指定配置文件或配置类</li><li>使用@Autowired注入需要测试的对象</li><li>创建测试方法进行测试</li></ul><p>Demo</p><pre><code>@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(classes = {SpringConfiguration.class})public class SpringJunitTest {  @Autowired  private UserService userService;  @Test  public void testUserService(){ userService.save(); }}</code></pre><hr><p> 基于<font color="red">AOP</font>开发的注解<br>先了解开发步骤</p><p>①使用<font color="red">@Aspect</font>标注切面类</p><p>②使用@通知注解标注通知方法</p><p>③在配置文件中配置aop自动代理<font color="red"><a href="aop:aspectj-autoproxy/" target="_blank" rel="noopener">aop:aspectj-autoproxy/</a></font></p><p>其中第②步的注解有以下<br><img src="https://i.loli.net/2019/05/31/5cf08952e6ade71571.png" alt></p><h2 id="声明式事务控制的注解开发"><a href="#声明式事务控制的注解开发" class="headerlink" title="声明式事务控制的注解开发"></a>声明式事务控制的注解开发</h2><p>@Transactional 在想要添加事务的方法上使用(可加参数)</p><p>@EableTransactionManagement 注解驱动(相当于annotation-driven,一般放在业务层上)</p><p>@EableAspectJAutoProxy 开启AOP自动代理支持</p>]]></content>
      
      
      <categories>
          
          <category> 框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> annotation </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Spring通过DataSource获取数据库数据(非注解方式和注解形式)及Spring集成Junit测试</title>
      <link href="/2019/05/27/Spring%E9%80%9A%E8%BF%87DataSource%E8%8E%B7%E5%8F%96%E6%95%B0%E6%8D%AE%E5%BA%93%E6%95%B0%E6%8D%AE/"/>
      <url>/2019/05/27/Spring%E9%80%9A%E8%BF%87DataSource%E8%8E%B7%E5%8F%96%E6%95%B0%E6%8D%AE%E5%BA%93%E6%95%B0%E6%8D%AE/</url>
      
        <content type="html"><![CDATA[<h2 id="非注解"><a href="#非注解" class="headerlink" title="非注解"></a>非注解</h2><p>这里就不多说了，直接来源码</p><p>1.导入各坐标<br>这里包括数据库连接池(druid/c3p0)，单元测试，数据库连接驱动坐标以及spring的依赖就不一一写出了</p><pre><code>&lt;dependencies&gt;&lt;dependency&gt;  &lt;groupId&gt;org.springframework&lt;/groupId&gt;  &lt;artifactId&gt;spring-context&lt;/artifactId&gt;  &lt;version&gt;5.0.5.RELEASE&lt;/version&gt;&lt;/dependency&gt;&lt;!--druid连接池--&gt;&lt;dependency&gt;  &lt;groupId&gt;com.alibaba&lt;/groupId&gt;  &lt;artifactId&gt;druid&lt;/artifactId&gt;  &lt;version&gt;1.1.13&lt;/version&gt;&lt;/dependency&gt;</code></pre><p>2.AccountDaoImpl.java</p><pre><code>public class AccountDaoImpl implements AccountDao {private JdbcTemplate template;public void setTemplate(JdbcTemplate template) {    this.template = template;}public void findAll(){    List&lt;Map&lt;String, Object&gt;&gt; list = template.queryForList(&quot;select * from teacher&quot;);    for (Map&lt;String, Object&gt; map : list) {        for (String s : map.keySet()) {            System.out.println(s+&quot;:&quot;+map.get(s));        }    }  }}</code></pre><p>3.AccountServiceImpl.java</p><pre><code>public class AccountServiceImpl implements AccountService {    private AccountDaoImpl accountDao;    public void setAccountDao(AccountDaoImpl accountDao) {        this.accountDao = accountDao;    }    @Override    public void findAll() {        ClassPathXmlApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);        AccountDao accountDao = (AccountDao) applicationContext.getBean(&quot;accountDao&quot;);        accountDao.findAll();        System.out.println(&quot;username:&quot;+username);    }}</code></pre><p>4.applicationContext.xml</p><pre><code>&lt;bean id=&quot;accountDao&quot; class=&quot;top.jigw.dao.impl.AccountDaoImpl&quot;&gt;        &lt;property name=&quot;template&quot; ref=&quot;jdbcTemplate&quot;&gt;&lt;/property&gt;    &lt;/bean&gt;    &lt;bean id=&quot;accountService&quot; class=&quot;top.jigw.service.impl.AccountServiceImpl&quot;&gt;        &lt;property name=&quot;accountDao&quot; ref=&quot;accountDao&quot;&gt;&lt;/property&gt;    &lt;/bean&gt;    &lt;bean id=&quot;dataSource&quot; class=&quot;com.alibaba.druid.pool.DruidDataSourceFactory&quot; factory-method=&quot;createDataSource&quot;&gt;        &lt;constructor-arg name=&quot;properties&quot;&gt;            &lt;props&gt;                &lt;prop key=&quot;driverClassName&quot;&gt;com.mysql.jdbc.Driver&lt;/prop&gt;                &lt;prop key=&quot;url&quot;&gt;jdbc:mysql:///test&lt;/prop&gt;                &lt;prop key=&quot;username&quot;&gt;root&lt;/prop&gt;                &lt;prop key=&quot;password&quot;&gt;123456&lt;/prop&gt;            &lt;/props&gt;        &lt;/constructor-arg&gt;    &lt;/bean&gt;    &lt;bean id=&quot;jdbcTemplate&quot; class=&quot;org.springframework.jdbc.core.JdbcTemplate&quot;&gt;        &lt;constructor-arg name=&quot;dataSource&quot; ref=&quot;dataSource&quot;&gt;&lt;/constructor-arg&gt;    &lt;/bean&gt;</code></pre><p>5.单元测试</p><pre><code>public class test {    @Test    public void test01() {        ClassPathXmlApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);        AccountService accountService = (AccountService) applicationContext.getBean(&quot;accountService&quot;);        accountService.findAll();    }}</code></pre><h2 id="注解形式"><a href="#注解形式" class="headerlink" title="注解形式"></a>注解形式</h2><p>1.首先同样是导入坐标</p><p>2.提取jdbc.properties</p><pre><code>jdbc.driver=com.mysql.jdbc.Driverjdbc.url=jdbc:mysql:///testjdbc.username=rootjdbc.password=123456</code></pre><p>3.了解下Spring的一些基本注解吧</p><pre><code>注解                             说明@Component        使用在类上用于实例化Bean@Controller            使用在web层类上用于实例化Bean@Service              使用在service层类上用于实例化Bean@Repository         使用在dao层类上用于实例化Bean@Autowired         使用在字段上用于根据类型依赖注入@Qualifier             结合@Autowired一起使用用于根据名称进行依赖注入@Resource         相当于@Autowired+@Qualifier，按照名称进行注入@Value             注入普通属性@Scope             标注Bean的作用范围@PostConstruct     使用在方法上标注该方法是Bean的初始化方法@PreDestroy         使用在方法上标注该方法是Bean的销毁方法@Configuration 用于指定当前类是一个 Spring 配置类，当创建容器时会从该类上加载注解@ComponentScan 用于指定 Spring 在初始化容器时要扫描的包。 作用和在 Spring 的 xml 配置文件中的 &lt;context:component-scan base-package=&quot;com.itheima&quot;/&gt;一样@Bean 使用在方法上，标注将该方法的返回值存储到 Spring 容器中@PropertySource 用于加载.properties 文件中的配置@Import 用于导入其他配置类</code></pre><p>使用注解进行开发时，需要在applicationContext.xml中配置组件扫描，作用是指定哪个包及其子包下的Bean需要<br>进行扫描以便识别使用注解配置的类、字段和方法。</p><pre><code>&lt;context:component-scan base-package=&quot;top.jigw&quot;&gt;&lt;/context:component-scan&gt;</code></pre><p>4.AccountDaoImpl.java</p><pre><code>@Repository(&quot;accountDao&quot;)public class AccountDaoImpl implements AccountDao {private JdbcTemplate template;public void setTemplate(JdbcTemplate template) {    this.template = template;}public void findAll(){    List&lt;Map&lt;String, Object&gt;&gt; list = template.queryForList(&quot;select * from teacher&quot;);    for (Map&lt;String, Object&gt; map : list) {        for (String s : map.keySet()) {            System.out.println(s+&quot;:&quot;+map.get(s));        }    }  }}</code></pre><p>5.AccountServiceImpl.java</p><pre><code>@Service(&quot;accountService&quot;)public class AccountServiceImpl implements AccountService {    private AccountDaoImpl accountDao;    public void setAccountDao(AccountDaoImpl accountDao) {        this.accountDao = accountDao;    }    @Override    public void findAll() {        ClassPathXmlApplicationContext applicationContext = new ClassPathXmlApplicationContext(&quot;applicationContext.xml&quot;);        AccountDao accountDao = (AccountDao) applicationContext.getBean(&quot;accountDao&quot;);        accountDao.findAll();        System.out.println(&quot;username:&quot;+username);    }}</code></pre><p>6.SpringConfiguration.java</p><pre><code>@Configuration@ComponentScan(&quot;top.jigw&quot;)@Import({DataSourceConfiguration.class})public class SpringConfiguration {}</code></pre><p>7.DataSourceConfiguration.java</p><pre><code>@PropertySource(&quot;classpath:jdbc.properties&quot;)public class DataSourceConfiguration {    @Value(&quot;${jdbc.driver}&quot;)    private String driver;    @Value(&quot;${jdbc.url}&quot;)    private String url;    @Value(&quot;${jdbc.username}&quot;)    private String username;    @Value(&quot;${jdbc.password}&quot;)    private String password;    @Bean(name = &quot;dataSource&quot;)    public DataSource getDataSource(){        DruidDataSource dataSource = new DruidDataSource();        dataSource.setDriverClassName(driver);        dataSource.setUrl(url);        dataSource.setUsername(username);        dataSource.setPassword(password);        return dataSource;    }    @Bean(name = &quot;template&quot;)    public JdbcTemplate getTemplate(DataSource dataSource){        return new JdbcTemplate(dataSource);    }}</code></pre><h2 id="集成Junit测试"><a href="#集成Junit测试" class="headerlink" title="集成Junit测试"></a>集成Junit测试</h2><p>这里需要导入spring-test依赖包</p><pre><code>Spring集成Junit步骤①导入spring集成Junit的坐标②使用@Runwith注解替换原来的运行期③使用@ContextConfiguration指定配置文件或配置类④使用@Autowired注入需要测试的对象⑤创建测试方法进行测试</code></pre><p>SpringJunitTest.java</p><pre><code>@RunWith(SpringJUnit4ClassRunner.class)@ContextConfiguration(classes = SpringConfiguration.class)public class SpringJunitTest {    @Autowired    private AccountService accountService;    @Test    public void testService(){        accountService.findAll();    }}</code></pre>]]></content>
      
      
      <categories>
          
          <category> 框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> maven </tag>
            
            <tag> druid </tag>
            
            <tag> junit </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redis了解(转载)</title>
      <link href="/2019/05/24/Redis/"/>
      <url>/2019/05/24/Redis/</url>
      
        <content type="html"><![CDATA[<blockquote><p>转载自：<a href="https://github.com/Snailclimb/JavaGuide" target="_blank" rel="noopener">https://github.com/Snailclimb/JavaGuide</a></p></blockquote><!-- TOC --><ul><li><a href="#redis-简介">redis 简介</a></li><li><a href="#为什么要用-redis为什么要用缓存">为什么要用 redis/为什么要用缓存</a></li><li><a href="#为什么要用-redis-而不用-mapguava-做缓存">为什么要用 redis 而不用 map/guava 做缓存?</a></li><li><a href="#redis-和-memcached-的区别">redis 和 memcached 的区别</a></li><li><a href="#redis-常见数据结构以及使用场景分析">redis 常见数据结构以及使用场景分析</a><ul><li><a href="#1string">1.String</a></li><li><a href="#2hash">2.Hash</a></li><li><a href="#3list">3.List</a></li><li><a href="#4set">4.Set</a></li><li><a href="#5sorted-set">5.Sorted Set</a></li></ul></li><li><a href="#redis-设置过期时间">redis 设置过期时间</a></li><li><a href="#redis-内存淘汰机制mysql里有2000w数据redis中只存20w的数据如何保证redis中的数据都是热点数据">redis 内存淘汰机制(MySQL里有2000w数据，Redis中只存20w的数据，如何保证Redis中的数据都是热点数据?)</a></li><li><a href="#redis-持久化机制怎么保证-redis-挂掉之后再重启数据可以进行恢复">redis 持久化机制(怎么保证 redis 挂掉之后再重启数据可以进行恢复)</a></li><li><a href="#redis-事务">redis 事务</a></li><li><a href="#缓存雪崩和缓存穿透问题解决方案">缓存雪崩和缓存穿透问题解决方案</a></li><li><a href="#如何解决-redis-的并发竞争-key-问题">如何解决 Redis 的并发竞争 Key 问题</a></li><li><a href="#如何保证缓存与数据库双写时的数据一致性">如何保证缓存与数据库双写时的数据一致性?</a></li></ul><!-- /TOC --><h3 id="redis-简介"><a href="#redis-简介" class="headerlink" title="redis 简介"></a>redis 简介</h3><p>简单来说 redis 就是一个数据库，不过与传统数据库不同的是 redis 的数据是存在内存中的，所以读写速度非常快，因此 redis 被广泛应用于缓存方向。另外，redis 也经常用来做分布式锁。redis 提供了多种数据类型来支持不同的业务场景。除此之外，redis 支持事务 、持久化、LUA脚本、LRU驱动事件、多种集群方案。 </p><h3 id="为什么要用-redis-为什么要用缓存"><a href="#为什么要用-redis-为什么要用缓存" class="headerlink" title="为什么要用 redis/为什么要用缓存"></a>为什么要用 redis/为什么要用缓存</h3><p>主要从“高性能”和“高并发”这两点来看待这个问题。</p><p><strong>高性能：</strong></p><p>假如用户第一次访问数据库中的某些数据。这个过程会比较慢，因为是从硬盘上读取的。将该用户访问的数据存在数缓存中，这样下一次再访问这些数据的时候就可以直接从缓存中获取了。操作缓存就是直接操作内存，所以速度相当快。如果数据库中的对应数据改变的之后，同步改变缓存中相应的数据即可！</p><p><img src="http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-9-24/54316596.jpg" alt></p><p><strong>高并发：</strong></p><p>直接操作缓存能够承受的请求是远远大于直接访问数据库的，所以我们可以考虑把数据库中的部分数据转移到缓存中去，这样用户的一部分请求会直接到缓存这里而不用经过数据库。</p><p><img src="http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-9-24/85146760.jpg" alt></p><h3 id="为什么要用-redis-而不用-map-guava-做缓存"><a href="#为什么要用-redis-而不用-map-guava-做缓存" class="headerlink" title="为什么要用 redis 而不用 map/guava 做缓存?"></a>为什么要用 redis 而不用 map/guava 做缓存?</h3><blockquote><p>下面的内容来自 segmentfault 一位网友的提问，地址：<a href="https://segmentfault.com/q/1010000009106416" target="_blank" rel="noopener">https://segmentfault.com/q/1010000009106416</a></p></blockquote><p>缓存分为本地缓存和分布式缓存。以 Java 为例，使用自带的 map 或者 guava 实现的是本地缓存，最主要的特点是轻量以及快速，生命周期随着 jvm 的销毁而结束，并且在多实例的情况下，每个实例都需要各自保存一份缓存，缓存不具有一致性。</p><p>使用 redis 或 memcached 之类的称为分布式缓存，在多实例的情况下，各实例共用一份缓存数据，缓存具有一致性。缺点是需要保持 redis 或  memcached服务的高可用，整个程序架构上较为复杂。</p><h3 id="redis-和-memcached-的区别"><a href="#redis-和-memcached-的区别" class="headerlink" title="redis 和 memcached 的区别"></a>redis 和 memcached 的区别</h3><p>对于 redis 和 memcached 我总结了下面四点。现在公司一般都是用 redis 来实现缓存，而且 redis 自身也越来越强大了！</p><ol><li><strong>redis支持更丰富的数据类型（支持更复杂的应用场景）</strong>：Redis不仅仅支持简单的k/v类型的数据，同时还提供list，set，zset，hash等数据结构的存储。memcache支持简单的数据类型，String。</li><li><strong>Redis支持数据的持久化，可以将内存中的数据保持在磁盘中，重启的时候可以再次加载进行使用,而Memecache把数据全部存在内存之中。</strong></li><li><strong>集群模式</strong>：memcached没有原生的集群模式，需要依靠客户端来实现往集群中分片写入数据；但是 redis 目前是原生支持 cluster 模式的.</li><li><strong>Memcached是多线程，非阻塞IO复用的网络模型；Redis使用单线程的多路 IO 复用模型。</strong></li></ol><blockquote><p>来自网络上的一张图，这里分享给大家！</p></blockquote><p><img src="http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-9-24/61603179.jpg" alt="redis 和 memcached 的区别"></p><h3 id="redis-常见数据结构以及使用场景分析"><a href="#redis-常见数据结构以及使用场景分析" class="headerlink" title="redis 常见数据结构以及使用场景分析"></a>redis 常见数据结构以及使用场景分析</h3><h4 id="1-String"><a href="#1-String" class="headerlink" title="1.String"></a>1.String</h4><blockquote><p><strong>常用命令:</strong>  set,get,decr,incr,mget 等。</p></blockquote><p>String数据结构是简单的key-value类型，value其实不仅可以是String，也可以是数字。<br>常规key-value缓存应用；<br>常规计数：微博数，粉丝数等。</p><h4 id="2-Hash"><a href="#2-Hash" class="headerlink" title="2.Hash"></a>2.Hash</h4><blockquote><p><strong>常用命令：</strong> hget,hset,hgetall 等。</p></blockquote><p>hash 是一个 string 类型的 field 和 value 的映射表，hash 特别适合用于存储对象，后续操作的时候，你可以直接仅仅修改这个对象中的某个字段的值。 比如我们可以 hash 数据结构来存储用户信息，商品信息等等。比如下面我就用 hash 类型存放了我本人的一些信息：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">key=JavaUser293847</span><br><span class="line">value=&#123;</span><br><span class="line">  “id”: 1,</span><br><span class="line">  “name”: “SnailClimb”,</span><br><span class="line">  “age”: 22,</span><br><span class="line">  “location”: “Wuhan, Hubei”</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="3-List"><a href="#3-List" class="headerlink" title="3.List"></a>3.List</h4><blockquote><p><strong>常用命令:</strong> lpush,rpush,lpop,rpop,lrange等</p></blockquote><p>list 就是链表，Redis list 的应用场景非常多，也是Redis最重要的数据结构之一，比如微博的关注列表，粉丝列表，消息列表等功能都可以用Redis的 list 结构来实现。</p><p>Redis list 的实现为一个双向链表，即可以支持反向查找和遍历，更方便操作，不过带来了部分额外的内存开销。</p><p>另外可以通过 lrange 命令，就是从某个元素开始读取多少个元素，可以基于 list 实现分页查询，这个很棒的一个功能，基于 redis 实现简单的高性能分页，可以做类似微博那种下拉不断分页的东西（一页一页的往下走），性能高。</p><h4 id="4-Set"><a href="#4-Set" class="headerlink" title="4.Set"></a>4.Set</h4><blockquote><p><strong>常用命令：</strong><br>sadd,spop,smembers,sunion 等</p></blockquote><p>set 对外提供的功能与list类似是一个列表的功能，特殊之处在于 set 是可以自动排重的。</p><p>当你需要存储一个列表数据，又不希望出现重复数据时，set是一个很好的选择，并且set提供了判断某个成员是否在一个set集合内的重要接口，这个也是list所不能提供的。可以基于 set 轻易实现交集、并集、差集的操作。</p><p>比如：在微博应用中，可以将一个用户所有的关注人存在一个集合中，将其所有粉丝存在一个集合。Redis可以非常方便的实现如共同关注、共同粉丝、共同喜好等功能。这个过程也就是求交集的过程，具体命令如下：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">sinterstore key1 key2 key3     将交集存在key1内</span><br></pre></td></tr></table></figure><h4 id="5-Sorted-Set"><a href="#5-Sorted-Set" class="headerlink" title="5.Sorted Set"></a>5.Sorted Set</h4><blockquote><p><strong>常用命令：</strong> zadd,zrange,zrem,zcard等</p></blockquote><p>和set相比，sorted set增加了一个权重参数score，使得集合中的元素能够按score进行有序排列。</p><p><strong>举例：</strong> 在直播系统中，实时排行信息包含直播间在线用户列表，各种礼物排行榜，弹幕消息（可以理解为按消息维度的消息排行榜）等信息，适合使用 Redis 中的 Sorted Set 结构进行存储。</p><h3 id="redis-设置过期时间"><a href="#redis-设置过期时间" class="headerlink" title="redis 设置过期时间"></a>redis 设置过期时间</h3><p>Redis中有个设置时间过期的功能，即对存储在 redis 数据库中的值可以设置一个过期时间。作为一个缓存数据库，这是非常实用的。如我们一般项目中的 token 或者一些登录信息，尤其是短信验证码都是有时间限制的，按照传统的数据库处理方式，一般都是自己判断过期，这样无疑会严重影响项目性能。</p><p>我们 set key 的时候，都可以给一个 expire time，就是过期时间，通过过期时间我们可以指定这个 key 可以存活的时间。</p><p>如果假设你设置了一批 key 只能存活1个小时，那么接下来1小时后，redis是怎么对这批key进行删除的？</p><p><strong>定期删除+惰性删除。</strong></p><p>通过名字大概就能猜出这两个删除方式的意思了。</p><ul><li><strong>定期删除</strong>：redis默认是每隔 100ms 就<strong>随机抽取</strong>一些设置了过期时间的key，检查其是否过期，如果过期就删除。注意这里是随机抽取的。为什么要随机呢？你想一想假如 redis 存了几十万个 key ，每隔100ms就遍历所有的设置过期时间的 key 的话，就会给 CPU 带来很大的负载！</li><li><strong>惰性删除</strong> ：定期删除可能会导致很多过期 key 到了时间并没有被删除掉。所以就有了惰性删除。假如你的过期 key，靠定期删除没有被删除掉，还停留在内存里，除非你的系统去查一下那个 key，才会被redis给删除掉。这就是所谓的惰性删除，也是够懒的哈！</li></ul><p>但是仅仅通过设置过期时间还是有问题的。我们想一下：如果定期删除漏掉了很多过期 key，然后你也没及时去查，也就没走惰性删除，此时会怎么样？如果大量过期key堆积在内存里，导致redis内存块耗尽了。怎么解决这个问题呢？ <strong>redis 内存淘汰机制。</strong></p><h3 id="redis-内存淘汰机制-MySQL里有2000w数据，Redis中只存20w的数据，如何保证Redis中的数据都是热点数据"><a href="#redis-内存淘汰机制-MySQL里有2000w数据，Redis中只存20w的数据，如何保证Redis中的数据都是热点数据" class="headerlink" title="redis 内存淘汰机制(MySQL里有2000w数据，Redis中只存20w的数据，如何保证Redis中的数据都是热点数据?)"></a>redis 内存淘汰机制(MySQL里有2000w数据，Redis中只存20w的数据，如何保证Redis中的数据都是热点数据?)</h3><p>redis 配置文件 redis.conf 中有相关注释，我这里就不贴了，大家可以自行查阅或者通过这个网址查看： <a href="http://download.redis.io/redis-stable/redis.conf" target="_blank" rel="noopener">http://download.redis.io/redis-stable/redis.conf</a></p><p><strong>redis 提供 6种数据淘汰策略：</strong></p><ol><li><strong>volatile-lru</strong>：从已设置过期时间的数据集（server.db[i].expires）中挑选最近最少使用的数据淘汰</li><li><strong>volatile-ttl</strong>：从已设置过期时间的数据集（server.db[i].expires）中挑选将要过期的数据淘汰</li><li><strong>volatile-random</strong>：从已设置过期时间的数据集（server.db[i].expires）中任意选择数据淘汰</li><li><strong>allkeys-lru</strong>：当内存不足以容纳新写入数据时，在键空间中，移除最近最少使用的key（这个是最常用的）</li><li><strong>allkeys-random</strong>：从数据集（server.db[i].dict）中任意选择数据淘汰</li><li><strong>no-eviction</strong>：禁止驱逐数据，也就是说当内存不足以容纳新写入数据时，新写入操作会报错。这个应该没人使用吧！</li></ol><p>4.0版本后增加以下两种：</p><ol start="7"><li><strong>volatile-lfu</strong>：从已设置过期时间的数据集(server.db[i].expires)中挑选最不经常使用的数据淘汰</li><li><strong>allkeys-lfu</strong>：当内存不足以容纳新写入数据时，在键空间中，移除最不经常使用的key</li></ol><p><strong>备注： 关于 redis 设置过期时间以及内存淘汰机制，我这里只是简单的总结一下，后面会专门写一篇文章来总结！</strong></p><h3 id="redis-持久化机制-怎么保证-redis-挂掉之后再重启数据可以进行恢复"><a href="#redis-持久化机制-怎么保证-redis-挂掉之后再重启数据可以进行恢复" class="headerlink" title="redis 持久化机制(怎么保证 redis 挂掉之后再重启数据可以进行恢复)"></a>redis 持久化机制(怎么保证 redis 挂掉之后再重启数据可以进行恢复)</h3><p>很多时候我们需要持久化数据也就是将内存中的数据写入到硬盘里面，大部分原因是为了之后重用数据（比如重启机器、机器故障之后恢复数据），或者是为了防止系统故障而将数据备份到一个远程位置。</p><p>Redis不同于Memcached的很重一点就是，Redis支持持久化，而且支持两种不同的持久化操作。<strong>Redis的一种持久化方式叫快照（snapshotting，RDB），另一种方式是只追加文件（append-only file,AOF）</strong>。这两种方法各有千秋，下面我会详细这两种持久化方法是什么，怎么用，如何选择适合自己的持久化方法。</p><p><strong>快照（snapshotting）持久化（RDB）</strong></p><p>Redis可以通过创建快照来获得存储在内存里面的数据在某个时间点上的副本。Redis创建快照之后，可以对快照进行备份，可以将快照复制到其他服务器从而创建具有相同数据的服务器副本（Redis主从结构，主要用来提高Redis性能），还可以将快照留在原地以便重启服务器的时候使用。</p><p>快照持久化是Redis默认采用的持久化方式，在redis.conf配置文件中默认有此下配置：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">save 900 1           #在900秒(15分钟)之后，如果至少有1个key发生变化，Redis就会自动触发BGSAVE命令创建快照。</span><br><span class="line"></span><br><span class="line">save 300 10          #在300秒(5分钟)之后，如果至少有10个key发生变化，Redis就会自动触发BGSAVE命令创建快照。</span><br><span class="line"></span><br><span class="line">save 60 10000        #在60秒(1分钟)之后，如果至少有10000个key发生变化，Redis就会自动触发BGSAVE命令创建快照。</span><br></pre></td></tr></table></figure><p><strong>AOF（append-only file）持久化</strong></p><p>与快照持久化相比，AOF持久化 的实时性更好，因此已成为主流的持久化方案。默认情况下Redis没有开启AOF（append only file）方式的持久化，可以通过appendonly参数开启：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">appendonly yes</span><br></pre></td></tr></table></figure><p>开启AOF持久化后每执行一条会更改Redis中的数据的命令，Redis就会将该命令写入硬盘中的AOF文件。AOF文件的保存位置和RDB文件的位置相同，都是通过dir参数设置的，默认的文件名是appendonly.aof。</p><p>在Redis的配置文件中存在三种不同的 AOF 持久化方式，它们分别是：</p><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">appendfsync always    #每次有数据修改发生时都会写入AOF文件,这样会严重降低Redis的速度</span><br><span class="line">appendfsync everysec  #每秒钟同步一次，显示地将多个写命令同步到硬盘</span><br><span class="line">appendfsync no        #让操作系统决定何时进行同步</span><br></pre></td></tr></table></figure><p>为了兼顾数据和写入性能，用户可以考虑 appendfsync everysec选项 ，让Redis每秒同步一次AOF文件，Redis性能几乎没受到任何影响。而且这样即使出现系统崩溃，用户最多只会丢失一秒之内产生的数据。当硬盘忙于执行写入操作的时候，Redis还会优雅的放慢自己的速度以便适应硬盘的最大写入速度。</p><p><strong>Redis 4.0 对于持久化机制的优化</strong></p><p>Redis 4.0 开始支持 RDB 和 AOF 的混合持久化（默认关闭，可以通过配置项 <code>aof-use-rdb-preamble</code> 开启）。</p><p>如果把混合持久化打开，AOF 重写的时候就直接把 RDB 的内容写到 AOF 文件开头。这样做的好处是可以结合 RDB 和 AOF 的优点, 快速加载同时避免丢失过多的数据。当然缺点也是有的， AOF 里面的 RDB 部分是压缩格式不再是 AOF 格式，可读性较差。</p><p><strong>补充内容：AOF 重写</strong></p><p>AOF重写可以产生一个新的AOF文件，这个新的AOF文件和原有的AOF文件所保存的数据库状态一样，但体积更小。</p><p>AOF重写是一个有歧义的名字，该功能是通过读取数据库中的键值对来实现的，程序无须对现有AOF文件进行任何读入、分析或者写入操作。</p><p>在执行 BGREWRITEAOF 命令时，Redis 服务器会维护一个 AOF 重写缓冲区，该缓冲区会在子进程创建新AOF文件期间，记录服务器执行的所有写命令。当子进程完成创建新AOF文件的工作之后，服务器会将重写缓冲区中的所有内容追加到新AOF文件的末尾，使得新旧两个AOF文件所保存的数据库状态一致。最后，服务器用新的AOF文件替换旧的AOF文件，以此来完成AOF文件重写操作</p><p><strong>更多内容可以查看我的这篇文章：</strong></p><ul><li><a href="Redis持久化.md">Redis持久化</a></li></ul><h3 id="redis-事务"><a href="#redis-事务" class="headerlink" title="redis 事务"></a>redis 事务</h3><p>Redis 通过 MULTI、EXEC、WATCH 等命令来实现事务(transaction)功能。事务提供了一种将多个命令请求打包，然后一次性、按顺序地执行多个命令的机制，并且在事务执行期间，服务器不会中断事务而改去执行其他客户端的命令请求，它会将事务中的所有命令都执行完毕，然后才去处理其他客户端的命令请求。</p><p>在传统的关系式数据库中，常常用 ACID 性质来检验事务功能的可靠性和安全性。在 Redis 中，事务总是具有原子性（Atomicity）、一致性（Consistency）和隔离性（Isolation），并且当 Redis 运行在某种特定的持久化模式下时，事务也具有持久性（Durability）。</p><h3 id="缓存雪崩和缓存穿透问题解决方案"><a href="#缓存雪崩和缓存穿透问题解决方案" class="headerlink" title="缓存雪崩和缓存穿透问题解决方案"></a>缓存雪崩和缓存穿透问题解决方案</h3><p><strong>缓存雪崩</strong> </p><p>简介：缓存同一时间大面积的失效，所以，后面的请求都会落到数据库上，造成数据库短时间内承受大量请求而崩掉。</p><p>解决办法（中华石杉老师在他的视频中提到过，视频地址在最后一个问题中有提到）：</p><ul><li>事前：尽量保证整个 redis 集群的高可用性，发现机器宕机尽快补上。选择合适的内存淘汰策略。</li><li>事中：本地ehcache缓存 + hystrix限流&amp;降级，避免MySQL崩掉</li><li>事后：利用 redis 持久化机制保存的数据尽快恢复缓存</li></ul><p><img src="http://my-blog-to-use.oss-cn-beijing.aliyuncs.com/18-9-25/6078367.jpg" alt></p><p><strong>缓存穿透</strong> </p><p>简介：一般是黑客故意去请求缓存中不存在的数据，导致所有的请求都落到数据库上，造成数据库短时间内承受大量请求而崩掉。</p><p>解决办法： 有很多种方法可以有效地解决缓存穿透问题，最常见的则是采用布隆过滤器，将所有可能存在的数据哈希到一个足够大的bitmap中，一个一定不存在的数据会被 这个bitmap拦截掉，从而避免了对底层存储系统的查询压力。另外也有一个更为简单粗暴的方法（我们采用的就是这种），如果一个查询返回的数据为空（不管是数 据不存在，还是系统故障），我们仍然把这个空结果进行缓存，但它的过期时间会很短，最长不超过五分钟。</p><p>参考：</p><ul><li><a href="https://blog.csdn.net/zeb_perfect/article/details/54135506" target="_blank" rel="noopener">https://blog.csdn.net/zeb_perfect/article/details/54135506</a></li></ul><h3 id="如何解决-Redis-的并发竞争-Key-问题"><a href="#如何解决-Redis-的并发竞争-Key-问题" class="headerlink" title="如何解决 Redis 的并发竞争 Key 问题"></a>如何解决 Redis 的并发竞争 Key 问题</h3><p>所谓 Redis 的并发竞争 Key 的问题也就是多个系统同时对一个 key 进行操作，但是最后执行的顺序和我们期望的顺序不同，这样也就导致了结果的不同！</p><p>推荐一种方案：分布式锁（zookeeper 和 redis 都可以实现分布式锁）。（如果不存在 Redis 的并发竞争 Key 问题，不要使用分布式锁，这样会影响性能）</p><p>基于zookeeper临时有序节点可以实现的分布式锁。大致思想为：每个客户端对某个方法加锁时，在zookeeper上的与该方法对应的指定节点的目录下，生成一个唯一的瞬时有序节点。 判断是否获取锁的方式很简单，只需要判断有序节点中序号最小的一个。 当释放锁的时候，只需将这个瞬时节点删除即可。同时，其可以避免服务宕机导致的锁无法释放，而产生的死锁问题。完成业务流程后，删除对应的子节点释放锁。</p><p>在实践中，当然是从以可靠性为主。所以首推Zookeeper。</p><p>参考：</p><ul><li><a href="https://www.jianshu.com/p/8bddd381de06" target="_blank" rel="noopener">https://www.jianshu.com/p/8bddd381de06</a></li></ul><h3 id="如何保证缓存与数据库双写时的数据一致性"><a href="#如何保证缓存与数据库双写时的数据一致性" class="headerlink" title="如何保证缓存与数据库双写时的数据一致性?"></a>如何保证缓存与数据库双写时的数据一致性?</h3><p>你只要用缓存，就可能会涉及到缓存与数据库双存储双写，你只要是双写，就一定会有数据一致性的问题，那么你如何解决一致性问题？</p><p>一般来说，就是如果你的系统不是严格要求缓存+数据库必须一致性的话，缓存可以稍微的跟数据库偶尔有不一致的情况，最好不要做这个方案，读请求和写请求串行化，串到一个内存队列里去，这样就可以保证一定不会出现不一致的情况</p><p>串行化之后，就会导致系统的吞吐量会大幅度的降低，用比正常情况下多几倍的机器去支撑线上的一个请求。</p>]]></content>
      
      
      <categories>
          
          <category> DB </category>
          
      </categories>
      
      
        <tags>
            
            <tag> redis </tag>
            
            <tag> SQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>事务及隔离级别</title>
      <link href="/2019/05/02/%E4%BA%8B%E5%8A%A1%E5%8F%8A%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/"/>
      <url>/2019/05/02/%E4%BA%8B%E5%8A%A1%E5%8F%8A%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<h1 id="事务"><a href="#事务" class="headerlink" title="事务"></a>事务</h1><hr><h2 id="简述"><a href="#简述" class="headerlink" title="简述"></a>简述</h2><p>事务是逻辑上的一组操作，要么都执行，要么都不执行。最简单的；例子如银行转账，双方一人账户增加多少钱，另一人账号就减少多少钱。</p><h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2><pre><code>1. 开启事务： start transaction;2. 回滚：rollback;3. 提交：commit;事务提交的方式：    1. 自动提交        MySQL的提交方式    2. 手动提交        Oracle的提交方式修改事务提交的方式    查看事务的默认提交方式：SELECT @@autocommit; -- 1 代表自动提交  0 代表手动提交    修改默认提交方式： set @@autocommit = 0;</code></pre><h2 id="事务的四个特征"><a href="#事务的四个特征" class="headerlink" title="事务的四个特征"></a>事务的四个特征</h2><ul><li>原子性：是不可分割的最小操作单位，要么同时成功，要么同时失败</li><li>持久性：当事务提交或回滚后，数据库会持久化的保存数据。</li><li>隔离性：多个事务之间。相互独立。</li><li>一致性：事务操作前后，数据总量不变</li></ul><h2 id="事务的隔离级别"><a href="#事务的隔离级别" class="headerlink" title="事务的隔离级别"></a>事务的隔离级别</h2><p>多个事务是相互隔离的、独立的，但多个事务处理同样一批数据时便会发生问题，这时就必须设置隔离级别来解决这些问题。</p><h3 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h3><ul><li>脏读(Dirty Read)：一个事务读取到另一个事务未提交的数据</li><li>不可重复读(虚读)(Unrepeatable Read)：同一个事务中，两次读取的数据不一样。在这个事务还没有结束时，另一个事务也访问该数据。那么，在第一个事务中的两次读数据之间，由于第二个事务的修改导致第一个事务两次读取的数据可能不太一样。</li><li>幻读(Phantom Read)：一个事务操作(DML)数据表中所有记录，另一个事务添加了一条数据，则第一个事务查询不到自己的修改。</li><li>有人也说还有第四种问题-丢失修改(Lost to modify)：指在一个事务读取一个数据时，另外一个事务也访问了该数据，那么在第一个事务中修改了这个数据后，第二个事务也修改了这个数据。这样第一个事务内的修改结果就被丢失，因此称为丢失修改。    例如：事务1读取某表中的数据A=20，事务2也读取A=20，事务1修改A=A-1，事务2也修改A=A-1，最终结果A=18，事务1的修改被丢失。</li></ul><p><strong>不可重复度和幻读区别</strong>：<br>不可重复读的重点是修改，幻读的重点在于新增或者删除。</p><h3 id="隔离级别"><a href="#隔离级别" class="headerlink" title="隔离级别"></a>隔离级别</h3><ul><li><strong>READ-UNCOMMITTED(读取未提交)：</strong> 最低的隔离级别，允许读取尚未提交的数据变更，<strong>可能会导致脏读、幻读或不可重复读</strong>。</li><li><strong>READ-COMMITTED(读取已提交)：</strong> 允许读取并发事务已经提交的数据，<strong>可以阻止脏读，但是幻读或不可重复读仍有可能发生</strong>。</li><li><strong>REPEATABLE-READ(可重复读)：</strong>  对同一字段的多次读取结果都是一致的，除非数据是被本身事务自己所修改，<strong>可以阻止脏读和不可重复读，但幻读仍有可能发生</strong>。</li><li><strong>SERIALIZABLE(可串行化)：</strong> 最高的隔离级别，完全服从ACID的隔离级别。所有的事务依次逐个执行，这样事务之间就完全不可能产生干扰，也就是说，<strong>该级别可以防止脏读、不可重复读以及幻读</strong>。</li></ul><p><strong>特点</strong>：安全等级越来越高，但效率越来越低。</p><pre><code>数据库查询隔离级别：    * select @@tx_isolation;数据库设置隔离级别：    * set global transaction isolation level  级别字符串;</code></pre><h3 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h3><p>在Github上的JavaGuide-master仓库中写到</p><blockquote><p>由 <a href="https://github.com/Snailclimb" target="_blank" rel="noopener">SnailClimb</a> 和 <a href="https://github.com/BugSpeak" target="_blank" rel="noopener">BugSpeak</a> 共同完成。</p></blockquote><pre><code>这里需要注意的是：与 SQL 标准不同的地方在于InnoDB 存储引擎在 **REPEATABLE-READ（可重读）**事务隔离级别下使用的是Next-Key Lock 锁算法，因此可以避免幻读的产生，这与其他数据库系统(如 SQL Server)是不同的。所以说InnoDB 存储引擎的默认支持的隔离级别是 **REPEATABLE-READ（可重读）** 已经可以完全保证事务的隔离性要求，即达到了 SQL标准的**SERIALIZABLE(可串行化)**隔离级别。因为隔离级别越低，事务请求的锁越少，所以大部分数据库系统的隔离级别都是**READ-COMMITTED(读取提交内容):**，但是你要知道的是InnoDB 存储引擎默认使用 **REPEATABLE-READ（可重读）**并不会有任何性能损失。InnoDB 存储引擎在 **分布式事务** 的情况下一般会用到**SERIALIZABLE(可串行化)**隔离级别。</code></pre>]]></content>
      
      
      <categories>
          
          <category> DB </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQL </tag>
            
            <tag> MySQL </tag>
            
            <tag> Oracle </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>String问题</title>
      <link href="/2019/04/16/String/"/>
      <url>/2019/04/16/String/</url>
      
        <content type="html"><![CDATA[<p>看到了一题自己不会的String面试题，想想面试官恶心啊，这里把String方面的面试题整理下吧</p><p><strong>持续更新</strong></p><hr><h2 id="记住"><a href="#记住" class="headerlink" title="记住"></a>记住</h2><h3 id="创建字符串方式的区别"><a href="#创建字符串方式的区别" class="headerlink" title="创建字符串方式的区别"></a>创建字符串方式的区别</h3><ul><li><p>常量式创建<br>如 String str1 = “helloworld”;</p><blockquote><p>JVM在实例化字符串时使用了<strong>字符串常量池</strong><br>每当我们创建字符串常量时，JVM会首先检查字符串常量池，如果该字符串已经存在常量池中，那么就直接返回常量池中的实例引用。如果字符串不存在常量池中，就会实例化该字符串并且将其放到常量池中。由于String字符串的不可变性我们可以十分肯定常量池中一定不存在两个相同的字符串。</p></blockquote></li><li><p>对象式创建<br>如 String str2 = new String(“helloworld”);</p><blockquote><p>不存储于字符串池，而是在堆内存中。我们可以调用intern()方法将该字符串对象存储在字符串池，如果字符串池已经有了同样值的字符串，则返回引用。</p></blockquote></li></ul><p>网上有张图片很容易理解<br><img src="https://i.loli.net/2019/07/14/5d2af0ed2279839556.png" alt></p><h3 id="intern-方法"><a href="#intern-方法" class="headerlink" title="intern()方法"></a>intern()方法</h3><p>当intern()方法被调用，如果字符串池中含有一个字符串和当前调用方法的字符串eqauls相等，那么就会返回池中的字符串。如果池中没有的话，则首先将当前字符串加入到池中，然后返回引用。</p><h2 id="案例"><a href="#案例" class="headerlink" title="案例"></a>案例</h2><h3 id="想法"><a href="#想法" class="headerlink" title="想法"></a>想法</h3><p>由于常量池中绝对不存在相同的字符串对象，普通比较就很简单了。<br>其他比较这时看是否 调用intern()方法了。</p><ol><li><p> String s1 = “abc”;<br> //abc存在字符串常量池中，s1地址指向abc常量池的首地址(指针)<br> String s2 = new String(“abc”);<br> //abc存在堆中，s2地址指向我们abc在堆中的首地址<br> String s3 = s2.intern();<br> //intern()作用节省内存的存储空间，会去常量池中的地址给s3,找不到就添加到池中，再返回地址给s3</p><p> System.out.println(s1==s2);<br> System.out.println(s2==s3);<br> System.out.println(s1==s3);</p></li></ol><blockquote><p>答案<br>false/false/true</p></blockquote><ol start="2"><li>下面的代码创建了几个字符串对象<br> String str1 = new String(“helloworld”);<br> String str2 = new String(“helloworld”);</li></ol><blockquote><p>3个对象<br>第一行，字符串池中的”helloworld”对象和堆内存中创建值为”helloworld”新字符串<br>第二行，堆内存中创建值为”helloworld”新字符串，这里字符串池中的”helloworld”重用了</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> JavaSE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> String </tag>
            
            <tag> interview </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Mybatis分页插件PageHelper的问题</title>
      <link href="/2019/04/08/Mybatis%E5%88%86%E9%A1%B5%E6%8F%92%E4%BB%B6PageHelper%E7%9A%84%E9%97%AE%E9%A2%98/"/>
      <url>/2019/04/08/Mybatis%E5%88%86%E9%A1%B5%E6%8F%92%E4%BB%B6PageHelper%E7%9A%84%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><p><font color="red">在使用Mybatis的第三方分页插件时，出现了下面的问题</font></p><pre><code>com.github.pagehelper.PageHelper cannot be cast to org.apache.ibatis.plugin.Interceptor</code></pre><p>具体如图</p><p><img src="https://i.loli.net/2019/06/08/5cfbae47865db77511.png" alt></p><p>附上代码</p><pre><code>&lt;!--引入分页助手--&gt;&lt;plugins&gt;    &lt;plugin interceptor=&quot;com.github.pagehelper.PageHelper&quot;&gt;        &lt;!--指定方言--&gt;        &lt;property name=&quot;dialect&quot; value=&quot;mysql&quot;/&gt;    &lt;/plugin&gt;&lt;/plugins&gt;</code></pre><p><font color="red">此出导入的jar包版本为5.1.2</font></p><p>关注报错信息发现，PageHelper无法转化为Interceptor,查阅信息，再打开源码查看的确有些端倪</p><p><img src="https://i.loli.net/2019/06/08/5cfbb0d6c41a131692.png" alt><br>有一个PageInterceptor实现了Interceptor接口，再将代码中的PageHelper改为PageInterceptor后，又出现了新问题</p><pre><code>Error parsing SQL Mapper Configuration. Cause: com.github.pagehelper.PageException: java.lang.ClassNotFoundException: mysql</code></pre><p><img src="https://i.loli.net/2019/06/08/5cfbb1773c2db17685.png" alt></p><p>查询信息后了解到，<font color="red">PageHelper插件4.0.0后的版本支持自动识别使用数据库，不用配置方言</font>，因此我将代码改为了如下</p><pre><code>&lt;plugins&gt;    &lt;plugin interceptor=&quot;com.github.pagehelper.PageInterceptor&quot;&gt;    &lt;/plugin&gt;&lt;/plugins&gt;</code></pre><p>程序正常运行！</p>]]></content>
      
      
      <categories>
          
          <category> 框架 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Mybatis </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>更换电脑或重装系统时的博客配置</title>
      <link href="/2019/03/30/%E5%8D%9A%E5%AE%A2%E9%87%8D%E9%85%8D%E7%BD%AE/"/>
      <url>/2019/03/30/%E5%8D%9A%E5%AE%A2%E9%87%8D%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>首先感谢网络上的大佬们，查阅了一些人的博客总算解决了这一难题。废话少说，下面是简单的教程。</p><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><ul><li>安装node.js</li><li>安装Git</li><li>备份你的本地博客目录的部分文件夹</li></ul><p><a href="http://jiguangwu.top/2018/01/10/hexo/#more" title="下载点此" target="_blank" rel="noopener">node.js和Git的安装包参考</a></p><p>拷贝文件夹如下</p><blockquote><p>_config.yml</p><p>theme/</p><p>source/</p><p>scaffolds/</p><p>package.json</p><p>.gitignore</p></blockquote><h2 id="配置你的Git"><a href="#配置你的Git" class="headerlink" title="配置你的Git"></a>配置你的Git</h2><p>桌面右键选择bash here,设置用户名称和邮件地址。</p><blockquote><p>1 $ git config –global user.name “username”</p><p>2 $ git config –global user.email “<a href="mailto:username@xxxx.com" target="_blank" rel="noopener">username@xxxx.com</a>“</p></blockquote><h2 id="配置SSH-Key"><a href="#配置SSH-Key" class="headerlink" title="配置SSH Key"></a>配置SSH Key</h2><p>输入</p><blockquote><p>$ ssh-keygen -t rsa -C “你的邮件地址”</p></blockquote><p>然后连续按三次回车，会生成id_rsa.pub文件，用记事本打开它，然后全部复制即可，待会要用。这个文件的地址：C:\Users\Administrator.ssh<br>打开你的GitHub主页，打开设置-&gt;Deploy keys-&gt;Add deploy key.<br>这里名称随便取，在下面粘贴内容保存即可。</p><p>我们回来测试下是否把SSH配置成功了。<br>继续在bash里输入</p><blockquote><p> $ ssh -T <a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a></p></blockquote><p>如果提示 Are you sure you want to continue connecting (yes/no)? ，输入yes，然后会看到 successfully authenticated,but github…..<br>看到这个意味着已成功！</p><h2 id="正式工作"><a href="#正式工作" class="headerlink" title="正式工作"></a>正式工作</h2><p>接下来时hexo和一些组件的安装，恭喜了很快了。</p><h1 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h1><p>我们打开cmd命令行，输入</p><blockquote><p>npm install -g hexo</p></blockquote><p>这里可能会很慢，所以推荐使用淘宝镜像。</p><blockquote><p>npm install -g cnpm –registry=<a href="https://registry.npm.taobao.org" target="_blank" rel="noopener">https://registry.npm.taobao.org</a></p></blockquote><p>验证是否安装成功使用：</p><blockquote><p>cnpm -v</p></blockquote><p>安装了淘宝镜像后，都使用cnpm指令：</p><blockquote><p>cnpm install -g hexo   // 安装 hexo</p></blockquote><p>验证Hexo是否安装成功使用：</p><blockquote><p>hexo -v</p></blockquote><h1 id="安装一些组件"><a href="#安装一些组件" class="headerlink" title="安装一些组件"></a>安装一些组件</h1><blockquote><p> npm install hexo-deployer-git –save  // 文章部署到 git 的模块（下面为选择安装）</p><p> npm install hexo-generator-feed –save  // 建立 RSS 订阅</p><p> npm install hexo-generator-sitemap –save // 建立站点地图</p></blockquote><h1 id="部署到Github"><a href="#部署到Github" class="headerlink" title="部署到Github"></a>部署到Github</h1><p>输入指令</p><blockquote><p>hexo generate</p><p>hexo deploy</p></blockquote><p>没有报错就OK了。<br>这里讲讲hexo的一些快捷命令</p><blockquote><p>hexo g == hexo generate</p><p>hexo d == hexo deploy</p><p>hexo s == hexo server</p><p>hexo n == hexo new</p></blockquote><h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><p>尝试部署文章并使用以下指令更新部署</p><blockquote><p>hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</p></blockquote><p>成功部署，恭喜你！博客重配置成功！</p><p>如果觉得有用，不如给个<a href="https://github.com/JiGuangwuu/JiGuangwuu.github.io" target="_blank" rel="noopener">Star Or Follow</a>，感谢。</p>]]></content>
      
      
      <categories>
          
          <category> 技术栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> blog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单例模式</title>
      <link href="/2019/03/26/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
      <url>/2019/03/26/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="理解"><a href="#理解" class="headerlink" title="理解"></a>理解</h1><p>设计模式（Design pattern）代表了最佳的实践，通常被有经验的面向对象的软件开发人员所采用。设计模式是软件开发人员在软件开发过程中面临的一般问题的解决方案。这些解决方案是众多软件开发人员经过相当长的一段时间的试验和错误总结出来的。</p><h1 id="何为单例模式"><a href="#何为单例模式" class="headerlink" title="何为单例模式"></a>何为单例模式</h1><p>单例模式(Singleton)，又称单态模式或者单件模式。即保证一个类仅有一个实例，并提供一个访问它的全局访问点。<br>目的是即控制特定的类只产生一个对象，也允许在一定情况下灵活的改变对象的个数。</p><h1 id="如何实现"><a href="#如何实现" class="headerlink" title="如何实现"></a>如何实现</h1><p>先看一段代码</p><pre><code>public class Thing {    private Thing(){    }    private static  Thing instance = new Thing();    //这段代码保证了Thread safe    public static Thing getInstance(){        return instance;    ｝｝    </code></pre><p>测试类</p><pre><code>public class TestDemo {    public static void main(String[] args) {        Thing t1 = Thing.getInstance();        Thing t2 = Thing.getInstance();        System.out.println(t1);        System.out.println(t2);    }}</code></pre><p>输出t1和t2的结果是一致的。<br>可以发现，我们将构造方法私有化了，这使得外面的类无法通过引用来创建对象；同时为了保证类的可用性，就必须提供一个自己的对象以及访问这个对象的静态方法。<br>因此，我们应该明白：<br>单例模式只有一个角色，而客户通过调用类的方法来创建对象。</p><p><img src="https://i.loli.net/2019/04/08/5cab563abef10.png" alt="单例原理"></p><h1 id="还有什么"><a href="#还有什么" class="headerlink" title="还有什么"></a>还有什么</h1><p>在上面的Thing类中我们“迫不及待”的创建了对象，但如果这个对象我们很长时间都没有使用就浪费了内存空间，因此称之为<strong>饿汉式</strong>。存在另一种写法，即<strong>懒汉式</strong>。<br>看这段代码</p><pre><code>private static Thing instance;public static Thing getInstance(){                    if (instance==null){               instance = new Thing();            }            return instance;}</code></pre><p>很明显，当程序真正需要这个对象的时候我们才开始创建。但是这在多线程情况下是有问题的，为了防止多线程环境中产生多个实例，我们做出改进，使用同步处理。</p><pre><code>private static Thing instance;public static Thing getInstance(){     //如果是对象还没创建的时候使用同步，如果对象已经创建完了，就不要同步了  ，这样效率就可以提高    if (instance==null){        synchronized (Thing.class){            if (instance==null){            //说明对象还没创建，所以里面使用了同步s               instance = new Thing();            }        }    }    return instance;}</code></pre><p>这里我们使用的是同步代码块，为什么不要同步方法呢？</p><pre><code> private static Thing instance;public synchronized static Thing getInstance(){    if (instance==null){        instance = new Thing();    }    return instance;}</code></pre><p>通过使用同步方法，迫使每个线程在进入这个方法前要等候别的进程离开该方法。但同步会降低性能，并且这里只有第一次执行该方法时才会正在需要同步。之后每一次调用这个方法，同步都是浪费的。</p><h1 id="存在的问题"><a href="#存在的问题" class="headerlink" title="存在的问题"></a>存在的问题</h1><p>在学习单例模式时，通过这方面的书籍了解到以下问题</p><p><img src="https://i.loli.net/2019/04/08/5cab564492dd7.png" alt></p><p>如果觉得有用，不如给个<a href="https://github.com/JiGuangwuu/JiGuangwuu.github.io" target="_blank" rel="noopener">Star Or Follow</a>，感谢。</p><p>​    </p>]]></content>
      
      
      <categories>
          
          <category> 设计模式和数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> interview </tag>
            
            <tag> designPattern </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于我的考研</title>
      <link href="/2019/02/20/190405/"/>
      <url>/2019/02/20/190405/</url>
      
        <content type="html"><![CDATA[<p><img src="https://i.loli.net/2019/07/14/5d2b4a9ed4a1888918.jpg" alt="2018"></p><h2 id="不去可惜了"><a href="#不去可惜了" class="headerlink" title="不去可惜了"></a>不去可惜了</h2><h2 id="一般般的去干啥"><a href="#一般般的去干啥" class="headerlink" title="一般般的去干啥"></a>一般般的去干啥</h2><h2 id="差点？人生就是这样"><a href="#差点？人生就是这样" class="headerlink" title="差点？人生就是这样"></a>差点？人生就是这样</h2><h1 id="不去"><a href="#不去" class="headerlink" title="不去"></a>不去</h1>]]></content>
      
      
      <categories>
          
          <category> 逆旅 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mood </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>如何将本地项目部署到Github</title>
      <link href="/2019/02/05/%E9%83%A8%E7%BD%B2%E9%A1%B9%E7%9B%AE%E5%88%B0github/"/>
      <url>/2019/02/05/%E9%83%A8%E7%BD%B2%E9%A1%B9%E7%9B%AE%E5%88%B0github/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>众所周知，GitHub是一个面向开源及私有软件项目的托管平台，那我们该如何将本地项目导入到Github上呢，这里，我写一个简单的教程，希望对你有所帮助。</p><h2 id="准备"><a href="#准备" class="headerlink" title="准备"></a>准备</h2><p>确定你的Git安装了，如果需要<a href="http://jiguangwu.top/2018/01/10/hexo/#more" title="下载参考" target="_blank" rel="noopener">点击此处</a></p><h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><p>首先在Github上新建一个repository，命名随意（以我为例，新建了一个Demo），勾选如图，create。</p><p><img src="https://i.loli.net/2019/03/26/5c9a1697490d0.png" alt="1"></p><p>然后，进入你的repository,打开settings，可以看到Github Pages的设置，在source中选择master branch。</p><p><img src="https://i.loli.net/2019/03/26/5c9a16d480146.png" alt="2"></p><p>最后，选择完会刷新页面，在去看Gith Pages时，会有显示一个网址，这就是你之后访问你项目页面的网址。<br><img src="https://i.loli.net/2019/03/26/5c9a16df8e603.png" alt="3"></p><h2 id="快了"><a href="#快了" class="headerlink" title="快了"></a>快了</h2><p>在一个盘里右键点击git bash here，打开bash命令行。如图，输入命令在D盘创建了文件夹Demo，第三个命令是克隆地址，格式为</p><blockquote><p><a href="https://github.com/用户名/项目名.git" target="_blank" rel="noopener">https://github.com/用户名/项目名.git</a></p></blockquote><p><img src="https://i.loli.net/2019/03/26/5c9a16eab9cd1.png" alt="4"></p><p>这时候你会发现你的D盘会多个Demo文件夹，打开它，进入根目录。</p><p>将自己的项目文件粘贴到这个根目录中。</p><p><img src="https://i.loli.net/2019/03/26/5c9a16eca4230.png" alt="5"></p><p><img src="https://i.loli.net/2019/03/26/5c9a16eebd4f2.png" alt="6"></p><p>执行如下命令，</p><p><img src="https://i.loli.net/2019/03/26/5c9a171336786.png" alt="7"></p><p>这里面注意，第一次操作需要你输入相关账号和密码，到时根据提示输入即可<br><img src="https://i.loli.net/2019/03/26/5c9a171e9432f.png" alt="8"></p><p><img src="https://i.loli.net/2019/03/26/5c9a1723ac514.png" alt="9"></p><h2 id="完成"><a href="#完成" class="headerlink" title="完成"></a>完成</h2><p>利用那个网址测试即可。</p><p>如果觉得有用，不如给个<a href="https://github.com/JiGuangwuu/JiGuangwuu.github.io" target="_blank" rel="noopener">starorfollow</a>，感谢。</p>]]></content>
      
      
      <categories>
          
          <category> 技术栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> blog </tag>
            
            <tag> github </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>乐观锁和悲观锁是什么</title>
      <link href="/2018/12/27/%E4%B9%90%E8%A7%82%E6%82%B2%E8%A7%82%E9%94%81/"/>
      <url>/2018/12/27/%E4%B9%90%E8%A7%82%E6%82%B2%E8%A7%82%E9%94%81/</url>
      
        <content type="html"><![CDATA[<h2 id="乐观锁"><a href="#乐观锁" class="headerlink" title="乐观锁"></a>乐观锁</h2><p>简单来说，总是假设最好的情况，每次去拿数据的时候都认为别人不会修改。</p><p>所以每次获取数据的时候都不会进行加锁，但是在更新数据的时候需要判断该数据是否被别人修改过。如果数据被其他线程修改，则不进行数据更新，如果数据没有被其他线程修改，则进行数据更新。由于数据没有进行加锁，期间该数据可以被其他线程进行读写操作。</p><h3 id="操作方式"><a href="#操作方式" class="headerlink" title="操作方式"></a>操作方式</h3><p>version方式和CAS操作方式。</p><h4 id="version方式"><a href="#version方式" class="headerlink" title="version方式"></a>version方式</h4><p>一般是在数据表中加上一个数据版本号version字段，表示数据被修改的次数，当数据被修改时，version值会加1。当线程A要更新数据值时，在读取数据的同时也会读取version值，在提交更新时，若刚才读取到的version值为当前数据库中的version值相等时才更新，否则重试更新操作，直到更新成功。<br>例如</p><pre><code>update table set x=x+1, version=version+1 where     id=#{id} and version=#{version};</code></pre><h4 id="CAS方式"><a href="#CAS方式" class="headerlink" title="CAS方式"></a>CAS方式</h4><p>即compare and swap（比较与交换），是一种有名的无锁算法。无锁编程，即不使用锁的情况下实现多线程之间的变量同步，也就是在没有线程被阻塞的情况下实现变量的同步，所以也叫非阻塞同步（Non-blocking Synchronization）。</p><p>CAS算法涉及到三个操作数：需要读写的内存值，进行比较的值，拟写入的新值</p><p>当需要更新时，判断当前内存值与之前取到的值是否相等，若相等，则用新值更新，若失败则重试。<br>一般情况下是一个自旋操作，即不断的重试。</p><h2 id="悲观锁"><a href="#悲观锁" class="headerlink" title="悲观锁"></a>悲观锁</h2><p>总是假设最坏的情况，每次去拿数据的时候都认为别人会修改</p><p>所以每次获取数据的时候都会进行加锁，确保在自己使用的过程中数据不会被别人修改，使用完成后进行数据解锁。由于数据进行加锁，期间对该数据进行读写的其他线程都会进行等待。</p><p>在Java中，<strong>synchronized</strong>的思想也是悲观锁。</p><h2 id="应用场景比较"><a href="#应用场景比较" class="headerlink" title="应用场景比较"></a>应用场景比较</h2><p>很清楚一点的是反复加锁多于读操作多的业务太傻了，因此</p><ul><li><strong>乐观锁适合读操作频繁的场景</strong>，如果出现大量的写入操作，数据发生冲突的可能性就会增大，为了保证数据的一致性，应用层需要不断的重新获取数据，这样会增加大量的查询操作，降低了系统的吞吐量。</li><li><strong>悲观锁适合写操作频繁的场景</strong>，如果出现大量的读取操作，每次读取的时候都会进行加锁，这样会增加大量的锁的开销，降低了系统的吞吐量。</li></ul><p>over</p>]]></content>
      
      
      <categories>
          
          <category> DB </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQL </tag>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>eclipse的maven插件安装</title>
      <link href="/2018/09/07/eclipse%E6%8F%92%E4%BB%B6maven/"/>
      <url>/2018/09/07/eclipse%E6%8F%92%E4%BB%B6maven/</url>
      
        <content type="html"><![CDATA[<p>以eclipse kepler为例，<br>官网下载地址：<a href="http://www.eclipse.org/downloads/packages/release/Kepler/SR2" target="_blank" rel="noopener">http://www.eclipse.org/downloads/packages/release/Kepler/SR2</a></p><p>1.打开eclipse，help–install new software…</p><p>2.workwith里输入：<a href="http://download.eclipse.org/releases/kepler，输入完会有提示地址出现，点击回车静待" target="_blank" rel="noopener">http://download.eclipse.org/releases/kepler，输入完会有提示地址出现，点击回车静待</a>…</p><p>3.在filter框中输入maven便能定位要安装的插件<br><img src="https://i.imgur.com/vyBFPux.png" alt></p><p>4.选择“Collaboration”-“m2e - Maven Integration for Eclipse”，并点击next按钮进行安装</p><p>5.安装完成重启eclipse即可</p><p>6.配置你的maven</p><p>如果觉得有用，不如给个<a href="https://github.com/JiGuangwuu/JiGuangwuu.github.io" target="_blank" rel="noopener">Star Or Follow</a>，感谢。</p>]]></content>
      
      
      <categories>
          
          <category> JavaWeb </category>
          
      </categories>
      
      
        <tags>
            
            <tag> maven </tag>
            
            <tag> eclipse </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Tomcat问题和项目部署</title>
      <link href="/2018/08/09/tomcat%E9%85%8D%E7%BD%AE/"/>
      <url>/2018/08/09/tomcat%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="Tomcat可能出现的问题"><a href="#Tomcat可能出现的问题" class="headerlink" title="Tomcat可能出现的问题"></a>Tomcat可能出现的问题</h1><hr><pre><code>1. 黑窗口一闪而过：    * 原因： 没有正确配置JAVA_HOME环境变量    * 解决方案：正确配置JAVA_HOME环境变量，并在path中添加%JAVA_HOME%\bin;2. 启动报错：    1. 暴力修改：找到占用的端口号，并且找到对应的进程，杀死该进程        * 命令行输入netstat -ano，查询到端口豪对应进程的PID    2. 温柔修改：修改自身的端口号        * conf/server.xml        * &lt;Connector port=&quot;8888&quot; protocol=&quot;HTTP/1.1&quot;           connectionTimeout=&quot;20000&quot;           redirectPort=&quot;8445&quot; /&gt;        * 一般会将tomcat的默认端口号修改为80。80端口号是http协议的默认端口号。            * 好处：在访问时，就不用输入端口号</code></pre><h1 id="在Tomcat中部署项目的方式"><a href="#在Tomcat中部署项目的方式" class="headerlink" title="在Tomcat中部署项目的方式"></a>在Tomcat中部署项目的方式</h1><hr><pre><code>1. 直接将项目放到webapps目录下即可。    * /WebProject：项目的访问路径--&gt;虚拟目录    * 简化部署：将项目打成一个war包，再将war包放置到webapps目录下。        * war包会自动解压缩2. 配置conf/server.xml文件    在&lt;Host&gt;标签体中配置    &lt;Context docBase=&quot;D:\WebProject&quot; path=&quot;/demo&quot; /&gt;    * docBase:项目存放的路径    * path：虚拟目录3. 在conf\Catalina\localhost创建任意名称的xml文件。在文件中编写    &lt;Context docBase=&quot;D:\WebProject&quot; /&gt;    * 虚拟目录：xml文件的名称4. 在IDE中</code></pre>]]></content>
      
      
      <categories>
          
          <category> JavaWeb </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Tomcat </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>初识主键，索引，视图</title>
      <link href="/2018/07/14/%E4%B8%BB%E9%94%AE%E7%B4%A2%E5%BC%95%E8%A7%86%E5%9B%BE%E5%88%9D%E8%AF%86/"/>
      <url>/2018/07/14/%E4%B8%BB%E9%94%AE%E7%B4%A2%E5%BC%95%E8%A7%86%E5%9B%BE%E5%88%9D%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<h2 id="主键"><a href="#主键" class="headerlink" title="主键"></a>主键</h2><p>主键即主键约束。<br>MySQL主键约束是一个列或者列的集合，其值能唯一地标识表中的每一行。这样的一列或多列称为表的主键</p><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><ul><li>保证实体的完整性</li><li>加快数据库的操作速度</li><li>在表中添加新记录时，DB会自动检查新记录的主键值，不允许该值与其他记录的主键值重复</li><li>DB自动按主键值的顺序显示表中的记录。如果没有定义主键，则按输入的顺序显示</li></ul><h3 id="性质"><a href="#性质" class="headerlink" title="性质"></a>性质</h3><p>主键创建后自带一个唯一性索引</p><blockquote><p>与唯一索引区别</p></blockquote><ul><li>唯一索引不一定是主键</li><li>唯一性索引允许空值，主键不允许</li><li>一个表只能建一个主键，可以创建多个唯一索引</li><li>主键可以被其他表引用为外键，唯一索引不行</li></ul><h3 id="设置主键的注意"><a href="#设置主键的注意" class="headerlink" title="设置主键的注意"></a>设置主键的注意</h3><p>主键约束即在表中定义一个主键来唯一确定表中每一行数据的标识符。主键可以是表中的某一列或者多列的组合，其中由多列组合的主键称为复合主键。主键应该遵守下面的规则：</p><ul><li><p>每个表只能定义一个主键。<br>主键值必须唯一标识表中的每一行，且不能为 NULL，即表中不可能存在两行数据有相同的主键值。这是唯一性原则</p></li><li><p>一个列名只能在复合主键列表中出现一次。</p></li></ul><ul><li>复合主键不能包含不必要的多余列。当把复合主键的某一列删除后，如果剩下的列构成的主键仍然满足唯一性原则，那么这个复合主键是不正确的。这是最小化原则。</li></ul><h2 id="索引"><a href="#索引" class="headerlink" title="索引"></a>索引</h2><p>索引是对数据库表中一列或多列的值进行排序的一种结构，使用索引可快速访问数据库表中的特定信息</p><h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><p>索引用于快速查找具有特定列值的行。如果没有索引，MySQL必须从第一行开始，然后读取整个表以查找相关行。表越大，成本越高。如果表中有相关​​列的索引，MySQL可以快速确定要在数据文件中间寻找的位置，而无需查看所有数据。这比按顺序读取每一行要快得多。</p><p>大多数MySQL索引（PRIMARY KEY， UNIQUE，INDEX和 FULLTEXT）存储在 B树。例外：空间数据类型的索引使用R树; MEMORY 表也​​支持哈希索引 ; InnoDB使用反向列表作为FULLTEXT索引。</p><p>详细见<a href="https://dev.mysql.com/doc/refman/5.7/en/mysql-indexes.html" target="_blank" rel="noopener">官方文档中索引内容</a></p><p>关于索引，还会有其他博文和转载详细介绍</p><h2 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h2><p>视图是一个虚拟表，其内容由查询定义。同真实表一样，视图包含一系列带有名称的列和行数据，但视图并不是数据库真实存储的数据表。</p><p>视图是从一个、多个表或者视图中导出的表，包含一系列带有名称的数据列和若干条数据行。</p><h3 id="视图与数据表的区别"><a href="#视图与数据表的区别" class="headerlink" title="视图与数据表的区别"></a>视图与数据表的区别</h3><ul><li>视图不是数据库中真实的表，而是一张虚拟表，其结构和数据是建立在对数据中真实表的查询基础上的。</li><li>存储在数据库中的查询操作 SQL 语句定义了视图的内容，列数据和行数据来自于视图查询所引用的实际表，引用视图时动态生成这些数据。</li><li>视图没有实际的物理记录，不是以数据集的形式存储在数据库中的，它所对应的数据实际上是存储在视图所引用的真实表中的。</li><li>视图是数据的窗口，而表是内容。表是实际数据的存放单位，而视图只是以不同的显示方式展示数据，其数据来源还是实际表。</li><li>视图是查看数据表的一种方法，可以查询数据表中某些字段构成的数据，只是一些 SQL 语句的集合。从安全的角度来看，视图的数据安全性更高，使用视图的用户不接触数据表，不知道表结构。</li><li>视图的建立和删除只影响视图本身，不影响对应的基本表。</li></ul><p><strong>视图与表在本质上虽然不相同，但视图经过定义以后，结构形式和表一样，可以进行查询、修改、更新和删除等操作。</strong></p><h3 id="视图注意项"><a href="#视图注意项" class="headerlink" title="视图注意项"></a>视图注意项</h3><ul><li>创建视图需要足够的访问权限。</li><li>创建视图的数目没有限制。</li><li>视图可以嵌套，即从其他视图中检索数据的查询来创建视图。</li><li>视图不能索引，也不能有关联的触发器、默认值或规则。</li><li>视图可以和表一起使用。</li><li>视图不包含数据，所以每次使用视图时，都必须执行查询中所需的任何一个检索操作。如果用多个连接和过滤条件创建了复杂的视图或嵌套了视图，可能会发现系统运行性能下降得十分严重。因此，在部署大量视图应用时，应该进行系统测试。</li></ul>]]></content>
      
      
      <categories>
          
          <category> DB </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQL </tag>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>servlet域对象</title>
      <link href="/2018/07/05/servlet%E5%9F%9F%E5%AF%B9%E8%B1%A1/"/>
      <url>/2018/07/05/servlet%E5%9F%9F%E5%AF%B9%E8%B1%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="引言"><a href="#引言" class="headerlink" title="引言"></a>引言</h1><p>在学习servlet的过程中，数据共享是必须的操作。总的来说，我们要想共享数据往往是利用<font color="pink" size="3"><strong>多个servlet或对象共同操作的一个对象</strong></font>，这类对象称之为<font color="pink" size="3"><strong>作用域</strong></font>。</p><h2 id="HttpServletRequest"><a href="#HttpServletRequest" class="headerlink" title="HttpServletRequest"></a>HttpServletRequest</h2><p>针对<font color="red" size="3"><strong>一次请求</strong></font>。<br>使用该对象保存数据，一次请求(一个页面，如果是请求转发多个页面)内有效。</p><ul><li>创建：客户端想服务器端发送一次请求</li><li>销毁：服务器响应后销毁</li></ul><h2 id="HttpServletSession"><a href="#HttpServletSession" class="headerlink" title="HttpServletSession"></a>HttpServletSession</h2><p>针对<font color="red" size="3"><strong>一次会话</strong></font>。<br>使用该对象保存数据，一次会话(多次请求)有效。</p><ul><li>创建：请求未携带jsessionid时创建session对象，请求携带jsessionid但找不到对应的session时创建session对象。</li><li>销毁：<pre><code>1. 未正常关闭服务器2. 手动调用了Session的invalidate方法3. session过期了，有效时间默认为30分钟</code></pre></li></ul><h2 id="HttpServletContext"><a href="#HttpServletContext" class="headerlink" title="HttpServletContext"></a>HttpServletContext</h2><p>针对<font color="red" size="3"><strong>一个web应用</strong></font>。<br>一个web应用只有一个ServletContext对象，该对象保存的数据对整个web应用都有效。我们可以把ServletContext与其他对象描绘成水和鱼类的关系。</p><ul><li>创建：服务器启动的时候</li><li>销毁：服务器关闭的时候或者项目移除</li></ul><h3 id="三个作用域对象操作的API"><a href="#三个作用域对象操作的API" class="headerlink" title="三个作用域对象操作的API"></a>三个作用域对象操作的API</h3><p>api都是一样的,完成存取和销毁的操作</p><ul><li>存放数据：setAttribute(name,value)</li><li>获得数据：getAttribute(name)</li><li>删除数据：removeAttribute(name)</li></ul><h1 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h1><p>servlet为我们提供的三大域对象来帮助我们实现不同情况下的数据共享,<font color="blue" size="3"><strong>若一个业务功能使用这三个域对象都可以实现,我们一般选用最小的域对象</strong></font>.作用域越小,生命周期越短,在一定程度上可以提供程序的执行效率</p>]]></content>
      
      
      <categories>
          
          <category> JavaWeb </category>
          
      </categories>
      
      
        <tags>
            
            <tag> servlet </tag>
            
            <tag> request </tag>
            
            <tag> session </tag>
            
            <tag> ServletContext </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>构造、静态代码块面试题</title>
      <link href="/2018/06/05/%E6%9E%84%E9%80%A0%E9%9D%99%E6%80%81%E4%BB%A3%E7%A0%81%E5%9D%97/"/>
      <url>/2018/06/05/%E6%9E%84%E9%80%A0%E9%9D%99%E6%80%81%E4%BB%A3%E7%A0%81%E5%9D%97/</url>
      
        <content type="html"><![CDATA[<h1 id="复习"><a href="#复习" class="headerlink" title="复习"></a>复习</h1><p>构造代码块的执行时机：每次我们调用构造方法的时候都会先执行构造代码块中的代码，然后才去执行对应的构造方法中的代码。</p><p>静态代码块的执行时机：静态代码块其实就是在类加载的时候执行，一个类只会加载一次，所以静态代码块也最多只会执行一次。</p><pre><code>public class Test01 {    {        System.out.println(&quot;Test01的构造代码块&quot;);    }    static {        System.out.println(&quot;Test01的静态代码块&quot;);    }    public Test01() {        System.out.println(&quot;Test01的构造方法&quot;);    }    public static void main(String[] args) {        Student stu = new Student();        Student stu2 = new Student();    }}class Student {    {        System.out.println(&quot;Student的构造代码块&quot;);    }    static {        System.out.println(&quot;Student的静态代码块&quot;);    }    public Student() {        System.out.println(&quot;Student的构造方法&quot;);    }}</code></pre><p>答案：Test01的静态代码块 Student的静态代码块 Student的构造代码块<br>Student的构造方法  Student的构造代码块  Student的构造方法</p><p>如果觉得有用，不如给个<a href="https://github.com/JiGuangwuu/JiGuangwuu.github.io" target="_blank" rel="noopener">Star Or Follow</a>，感谢。</p>]]></content>
      
      
      <categories>
          
          <category> JavaSE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> interview </tag>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>${pageContext.request.contextPath}与web.xml问题</title>
      <link href="/2018/06/01/web_xml%E5%A4%B4%E9%97%AE%E9%A2%98/"/>
      <url>/2018/06/01/web_xml%E5%A4%B4%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<p>在使用idea中的maven-webapp骨架创建web项目时，我的web.xml文件头默认为</p><pre><code>&lt;!DOCTYPE web-app PUBLIC        &quot;-//Sun Microsystems, Inc.//DTD Web Application 2.3//EN&quot;        &quot;http://java.sun.com/dtd/web-app_2_3.dtd&quot; &gt;&lt;web-app&gt;</code></pre><p>之初，配置Spring前端控制器，全局参数…等等，<webapp>标签报红，但这并不影响项目的正常运行，因此也没换成</webapp></p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot;?&gt;&lt;web-app xmlns=&quot;http://java.sun.com/xml/ns/j2ee&quot;         xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;         xsi:schemaLocation=&quot;http://java.sun.com/xml/ns/j2ee http://java.sun.com/xml/ns/j2ee/web-app_2_4.xsd&quot;         version=&quot;2.4&quot;&gt;</code></pre><p>但是，在处理SpringMVC请求去获取集合类型参数时，使用了${pageContext.request.contextPath} 表达式，比如下面</p><pre><code>&lt;script src=&quot;${pageContext.request.contextPath}/js/jquery-3.3.1.js&quot;&gt;&lt;/script&gt;    &lt;script&gt;        var userList = new Array();        userList.push({name:&quot;zhangsan&quot;,age:23});        userList.push({name:&quot;lisi&quot;,age:25});        $.ajax({            type:&quot;post&quot;,            url:&quot;${pageContext.request.contextPath}/user/success9&quot;,            data:JSON.stringify(userList),            contentType:&quot;application/json;charset=utf-8&quot;        });    &lt;/script&gt;</code></pre><p>报错如下</p><p><img src="https://i.loli.net/2019/06/01/5cf264ea37c8462438.png" alt></p><p>？？？难道使我js路径写的有问题？仔细检查并没有，此时idea控制台并没有报错详细信息。</p><p>再打开f12</p><p><img src="https://i.loli.net/2019/06/01/5cf264f4dce5d41472.png" alt></p><p>再把xml文件头改成上面那个，就好了…这里的version应该在2.4以上，因此在使用${pageContext.request.contextPath}表达式时，web.xml的头应该注意版本</p>]]></content>
      
      
      <categories>
          
          <category> JavaWeb </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Spring </tag>
            
            <tag> xml </tag>
            
            <tag> SpringMVC </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>一千行MySQL命令(转载)</title>
      <link href="/2018/05/20/%E4%B8%80%E5%8D%83%E8%A1%8CMySQL%E5%91%BD%E4%BB%A4(%E8%BD%AC%E8%BD%BD)/"/>
      <url>/2018/05/20/%E4%B8%80%E5%8D%83%E8%A1%8CMySQL%E5%91%BD%E4%BB%A4(%E8%BD%AC%E8%BD%BD)/</url>
      
        <content type="html"><![CDATA[<blockquote><p>原文地址：<a href="https://shockerli.net/post/1000-line-mysql-note/" target="_blank" rel="noopener">https://shockerli.net/post/1000-line-mysql-note/</a> ，JavaGuide 对本文进行了简答排版，新增了目录。<br>作者：格物<br>转载自：<a href="https://github.com/Snailclimb/JavaGuide" target="_blank" rel="noopener">https://github.com/Snailclimb/JavaGuide</a></p></blockquote><p>非常不错的总结，强烈建议保存下来，需要的时候看一看。</p><!-- TOC --><ul><li><a href="#基本操作">基本操作</a></li><li><a href="#数据库操作">数据库操作</a></li><li><a href="#表的操作">表的操作</a></li><li><a href="#数据操作">数据操作</a></li><li><a href="#字符集编码">字符集编码</a></li><li><a href="#数据类型列类型">数据类型(列类型)</a></li><li><a href="#列属性列约束">列属性(列约束)</a></li><li><a href="#建表规范">建表规范</a></li><li><a href="#select">SELECT</a></li><li><a href="#union">UNION</a></li><li><a href="#子查询">子查询</a></li><li><a href="#连接查询join">连接查询(join)</a></li><li><a href="#truncate">TRUNCATE</a></li><li><a href="#备份与还原">备份与还原</a></li><li><a href="#视图">视图</a></li><li><a href="#事务transaction">事务(transaction)</a></li><li><a href="#锁表">锁表</a></li><li><a href="#触发器">触发器</a></li><li><a href="#sql编程">SQL编程</a></li><li><a href="#存储过程">存储过程</a></li><li><a href="#用户和权限管理">用户和权限管理</a></li><li><a href="#表维护">表维护</a></li><li><a href="#杂项">杂项</a></li></ul><!-- /TOC --><h3 id="基本操作"><a href="#基本操作" class="headerlink" title="基本操作"></a>基本操作</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/* Windows服务 */</span><br><span class="line">-- 启动MySQL</span><br><span class="line">    net start mysql</span><br><span class="line">-- 创建Windows服务</span><br><span class="line">    sc create mysql binPath= mysqld_bin_path(注意：等号与值之间有空格)</span><br><span class="line">/* 连接与断开服务器 */</span><br><span class="line">mysql -h 地址 -P 端口 -u 用户名 -p 密码</span><br><span class="line">SHOW PROCESSLIST -- 显示哪些线程正在运行</span><br><span class="line">SHOW VARIABLES -- 显示系统变量信息</span><br></pre></td></tr></table></figure><h3 id="数据库操作"><a href="#数据库操作" class="headerlink" title="数据库操作"></a>数据库操作</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/* 数据库操作 */ ------------------</span><br><span class="line">-- 查看当前数据库</span><br><span class="line">    SELECT DATABASE();</span><br><span class="line">-- 显示当前时间、用户名、数据库版本</span><br><span class="line">    SELECT now(), user(), version();</span><br><span class="line">-- 创建库</span><br><span class="line">    CREATE DATABASE[ IF NOT EXISTS] 数据库名 数据库选项</span><br><span class="line">    数据库选项：</span><br><span class="line">        CHARACTER SET charset_name</span><br><span class="line">        COLLATE collation_name</span><br><span class="line">-- 查看已有库</span><br><span class="line">    SHOW DATABASES[ LIKE &apos;PATTERN&apos;]</span><br><span class="line">-- 查看当前库信息</span><br><span class="line">    SHOW CREATE DATABASE 数据库名</span><br><span class="line">-- 修改库的选项信息</span><br><span class="line">    ALTER DATABASE 库名 选项信息</span><br><span class="line">-- 删除库</span><br><span class="line">    DROP DATABASE[ IF EXISTS] 数据库名</span><br><span class="line">        同时删除该数据库相关的目录及其目录内容</span><br></pre></td></tr></table></figure><h3 id="表的操作"><a href="#表的操作" class="headerlink" title="表的操作"></a>表的操作</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">-- 创建表</span><br><span class="line">    CREATE [TEMPORARY] TABLE[ IF NOT EXISTS] [库名.]表名 ( 表的结构定义 )[ 表选项]</span><br><span class="line">        每个字段必须有数据类型</span><br><span class="line">        最后一个字段后不能有逗号</span><br><span class="line">        TEMPORARY 临时表，会话结束时表自动消失</span><br><span class="line">        对于字段的定义：</span><br><span class="line">            字段名 数据类型 [NOT NULL | NULL] [DEFAULT default_value] [AUTO_INCREMENT] [UNIQUE [KEY] | [PRIMARY] KEY] [COMMENT &apos;string&apos;]</span><br><span class="line">-- 表选项</span><br><span class="line">    -- 字符集</span><br><span class="line">        CHARSET = charset_name</span><br><span class="line">        如果表没有设定，则使用数据库字符集</span><br><span class="line">    -- 存储引擎</span><br><span class="line">        ENGINE = engine_name</span><br><span class="line">        表在管理数据时采用的不同的数据结构，结构不同会导致处理方式、提供的特性操作等不同</span><br><span class="line">        常见的引擎：InnoDB MyISAM Memory/Heap BDB Merge Example CSV MaxDB Archive</span><br><span class="line">        不同的引擎在保存表的结构和数据时采用不同的方式</span><br><span class="line">        MyISAM表文件含义：.frm表定义，.MYD表数据，.MYI表索引</span><br><span class="line">        InnoDB表文件含义：.frm表定义，表空间数据和日志文件</span><br><span class="line">        SHOW ENGINES -- 显示存储引擎的状态信息</span><br><span class="line">        SHOW ENGINE 引擎名 &#123;LOGS|STATUS&#125; -- 显示存储引擎的日志或状态信息</span><br><span class="line">    -- 自增起始数</span><br><span class="line">    AUTO_INCREMENT = 行数</span><br><span class="line">    -- 数据文件目录</span><br><span class="line">        DATA DIRECTORY = &apos;目录&apos;</span><br><span class="line">    -- 索引文件目录</span><br><span class="line">        INDEX DIRECTORY = &apos;目录&apos;</span><br><span class="line">    -- 表注释</span><br><span class="line">        COMMENT = &apos;string&apos;</span><br><span class="line">    -- 分区选项</span><br><span class="line">        PARTITION BY ... (详细见手册)</span><br><span class="line">-- 查看所有表</span><br><span class="line">    SHOW TABLES[ LIKE &apos;pattern&apos;]</span><br><span class="line">    SHOW TABLES FROM  库名</span><br><span class="line">-- 查看表机构</span><br><span class="line">    SHOW CREATE TABLE 表名 （信息更详细）</span><br><span class="line">    DESC 表名 / DESCRIBE 表名 / EXPLAIN 表名 / SHOW COLUMNS FROM 表名 [LIKE &apos;PATTERN&apos;]</span><br><span class="line">    SHOW TABLE STATUS [FROM db_name] [LIKE &apos;pattern&apos;]</span><br><span class="line">-- 修改表</span><br><span class="line">    -- 修改表本身的选项</span><br><span class="line">        ALTER TABLE 表名 表的选项</span><br><span class="line">        eg: ALTER TABLE 表名 ENGINE=MYISAM;</span><br><span class="line">    -- 对表进行重命名</span><br><span class="line">        RENAME TABLE 原表名 TO 新表名</span><br><span class="line">        RENAME TABLE 原表名 TO 库名.表名 （可将表移动到另一个数据库）</span><br><span class="line">        -- RENAME可以交换两个表名</span><br><span class="line">    -- 修改表的字段机构（13.1.2. ALTER TABLE语法）</span><br><span class="line">        ALTER TABLE 表名 操作名</span><br><span class="line">        -- 操作名</span><br><span class="line">            ADD[ COLUMN] 字段定义       -- 增加字段</span><br><span class="line">                AFTER 字段名          -- 表示增加在该字段名后面</span><br><span class="line">                FIRST               -- 表示增加在第一个</span><br><span class="line">            ADD PRIMARY KEY(字段名)   -- 创建主键</span><br><span class="line">            ADD UNIQUE [索引名] (字段名)-- 创建唯一索引</span><br><span class="line">            ADD INDEX [索引名] (字段名) -- 创建普通索引</span><br><span class="line">            DROP[ COLUMN] 字段名      -- 删除字段</span><br><span class="line">            MODIFY[ COLUMN] 字段名 字段属性     -- 支持对字段属性进行修改，不能修改字段名(所有原有属性也需写上)</span><br><span class="line">            CHANGE[ COLUMN] 原字段名 新字段名 字段属性      -- 支持对字段名修改</span><br><span class="line">            DROP PRIMARY KEY    -- 删除主键(删除主键前需删除其AUTO_INCREMENT属性)</span><br><span class="line">            DROP INDEX 索引名 -- 删除索引</span><br><span class="line">            DROP FOREIGN KEY 外键    -- 删除外键</span><br><span class="line">-- 删除表</span><br><span class="line">    DROP TABLE[ IF EXISTS] 表名 ...</span><br><span class="line">-- 清空表数据</span><br><span class="line">    TRUNCATE [TABLE] 表名</span><br><span class="line">-- 复制表结构</span><br><span class="line">    CREATE TABLE 表名 LIKE 要复制的表名</span><br><span class="line">-- 复制表结构和数据</span><br><span class="line">    CREATE TABLE 表名 [AS] SELECT * FROM 要复制的表名</span><br><span class="line">-- 检查表是否有错误</span><br><span class="line">    CHECK TABLE tbl_name [, tbl_name] ... [option] ...</span><br><span class="line">-- 优化表</span><br><span class="line">    OPTIMIZE [LOCAL | NO_WRITE_TO_BINLOG] TABLE tbl_name [, tbl_name] ...</span><br><span class="line">-- 修复表</span><br><span class="line">    REPAIR [LOCAL | NO_WRITE_TO_BINLOG] TABLE tbl_name [, tbl_name] ... [QUICK] [EXTENDED] [USE_FRM]</span><br><span class="line">-- 分析表</span><br><span class="line">    ANALYZE [LOCAL | NO_WRITE_TO_BINLOG] TABLE tbl_name [, tbl_name] ...</span><br></pre></td></tr></table></figure><h3 id="数据操作"><a href="#数据操作" class="headerlink" title="数据操作"></a>数据操作</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/* 数据操作 */ ------------------</span><br><span class="line">-- 增</span><br><span class="line">    INSERT [INTO] 表名 [(字段列表)] VALUES (值列表)[, (值列表), ...]</span><br><span class="line">        -- 如果要插入的值列表包含所有字段并且顺序一致，则可以省略字段列表。</span><br><span class="line">        -- 可同时插入多条数据记录！</span><br><span class="line">        REPLACE 与 INSERT 完全一样，可互换。</span><br><span class="line">    INSERT [INTO] 表名 SET 字段名=值[, 字段名=值, ...]</span><br><span class="line">-- 查</span><br><span class="line">    SELECT 字段列表 FROM 表名[ 其他子句]</span><br><span class="line">        -- 可来自多个表的多个字段</span><br><span class="line">        -- 其他子句可以不使用</span><br><span class="line">        -- 字段列表可以用*代替，表示所有字段</span><br><span class="line">-- 删</span><br><span class="line">    DELETE FROM 表名[ 删除条件子句]</span><br><span class="line">        没有条件子句，则会删除全部</span><br><span class="line">-- 改</span><br><span class="line">    UPDATE 表名 SET 字段名=新值[, 字段名=新值] [更新条件]</span><br></pre></td></tr></table></figure><h3 id="字符集编码"><a href="#字符集编码" class="headerlink" title="字符集编码"></a>字符集编码</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/* 字符集编码 */ ------------------</span><br><span class="line">-- MySQL、数据库、表、字段均可设置编码</span><br><span class="line">-- 数据编码与客户端编码不需一致</span><br><span class="line">SHOW VARIABLES LIKE &apos;character_set_%&apos;   -- 查看所有字符集编码项</span><br><span class="line">    character_set_client        客户端向服务器发送数据时使用的编码</span><br><span class="line">    character_set_results       服务器端将结果返回给客户端所使用的编码</span><br><span class="line">    character_set_connection    连接层编码</span><br><span class="line">SET 变量名 = 变量值</span><br><span class="line">    SET character_set_client = gbk;</span><br><span class="line">    SET character_set_results = gbk;</span><br><span class="line">    SET character_set_connection = gbk;</span><br><span class="line">SET NAMES GBK;  -- 相当于完成以上三个设置</span><br><span class="line">-- 校对集</span><br><span class="line">    校对集用以排序</span><br><span class="line">    SHOW CHARACTER SET [LIKE &apos;pattern&apos;]/SHOW CHARSET [LIKE &apos;pattern&apos;]   查看所有字符集</span><br><span class="line">    SHOW COLLATION [LIKE &apos;pattern&apos;]     查看所有校对集</span><br><span class="line">    CHARSET 字符集编码     设置字符集编码</span><br><span class="line">    COLLATE 校对集编码     设置校对集编码</span><br></pre></td></tr></table></figure><h3 id="数据类型-列类型"><a href="#数据类型-列类型" class="headerlink" title="数据类型(列类型)"></a>数据类型(列类型)</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/* 数据类型（列类型） */ ------------------</span><br><span class="line">1. 数值类型</span><br><span class="line">-- a. 整型 ----------</span><br><span class="line">    类型         字节     范围（有符号位）</span><br><span class="line">    tinyint     1字节    -128 ~ 127      无符号位：0 ~ 255</span><br><span class="line">    smallint    2字节    -32768 ~ 32767</span><br><span class="line">    mediumint   3字节    -8388608 ~ 8388607</span><br><span class="line">    int         4字节</span><br><span class="line">    bigint      8字节</span><br><span class="line">    int(M)  M表示总位数</span><br><span class="line">    - 默认存在符号位，unsigned 属性修改</span><br><span class="line">    - 显示宽度，如果某个数不够定义字段时设置的位数，则前面以0补填，zerofill 属性修改</span><br><span class="line">        例：int(5)   插入一个数&apos;123&apos;，补填后为&apos;00123&apos;</span><br><span class="line">    - 在满足要求的情况下，越小越好。</span><br><span class="line">    - 1表示bool值真，0表示bool值假。MySQL没有布尔类型，通过整型0和1表示。常用tinyint(1)表示布尔型。</span><br><span class="line">-- b. 浮点型 ----------</span><br><span class="line">    类型             字节     范围</span><br><span class="line">    float(单精度)     4字节</span><br><span class="line">    double(双精度)    8字节</span><br><span class="line">    浮点型既支持符号位 unsigned 属性，也支持显示宽度 zerofill 属性。</span><br><span class="line">        不同于整型，前后均会补填0.</span><br><span class="line">    定义浮点型时，需指定总位数和小数位数。</span><br><span class="line">        float(M, D)     double(M, D)</span><br><span class="line">        M表示总位数，D表示小数位数。</span><br><span class="line">        M和D的大小会决定浮点数的范围。不同于整型的固定范围。</span><br><span class="line">        M既表示总位数（不包括小数点和正负号），也表示显示宽度（所有显示符号均包括）。</span><br><span class="line">        支持科学计数法表示。</span><br><span class="line">        浮点数表示近似值。</span><br><span class="line">-- c. 定点数 ----------</span><br><span class="line">    decimal -- 可变长度</span><br><span class="line">    decimal(M, D)   M也表示总位数，D表示小数位数。</span><br><span class="line">    保存一个精确的数值，不会发生数据的改变，不同于浮点数的四舍五入。</span><br><span class="line">    将浮点数转换为字符串来保存，每9位数字保存为4个字节。</span><br><span class="line">2. 字符串类型</span><br><span class="line">-- a. char, varchar ----------</span><br><span class="line">    char    定长字符串，速度快，但浪费空间</span><br><span class="line">    varchar 变长字符串，速度慢，但节省空间</span><br><span class="line">    M表示能存储的最大长度，此长度是字符数，非字节数。</span><br><span class="line">    不同的编码，所占用的空间不同。</span><br><span class="line">    char,最多255个字符，与编码无关。</span><br><span class="line">    varchar,最多65535字符，与编码有关。</span><br><span class="line">    一条有效记录最大不能超过65535个字节。</span><br><span class="line">        utf8 最大为21844个字符，gbk 最大为32766个字符，latin1 最大为65532个字符</span><br><span class="line">    varchar 是变长的，需要利用存储空间保存 varchar 的长度，如果数据小于255个字节，则采用一个字节来保存长度，反之需要两个字节来保存。</span><br><span class="line">    varchar 的最大有效长度由最大行大小和使用的字符集确定。</span><br><span class="line">    最大有效长度是65532字节，因为在varchar存字符串时，第一个字节是空的，不存在任何数据，然后还需两个字节来存放字符串的长度，所以有效长度是64432-1-2=65532字节。</span><br><span class="line">    例：若一个表定义为 CREATE TABLE tb(c1 int, c2 char(30), c3 varchar(N)) charset=utf8; 问N的最大值是多少？ 答：(65535-1-2-4-30*3)/3</span><br><span class="line">-- b. blob, text ----------</span><br><span class="line">    blob 二进制字符串（字节字符串）</span><br><span class="line">        tinyblob, blob, mediumblob, longblob</span><br><span class="line">    text 非二进制字符串（字符字符串）</span><br><span class="line">        tinytext, text, mediumtext, longtext</span><br><span class="line">    text 在定义时，不需要定义长度，也不会计算总长度。</span><br><span class="line">    text 类型在定义时，不可给default值</span><br><span class="line">-- c. binary, varbinary ----------</span><br><span class="line">    类似于char和varchar，用于保存二进制字符串，也就是保存字节字符串而非字符字符串。</span><br><span class="line">    char, varchar, text 对应 binary, varbinary, blob.</span><br><span class="line">3. 日期时间类型</span><br><span class="line">    一般用整型保存时间戳，因为PHP可以很方便的将时间戳进行格式化。</span><br><span class="line">    datetime    8字节    日期及时间     1000-01-01 00:00:00 到 9999-12-31 23:59:59</span><br><span class="line">    date        3字节    日期         1000-01-01 到 9999-12-31</span><br><span class="line">    timestamp   4字节    时间戳        19700101000000 到 2038-01-19 03:14:07</span><br><span class="line">    time        3字节    时间         -838:59:59 到 838:59:59</span><br><span class="line">    year        1字节    年份         1901 - 2155</span><br><span class="line">datetime    YYYY-MM-DD hh:mm:ss</span><br><span class="line">timestamp   YY-MM-DD hh:mm:ss</span><br><span class="line">            YYYYMMDDhhmmss</span><br><span class="line">            YYMMDDhhmmss</span><br><span class="line">            YYYYMMDDhhmmss</span><br><span class="line">            YYMMDDhhmmss</span><br><span class="line">date        YYYY-MM-DD</span><br><span class="line">            YY-MM-DD</span><br><span class="line">            YYYYMMDD</span><br><span class="line">            YYMMDD</span><br><span class="line">            YYYYMMDD</span><br><span class="line">            YYMMDD</span><br><span class="line">time        hh:mm:ss</span><br><span class="line">            hhmmss</span><br><span class="line">            hhmmss</span><br><span class="line">year        YYYY</span><br><span class="line">            YY</span><br><span class="line">            YYYY</span><br><span class="line">            YY</span><br><span class="line">4. 枚举和集合</span><br><span class="line">-- 枚举(enum) ----------</span><br><span class="line">enum(val1, val2, val3...)</span><br><span class="line">    在已知的值中进行单选。最大数量为65535.</span><br><span class="line">    枚举值在保存时，以2个字节的整型(smallint)保存。每个枚举值，按保存的位置顺序，从1开始逐一递增。</span><br><span class="line">    表现为字符串类型，存储却是整型。</span><br><span class="line">    NULL值的索引是NULL。</span><br><span class="line">    空字符串错误值的索引值是0。</span><br><span class="line">-- 集合（set） ----------</span><br><span class="line">set(val1, val2, val3...)</span><br><span class="line">    create table tab ( gender set(&apos;男&apos;, &apos;女&apos;, &apos;无&apos;) );</span><br><span class="line">    insert into tab values (&apos;男, 女&apos;);</span><br><span class="line">    最多可以有64个不同的成员。以bigint存储，共8个字节。采取位运算的形式。</span><br><span class="line">    当创建表时，SET成员值的尾部空格将自动被删除。</span><br></pre></td></tr></table></figure><h3 id="列属性-列约束"><a href="#列属性-列约束" class="headerlink" title="列属性(列约束)"></a>列属性(列约束)</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/* 列属性（列约束） */ ------------------</span><br><span class="line">1. PRIMARY 主键</span><br><span class="line">    - 能唯一标识记录的字段，可以作为主键。</span><br><span class="line">    - 一个表只能有一个主键。</span><br><span class="line">    - 主键具有唯一性。</span><br><span class="line">    - 声明字段时，用 primary key 标识。</span><br><span class="line">        也可以在字段列表之后声明</span><br><span class="line">            例：create table tab ( id int, stu varchar(10), primary key (id));</span><br><span class="line">    - 主键字段的值不能为null。</span><br><span class="line">    - 主键可以由多个字段共同组成。此时需要在字段列表后声明的方法。</span><br><span class="line">        例：create table tab ( id int, stu varchar(10), age int, primary key (stu, age));</span><br><span class="line">2. UNIQUE 唯一索引（唯一约束）</span><br><span class="line">    使得某字段的值也不能重复。</span><br><span class="line">3. NULL 约束</span><br><span class="line">    null不是数据类型，是列的一个属性。</span><br><span class="line">    表示当前列是否可以为null，表示什么都没有。</span><br><span class="line">    null, 允许为空。默认。</span><br><span class="line">    not null, 不允许为空。</span><br><span class="line">    insert into tab values (null, &apos;val&apos;);</span><br><span class="line">        -- 此时表示将第一个字段的值设为null, 取决于该字段是否允许为null</span><br><span class="line">4. DEFAULT 默认值属性</span><br><span class="line">    当前字段的默认值。</span><br><span class="line">    insert into tab values (default, &apos;val&apos;);    -- 此时表示强制使用默认值。</span><br><span class="line">    create table tab ( add_time timestamp default current_timestamp );</span><br><span class="line">        -- 表示将当前时间的时间戳设为默认值。</span><br><span class="line">        current_date, current_time</span><br><span class="line">5. AUTO_INCREMENT 自动增长约束</span><br><span class="line">    自动增长必须为索引（主键或unique）</span><br><span class="line">    只能存在一个字段为自动增长。</span><br><span class="line">    默认为1开始自动增长。可以通过表属性 auto_increment = x进行设置，或 alter table tbl auto_increment = x;</span><br><span class="line">6. COMMENT 注释</span><br><span class="line">    例：create table tab ( id int ) comment &apos;注释内容&apos;;</span><br><span class="line">7. FOREIGN KEY 外键约束</span><br><span class="line">    用于限制主表与从表数据完整性。</span><br><span class="line">    alter table t1 add constraint `t1_t2_fk` foreign key (t1_id) references t2(id);</span><br><span class="line">        -- 将表t1的t1_id外键关联到表t2的id字段。</span><br><span class="line">        -- 每个外键都有一个名字，可以通过 constraint 指定</span><br><span class="line">    存在外键的表，称之为从表（子表），外键指向的表，称之为主表（父表）。</span><br><span class="line">    作用：保持数据一致性，完整性，主要目的是控制存储在外键表（从表）中的数据。</span><br><span class="line">    MySQL中，可以对InnoDB引擎使用外键约束：</span><br><span class="line">    语法：</span><br><span class="line">    foreign key (外键字段） references 主表名 (关联字段) [主表记录删除时的动作] [主表记录更新时的动作]</span><br><span class="line">    此时需要检测一个从表的外键需要约束为主表的已存在的值。外键在没有关联的情况下，可以设置为null.前提是该外键列，没有not null。</span><br><span class="line">    可以不指定主表记录更改或更新时的动作，那么此时主表的操作被拒绝。</span><br><span class="line">    如果指定了 on update 或 on delete：在删除或更新时，有如下几个操作可以选择：</span><br><span class="line">    1. cascade，级联操作。主表数据被更新（主键值更新），从表也被更新（外键值更新）。主表记录被删除，从表相关记录也被删除。</span><br><span class="line">    2. set null，设置为null。主表数据被更新（主键值更新），从表的外键被设置为null。主表记录被删除，从表相关记录外键被设置成null。但注意，要求该外键列，没有not null属性约束。</span><br><span class="line">    3. restrict，拒绝父表删除和更新。</span><br><span class="line">    注意，外键只被InnoDB存储引擎所支持。其他引擎是不支持的。</span><br></pre></td></tr></table></figure><h3 id="建表规范"><a href="#建表规范" class="headerlink" title="建表规范"></a>建表规范</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/* 建表规范 */ ------------------</span><br><span class="line">    -- Normal Format, NF</span><br><span class="line">        - 每个表保存一个实体信息</span><br><span class="line">        - 每个具有一个ID字段作为主键</span><br><span class="line">        - ID主键 + 原子表</span><br><span class="line">    -- 1NF, 第一范式</span><br><span class="line">        字段不能再分，就满足第一范式。</span><br><span class="line">    -- 2NF, 第二范式</span><br><span class="line">        满足第一范式的前提下，不能出现部分依赖。</span><br><span class="line">        消除符合主键就可以避免部分依赖。增加单列关键字。</span><br><span class="line">    -- 3NF, 第三范式</span><br><span class="line">        满足第二范式的前提下，不能出现传递依赖。</span><br><span class="line">        某个字段依赖于主键，而有其他字段依赖于该字段。这就是传递依赖。</span><br><span class="line">        将一个实体信息的数据放在一个表内实现。</span><br></pre></td></tr></table></figure><h3 id="SELECT"><a href="#SELECT" class="headerlink" title="SELECT"></a>SELECT</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/* SELECT */ ------------------</span><br><span class="line">SELECT [ALL|DISTINCT] select_expr FROM -&gt; WHERE -&gt; GROUP BY [合计函数] -&gt; HAVING -&gt; ORDER BY -&gt; LIMIT</span><br><span class="line">a. select_expr</span><br><span class="line">    -- 可以用 * 表示所有字段。</span><br><span class="line">        select * from tb;</span><br><span class="line">    -- 可以使用表达式（计算公式、函数调用、字段也是个表达式）</span><br><span class="line">        select stu, 29+25, now() from tb;</span><br><span class="line">    -- 可以为每个列使用别名。适用于简化列标识，避免多个列标识符重复。</span><br><span class="line">        - 使用 as 关键字，也可省略 as.</span><br><span class="line">        select stu+10 as add10 from tb;</span><br><span class="line">b. FROM 子句</span><br><span class="line">    用于标识查询来源。</span><br><span class="line">    -- 可以为表起别名。使用as关键字。</span><br><span class="line">        SELECT * FROM tb1 AS tt, tb2 AS bb;</span><br><span class="line">    -- from子句后，可以同时出现多个表。</span><br><span class="line">        -- 多个表会横向叠加到一起，而数据会形成一个笛卡尔积。</span><br><span class="line">        SELECT * FROM tb1, tb2;</span><br><span class="line">    -- 向优化符提示如何选择索引</span><br><span class="line">        USE INDEX、IGNORE INDEX、FORCE INDEX</span><br><span class="line">        SELECT * FROM table1 USE INDEX (key1,key2) WHERE key1=1 AND key2=2 AND key3=3;</span><br><span class="line">        SELECT * FROM table1 IGNORE INDEX (key3) WHERE key1=1 AND key2=2 AND key3=3;</span><br><span class="line">c. WHERE 子句</span><br><span class="line">    -- 从from获得的数据源中进行筛选。</span><br><span class="line">    -- 整型1表示真，0表示假。</span><br><span class="line">    -- 表达式由运算符和运算数组成。</span><br><span class="line">        -- 运算数：变量（字段）、值、函数返回值</span><br><span class="line">        -- 运算符：</span><br><span class="line">            =, &lt;=&gt;, &lt;&gt;, !=, &lt;=, &lt;, &gt;=, &gt;, !, &amp;&amp;, ||,</span><br><span class="line">            in (not) null, (not) like, (not) in, (not) between and, is (not), and, or, not, xor</span><br><span class="line">            is/is not 加上ture/false/unknown，检验某个值的真假</span><br><span class="line">            &lt;=&gt;与&lt;&gt;功能相同，&lt;=&gt;可用于null比较</span><br><span class="line">d. GROUP BY 子句, 分组子句</span><br><span class="line">    GROUP BY 字段/别名 [排序方式]</span><br><span class="line">    分组后会进行排序。升序：ASC，降序：DESC</span><br><span class="line">    以下[合计函数]需配合 GROUP BY 使用：</span><br><span class="line">    count 返回不同的非NULL值数目  count(*)、count(字段)</span><br><span class="line">    sum 求和</span><br><span class="line">    max 求最大值</span><br><span class="line">    min 求最小值</span><br><span class="line">    avg 求平均值</span><br><span class="line">    group_concat 返回带有来自一个组的连接的非NULL值的字符串结果。组内字符串连接。</span><br><span class="line">e. HAVING 子句，条件子句</span><br><span class="line">    与 where 功能、用法相同，执行时机不同。</span><br><span class="line">    where 在开始时执行检测数据，对原数据进行过滤。</span><br><span class="line">    having 对筛选出的结果再次进行过滤。</span><br><span class="line">    having 字段必须是查询出来的，where 字段必须是数据表存在的。</span><br><span class="line">    where 不可以使用字段的别名，having 可以。因为执行WHERE代码时，可能尚未确定列值。</span><br><span class="line">    where 不可以使用合计函数。一般需用合计函数才会用 having</span><br><span class="line">    SQL标准要求HAVING必须引用GROUP BY子句中的列或用于合计函数中的列。</span><br><span class="line">f. ORDER BY 子句，排序子句</span><br><span class="line">    order by 排序字段/别名 排序方式 [,排序字段/别名 排序方式]...</span><br><span class="line">    升序：ASC，降序：DESC</span><br><span class="line">    支持多个字段的排序。</span><br><span class="line">g. LIMIT 子句，限制结果数量子句</span><br><span class="line">    仅对处理好的结果进行数量限制。将处理好的结果的看作是一个集合，按照记录出现的顺序，索引从0开始。</span><br><span class="line">    limit 起始位置, 获取条数</span><br><span class="line">    省略第一个参数，表示从索引0开始。limit 获取条数</span><br><span class="line">h. DISTINCT, ALL 选项</span><br><span class="line">    distinct 去除重复记录</span><br><span class="line">    默认为 all, 全部记录</span><br></pre></td></tr></table></figure><h3 id="UNION"><a href="#UNION" class="headerlink" title="UNION"></a>UNION</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/* UNION */ ------------------</span><br><span class="line">    将多个select查询的结果组合成一个结果集合。</span><br><span class="line">    SELECT ... UNION [ALL|DISTINCT] SELECT ...</span><br><span class="line">    默认 DISTINCT 方式，即所有返回的行都是唯一的</span><br><span class="line">    建议，对每个SELECT查询加上小括号包裹。</span><br><span class="line">    ORDER BY 排序时，需加上 LIMIT 进行结合。</span><br><span class="line">    需要各select查询的字段数量一样。</span><br><span class="line">    每个select查询的字段列表(数量、类型)应一致，因为结果中的字段名以第一条select语句为准。</span><br></pre></td></tr></table></figure><h3 id="子查询"><a href="#子查询" class="headerlink" title="子查询"></a>子查询</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/* 子查询 */ ------------------</span><br><span class="line">    - 子查询需用括号包裹。</span><br><span class="line">-- from型</span><br><span class="line">    from后要求是一个表，必须给子查询结果取个别名。</span><br><span class="line">    - 简化每个查询内的条件。</span><br><span class="line">    - from型需将结果生成一个临时表格，可用以原表的锁定的释放。</span><br><span class="line">    - 子查询返回一个表，表型子查询。</span><br><span class="line">    select * from (select * from tb where id&gt;0) as subfrom where id&gt;1;</span><br><span class="line">-- where型</span><br><span class="line">    - 子查询返回一个值，标量子查询。</span><br><span class="line">    - 不需要给子查询取别名。</span><br><span class="line">    - where子查询内的表，不能直接用以更新。</span><br><span class="line">    select * from tb where money = (select max(money) from tb);</span><br><span class="line">    -- 列子查询</span><br><span class="line">        如果子查询结果返回的是一列。</span><br><span class="line">        使用 in 或 not in 完成查询</span><br><span class="line">        exists 和 not exists 条件</span><br><span class="line">            如果子查询返回数据，则返回1或0。常用于判断条件。</span><br><span class="line">            select column1 from t1 where exists (select * from t2);</span><br><span class="line">    -- 行子查询</span><br><span class="line">        查询条件是一个行。</span><br><span class="line">        select * from t1 where (id, gender) in (select id, gender from t2);</span><br><span class="line">        行构造符：(col1, col2, ...) 或 ROW(col1, col2, ...)</span><br><span class="line">        行构造符通常用于与对能返回两个或两个以上列的子查询进行比较。</span><br><span class="line">    -- 特殊运算符</span><br><span class="line">    != all()    相当于 not in</span><br><span class="line">    = some()    相当于 in。any 是 some 的别名</span><br><span class="line">    != some()   不等同于 not in，不等于其中某一个。</span><br><span class="line">    all, some 可以配合其他运算符一起使用。</span><br></pre></td></tr></table></figure><h3 id="连接查询-join"><a href="#连接查询-join" class="headerlink" title="连接查询(join)"></a>连接查询(join)</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/* 连接查询(join) */ ------------------</span><br><span class="line">    将多个表的字段进行连接，可以指定连接条件。</span><br><span class="line">-- 内连接(inner join)</span><br><span class="line">    - 默认就是内连接，可省略inner。</span><br><span class="line">    - 只有数据存在时才能发送连接。即连接结果不能出现空行。</span><br><span class="line">    on 表示连接条件。其条件表达式与where类似。也可以省略条件（表示条件永远为真）</span><br><span class="line">    也可用where表示连接条件。</span><br><span class="line">    还有 using, 但需字段名相同。 using(字段名)</span><br><span class="line">    -- 交叉连接 cross join</span><br><span class="line">        即，没有条件的内连接。</span><br><span class="line">        select * from tb1 cross join tb2;</span><br><span class="line">-- 外连接(outer join)</span><br><span class="line">    - 如果数据不存在，也会出现在连接结果中。</span><br><span class="line">    -- 左外连接 left join</span><br><span class="line">        如果数据不存在，左表记录会出现，而右表为null填充</span><br><span class="line">    -- 右外连接 right join</span><br><span class="line">        如果数据不存在，右表记录会出现，而左表为null填充</span><br><span class="line">-- 自然连接(natural join)</span><br><span class="line">    自动判断连接条件完成连接。</span><br><span class="line">    相当于省略了using，会自动查找相同字段名。</span><br><span class="line">    natural join</span><br><span class="line">    natural left join</span><br><span class="line">    natural right join</span><br><span class="line">select info.id, info.name, info.stu_num, extra_info.hobby, extra_info.sex from info, extra_info where info.stu_num = extra_info.stu_id;</span><br></pre></td></tr></table></figure><h3 id="TRUNCATE"><a href="#TRUNCATE" class="headerlink" title="TRUNCATE"></a>TRUNCATE</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/* TRUNCATE */ ------------------</span><br><span class="line">TRUNCATE [TABLE] tbl_name</span><br><span class="line">清空数据</span><br><span class="line">删除重建表</span><br><span class="line">区别：</span><br><span class="line">1，truncate 是删除表再创建，delete 是逐条删除</span><br><span class="line">2，truncate 重置auto_increment的值。而delete不会</span><br><span class="line">3，truncate 不知道删除了几条，而delete知道。</span><br><span class="line">4，当被用于带分区的表时，truncate 会保留分区</span><br></pre></td></tr></table></figure><h3 id="备份与还原"><a href="#备份与还原" class="headerlink" title="备份与还原"></a>备份与还原</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/* 备份与还原 */ ------------------</span><br><span class="line">备份，将数据的结构与表内数据保存起来。</span><br><span class="line">利用 mysqldump 指令完成。</span><br><span class="line">-- 导出</span><br><span class="line">mysqldump [options] db_name [tables]</span><br><span class="line">mysqldump [options] ---database DB1 [DB2 DB3...]</span><br><span class="line">mysqldump [options] --all--database</span><br><span class="line">1. 导出一张表</span><br><span class="line">　　mysqldump -u用户名 -p密码 库名 表名 &gt; 文件名(D:/a.sql)</span><br><span class="line">2. 导出多张表</span><br><span class="line">　　mysqldump -u用户名 -p密码 库名 表1 表2 表3 &gt; 文件名(D:/a.sql)</span><br><span class="line">3. 导出所有表</span><br><span class="line">　　mysqldump -u用户名 -p密码 库名 &gt; 文件名(D:/a.sql)</span><br><span class="line">4. 导出一个库</span><br><span class="line">　　mysqldump -u用户名 -p密码 --lock-all-tables --database 库名 &gt; 文件名(D:/a.sql)</span><br><span class="line">可以-w携带WHERE条件</span><br><span class="line">-- 导入</span><br><span class="line">1. 在登录mysql的情况下：</span><br><span class="line">　　source  备份文件</span><br><span class="line">2. 在不登录的情况下</span><br><span class="line">　　mysql -u用户名 -p密码 库名 &lt; 备份文件</span><br></pre></td></tr></table></figure><h3 id="视图"><a href="#视图" class="headerlink" title="视图"></a>视图</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">什么是视图：</span><br><span class="line">    视图是一个虚拟表，其内容由查询定义。同真实的表一样，视图包含一系列带有名称的列和行数据。但是，视图并不在数据库中以存储的数据值集形式存在。行和列数据来自由定义视图的查询所引用的表，并且在引用视图时动态生成。</span><br><span class="line">    视图具有表结构文件，但不存在数据文件。</span><br><span class="line">    对其中所引用的基础表来说，视图的作用类似于筛选。定义视图的筛选可以来自当前或其它数据库的一个或多个表，或者其它视图。通过视图进行查询没有任何限制，通过它们进行数据修改时的限制也很少。</span><br><span class="line">    视图是存储在数据库中的查询的sql语句，它主要出于两种原因：安全原因，视图可以隐藏一些数据，如：社会保险基金表，可以用视图只显示姓名，地址，而不显示社会保险号和工资数等，另一原因是可使复杂的查询易于理解和使用。</span><br><span class="line">-- 创建视图</span><br><span class="line">CREATE [OR REPLACE] [ALGORITHM = &#123;UNDEFINED | MERGE | TEMPTABLE&#125;] VIEW view_name [(column_list)] AS select_statement</span><br><span class="line">    - 视图名必须唯一，同时不能与表重名。</span><br><span class="line">    - 视图可以使用select语句查询到的列名，也可以自己指定相应的列名。</span><br><span class="line">    - 可以指定视图执行的算法，通过ALGORITHM指定。</span><br><span class="line">    - column_list如果存在，则数目必须等于SELECT语句检索的列数</span><br><span class="line">-- 查看结构</span><br><span class="line">    SHOW CREATE VIEW view_name</span><br><span class="line">-- 删除视图</span><br><span class="line">    - 删除视图后，数据依然存在。</span><br><span class="line">    - 可同时删除多个视图。</span><br><span class="line">    DROP VIEW [IF EXISTS] view_name ...</span><br><span class="line">-- 修改视图结构</span><br><span class="line">    - 一般不修改视图，因为不是所有的更新视图都会映射到表上。</span><br><span class="line">    ALTER VIEW view_name [(column_list)] AS select_statement</span><br><span class="line">-- 视图作用</span><br><span class="line">    1. 简化业务逻辑</span><br><span class="line">    2. 对客户端隐藏真实的表结构</span><br><span class="line">-- 视图算法(ALGORITHM)</span><br><span class="line">    MERGE       合并</span><br><span class="line">        将视图的查询语句，与外部查询需要先合并再执行！</span><br><span class="line">    TEMPTABLE   临时表</span><br><span class="line">        将视图执行完毕后，形成临时表，再做外层查询！</span><br><span class="line">    UNDEFINED   未定义(默认)，指的是MySQL自主去选择相应的算法。</span><br></pre></td></tr></table></figure><h3 id="事务-transaction"><a href="#事务-transaction" class="headerlink" title="事务(transaction)"></a>事务(transaction)</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">事务是指逻辑上的一组操作，组成这组操作的各个单元，要不全成功要不全失败。</span><br><span class="line">    - 支持连续SQL的集体成功或集体撤销。</span><br><span class="line">    - 事务是数据库在数据晚自习方面的一个功能。</span><br><span class="line">    - 需要利用 InnoDB 或 BDB 存储引擎，对自动提交的特性支持完成。</span><br><span class="line">    - InnoDB被称为事务安全型引擎。</span><br><span class="line">-- 事务开启</span><br><span class="line">    START TRANSACTION; 或者 BEGIN;</span><br><span class="line">    开启事务后，所有被执行的SQL语句均被认作当前事务内的SQL语句。</span><br><span class="line">-- 事务提交</span><br><span class="line">    COMMIT;</span><br><span class="line">-- 事务回滚</span><br><span class="line">    ROLLBACK;</span><br><span class="line">    如果部分操作发生问题，映射到事务开启前。</span><br><span class="line">-- 事务的特性</span><br><span class="line">    1. 原子性（Atomicity）</span><br><span class="line">        事务是一个不可分割的工作单位，事务中的操作要么都发生，要么都不发生。</span><br><span class="line">    2. 一致性（Consistency）</span><br><span class="line">        事务前后数据的完整性必须保持一致。</span><br><span class="line">        - 事务开始和结束时，外部数据一致</span><br><span class="line">        - 在整个事务过程中，操作是连续的</span><br><span class="line">    3. 隔离性（Isolation）</span><br><span class="line">        多个用户并发访问数据库时，一个用户的事务不能被其它用户的事物所干扰，多个并发事务之间的数据要相互隔离。</span><br><span class="line">    4. 持久性（Durability）</span><br><span class="line">        一个事务一旦被提交，它对数据库中的数据改变就是永久性的。</span><br><span class="line">-- 事务的实现</span><br><span class="line">    1. 要求是事务支持的表类型</span><br><span class="line">    2. 执行一组相关的操作前开启事务</span><br><span class="line">    3. 整组操作完成后，都成功，则提交；如果存在失败，选择回滚，则会回到事务开始的备份点。</span><br><span class="line">-- 事务的原理</span><br><span class="line">    利用InnoDB的自动提交(autocommit)特性完成。</span><br><span class="line">    普通的MySQL执行语句后，当前的数据提交操作均可被其他客户端可见。</span><br><span class="line">    而事务是暂时关闭“自动提交”机制，需要commit提交持久化数据操作。</span><br><span class="line">-- 注意</span><br><span class="line">    1. 数据定义语言（DDL）语句不能被回滚，比如创建或取消数据库的语句，和创建、取消或更改表或存储的子程序的语句。</span><br><span class="line">    2. 事务不能被嵌套</span><br><span class="line">-- 保存点</span><br><span class="line">    SAVEPOINT 保存点名称 -- 设置一个事务保存点</span><br><span class="line">    ROLLBACK TO SAVEPOINT 保存点名称 -- 回滚到保存点</span><br><span class="line">    RELEASE SAVEPOINT 保存点名称 -- 删除保存点</span><br><span class="line">-- InnoDB自动提交特性设置</span><br><span class="line">    SET autocommit = 0|1;   0表示关闭自动提交，1表示开启自动提交。</span><br><span class="line">    - 如果关闭了，那普通操作的结果对其他客户端也不可见，需要commit提交后才能持久化数据操作。</span><br><span class="line">    - 也可以关闭自动提交来开启事务。但与START TRANSACTION不同的是，</span><br><span class="line">        SET autocommit是永久改变服务器的设置，直到下次再次修改该设置。(针对当前连接)</span><br><span class="line">        而START TRANSACTION记录开启前的状态，而一旦事务提交或回滚后就需要再次开启事务。(针对当前事务)</span><br></pre></td></tr></table></figure><h3 id="锁表"><a href="#锁表" class="headerlink" title="锁表"></a>锁表</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/* 锁表 */</span><br><span class="line">表锁定只用于防止其它客户端进行不正当地读取和写入</span><br><span class="line">MyISAM 支持表锁，InnoDB 支持行锁</span><br><span class="line">-- 锁定</span><br><span class="line">    LOCK TABLES tbl_name [AS alias]</span><br><span class="line">-- 解锁</span><br><span class="line">    UNLOCK TABLES</span><br></pre></td></tr></table></figure><h3 id="触发器"><a href="#触发器" class="headerlink" title="触发器"></a>触发器</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/* 触发器 */ ------------------</span><br><span class="line">    触发程序是与表有关的命名数据库对象，当该表出现特定事件时，将激活该对象</span><br><span class="line">    监听：记录的增加、修改、删除。</span><br><span class="line">-- 创建触发器</span><br><span class="line">CREATE TRIGGER trigger_name trigger_time trigger_event ON tbl_name FOR EACH ROW trigger_stmt</span><br><span class="line">    参数：</span><br><span class="line">    trigger_time是触发程序的动作时间。它可以是 before 或 after，以指明触发程序是在激活它的语句之前或之后触发。</span><br><span class="line">    trigger_event指明了激活触发程序的语句的类型</span><br><span class="line">        INSERT：将新行插入表时激活触发程序</span><br><span class="line">        UPDATE：更改某一行时激活触发程序</span><br><span class="line">        DELETE：从表中删除某一行时激活触发程序</span><br><span class="line">    tbl_name：监听的表，必须是永久性的表，不能将触发程序与TEMPORARY表或视图关联起来。</span><br><span class="line">    trigger_stmt：当触发程序激活时执行的语句。执行多个语句，可使用BEGIN...END复合语句结构</span><br><span class="line">-- 删除</span><br><span class="line">DROP TRIGGER [schema_name.]trigger_name</span><br><span class="line">可以使用old和new代替旧的和新的数据</span><br><span class="line">    更新操作，更新前是old，更新后是new.</span><br><span class="line">    删除操作，只有old.</span><br><span class="line">    增加操作，只有new.</span><br><span class="line">-- 注意</span><br><span class="line">    1. 对于具有相同触发程序动作时间和事件的给定表，不能有两个触发程序。</span><br><span class="line">-- 字符连接函数</span><br><span class="line">concat(str1,str2,...])</span><br><span class="line">concat_ws(separator,str1,str2,...)</span><br><span class="line">-- 分支语句</span><br><span class="line">if 条件 then</span><br><span class="line">    执行语句</span><br><span class="line">elseif 条件 then</span><br><span class="line">    执行语句</span><br><span class="line">else</span><br><span class="line">    执行语句</span><br><span class="line">end if;</span><br><span class="line">-- 修改最外层语句结束符</span><br><span class="line">delimiter 自定义结束符号</span><br><span class="line">    SQL语句</span><br><span class="line">自定义结束符号</span><br><span class="line">delimiter ;     -- 修改回原来的分号</span><br><span class="line">-- 语句块包裹</span><br><span class="line">begin</span><br><span class="line">    语句块</span><br><span class="line">end</span><br><span class="line">-- 特殊的执行</span><br><span class="line">1. 只要添加记录，就会触发程序。</span><br><span class="line">2. Insert into on duplicate key update 语法会触发：</span><br><span class="line">    如果没有重复记录，会触发 before insert, after insert;</span><br><span class="line">    如果有重复记录并更新，会触发 before insert, before update, after update;</span><br><span class="line">    如果有重复记录但是没有发生更新，则触发 before insert, before update</span><br><span class="line">3. Replace 语法 如果有记录，则执行 before insert, before delete, after delete, after insert</span><br></pre></td></tr></table></figure><h3 id="SQL编程"><a href="#SQL编程" class="headerlink" title="SQL编程"></a>SQL编程</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/* SQL编程 */ ------------------</span><br><span class="line">--// 局部变量 ----------</span><br><span class="line">-- 变量声明</span><br><span class="line">    declare var_name[,...] type [default value]</span><br><span class="line">    这个语句被用来声明局部变量。要给变量提供一个默认值，请包含一个default子句。值可以被指定为一个表达式，不需要为一个常数。如果没有default子句，初始值为null。</span><br><span class="line">-- 赋值</span><br><span class="line">    使用 set 和 select into 语句为变量赋值。</span><br><span class="line">    - 注意：在函数内是可以使用全局变量（用户自定义的变量）</span><br><span class="line">--// 全局变量 ----------</span><br><span class="line">-- 定义、赋值</span><br><span class="line">set 语句可以定义并为变量赋值。</span><br><span class="line">set @var = value;</span><br><span class="line">也可以使用select into语句为变量初始化并赋值。这样要求select语句只能返回一行，但是可以是多个字段，就意味着同时为多个变量进行赋值，变量的数量需要与查询的列数一致。</span><br><span class="line">还可以把赋值语句看作一个表达式，通过select执行完成。此时为了避免=被当作关系运算符看待，使用:=代替。（set语句可以使用= 和 :=）。</span><br><span class="line">select @var:=20;</span><br><span class="line">select @v1:=id, @v2=name from t1 limit 1;</span><br><span class="line">select * from tbl_name where @var:=30;</span><br><span class="line">select into 可以将表中查询获得的数据赋给变量。</span><br><span class="line">    -| select max(height) into @max_height from tb;</span><br><span class="line">-- 自定义变量名</span><br><span class="line">为了避免select语句中，用户自定义的变量与系统标识符（通常是字段名）冲突，用户自定义变量在变量名前使用@作为开始符号。</span><br><span class="line">@var=10;</span><br><span class="line">    - 变量被定义后，在整个会话周期都有效（登录到退出）</span><br><span class="line">--// 控制结构 ----------</span><br><span class="line">-- if语句</span><br><span class="line">if search_condition then</span><br><span class="line">    statement_list   </span><br><span class="line">[elseif search_condition then</span><br><span class="line">    statement_list]</span><br><span class="line">...</span><br><span class="line">[else</span><br><span class="line">    statement_list]</span><br><span class="line">end if;</span><br><span class="line">-- case语句</span><br><span class="line">CASE value WHEN [compare-value] THEN result</span><br><span class="line">[WHEN [compare-value] THEN result ...]</span><br><span class="line">[ELSE result]</span><br><span class="line">END</span><br><span class="line">-- while循环</span><br><span class="line">[begin_label:] while search_condition do</span><br><span class="line">    statement_list</span><br><span class="line">end while [end_label];</span><br><span class="line">- 如果需要在循环内提前终止 while循环，则需要使用标签；标签需要成对出现。</span><br><span class="line">    -- 退出循环</span><br><span class="line">        退出整个循环 leave</span><br><span class="line">        退出当前循环 iterate</span><br><span class="line">        通过退出的标签决定退出哪个循环</span><br><span class="line">--// 内置函数 ----------</span><br><span class="line">-- 数值函数</span><br><span class="line">abs(x)          -- 绝对值 abs(-10.9) = 10</span><br><span class="line">format(x, d)    -- 格式化千分位数值 format(1234567.456, 2) = 1,234,567.46</span><br><span class="line">ceil(x)         -- 向上取整 ceil(10.1) = 11</span><br><span class="line">floor(x)        -- 向下取整 floor (10.1) = 10</span><br><span class="line">round(x)        -- 四舍五入去整</span><br><span class="line">mod(m, n)       -- m%n m mod n 求余 10%3=1</span><br><span class="line">pi()            -- 获得圆周率</span><br><span class="line">pow(m, n)       -- m^n</span><br><span class="line">sqrt(x)         -- 算术平方根</span><br><span class="line">rand()          -- 随机数</span><br><span class="line">truncate(x, d)  -- 截取d位小数</span><br><span class="line">-- 时间日期函数</span><br><span class="line">now(), current_timestamp();     -- 当前日期时间</span><br><span class="line">current_date();                 -- 当前日期</span><br><span class="line">current_time();                 -- 当前时间</span><br><span class="line">date(&apos;yyyy-mm-dd hh:ii:ss&apos;);    -- 获取日期部分</span><br><span class="line">time(&apos;yyyy-mm-dd hh:ii:ss&apos;);    -- 获取时间部分</span><br><span class="line">date_format(&apos;yyyy-mm-dd hh:ii:ss&apos;, &apos;%d %y %a %d %m %b %j&apos;); -- 格式化时间</span><br><span class="line">unix_timestamp();               -- 获得unix时间戳</span><br><span class="line">from_unixtime();                -- 从时间戳获得时间</span><br><span class="line">-- 字符串函数</span><br><span class="line">length(string)          -- string长度，字节</span><br><span class="line">char_length(string)     -- string的字符个数</span><br><span class="line">substring(str, position [,length])      -- 从str的position开始,取length个字符</span><br><span class="line">replace(str ,search_str ,replace_str)   -- 在str中用replace_str替换search_str</span><br><span class="line">instr(string ,substring)    -- 返回substring首次在string中出现的位置</span><br><span class="line">concat(string [,...])   -- 连接字串</span><br><span class="line">charset(str)            -- 返回字串字符集</span><br><span class="line">lcase(string)           -- 转换成小写</span><br><span class="line">left(string, length)    -- 从string2中的左边起取length个字符</span><br><span class="line">load_file(file_name)    -- 从文件读取内容</span><br><span class="line">locate(substring, string [,start_position]) -- 同instr,但可指定开始位置</span><br><span class="line">lpad(string, length, pad)   -- 重复用pad加在string开头,直到字串长度为length</span><br><span class="line">ltrim(string)           -- 去除前端空格</span><br><span class="line">repeat(string, count)   -- 重复count次</span><br><span class="line">rpad(string, length, pad)   --在str后用pad补充,直到长度为length</span><br><span class="line">rtrim(string)           -- 去除后端空格</span><br><span class="line">strcmp(string1 ,string2)    -- 逐字符比较两字串大小</span><br><span class="line">-- 流程函数</span><br><span class="line">case when [condition] then result [when [condition] then result ...] [else result] end   多分支</span><br><span class="line">if(expr1,expr2,expr3)  双分支。</span><br><span class="line">-- 聚合函数</span><br><span class="line">count()</span><br><span class="line">sum();</span><br><span class="line">max();</span><br><span class="line">min();</span><br><span class="line">avg();</span><br><span class="line">group_concat()</span><br><span class="line">-- 其他常用函数</span><br><span class="line">md5();</span><br><span class="line">default();</span><br><span class="line">--// 存储函数，自定义函数 ----------</span><br><span class="line">-- 新建</span><br><span class="line">    CREATE FUNCTION function_name (参数列表) RETURNS 返回值类型</span><br><span class="line">        函数体</span><br><span class="line">    - 函数名，应该合法的标识符，并且不应该与已有的关键字冲突。</span><br><span class="line">    - 一个函数应该属于某个数据库，可以使用db_name.funciton_name的形式执行当前函数所属数据库，否则为当前数据库。</span><br><span class="line">    - 参数部分，由&quot;参数名&quot;和&quot;参数类型&quot;组成。多个参数用逗号隔开。</span><br><span class="line">    - 函数体由多条可用的mysql语句，流程控制，变量声明等语句构成。</span><br><span class="line">    - 多条语句应该使用 begin...end 语句块包含。</span><br><span class="line">    - 一定要有 return 返回值语句。</span><br><span class="line">-- 删除</span><br><span class="line">    DROP FUNCTION [IF EXISTS] function_name;</span><br><span class="line">-- 查看</span><br><span class="line">    SHOW FUNCTION STATUS LIKE &apos;partten&apos;</span><br><span class="line">    SHOW CREATE FUNCTION function_name;</span><br><span class="line">-- 修改</span><br><span class="line">    ALTER FUNCTION function_name 函数选项</span><br><span class="line">--// 存储过程，自定义功能 ----------</span><br><span class="line">-- 定义</span><br><span class="line">存储存储过程 是一段代码（过程），存储在数据库中的sql组成。</span><br><span class="line">一个存储过程通常用于完成一段业务逻辑，例如报名，交班费，订单入库等。</span><br><span class="line">而一个函数通常专注与某个功能，视为其他程序服务的，需要在其他语句中调用函数才可以，而存储过程不能被其他调用，是自己执行 通过call执行。</span><br><span class="line">-- 创建</span><br><span class="line">CREATE PROCEDURE sp_name (参数列表)</span><br><span class="line">    过程体</span><br><span class="line">参数列表：不同于函数的参数列表，需要指明参数类型</span><br><span class="line">IN，表示输入型</span><br><span class="line">OUT，表示输出型</span><br><span class="line">INOUT，表示混合型</span><br><span class="line">注意，没有返回值。</span><br></pre></td></tr></table></figure><h3 id="存储过程"><a href="#存储过程" class="headerlink" title="存储过程"></a>存储过程</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/* 存储过程 */ ------------------</span><br><span class="line">存储过程是一段可执行性代码的集合。相比函数，更偏向于业务逻辑。</span><br><span class="line">调用：CALL 过程名</span><br><span class="line">-- 注意</span><br><span class="line">- 没有返回值。</span><br><span class="line">- 只能单独调用，不可夹杂在其他语句中</span><br><span class="line">-- 参数</span><br><span class="line">IN|OUT|INOUT 参数名 数据类型</span><br><span class="line">IN      输入：在调用过程中，将数据输入到过程体内部的参数</span><br><span class="line">OUT     输出：在调用过程中，将过程体处理完的结果返回到客户端</span><br><span class="line">INOUT   输入输出：既可输入，也可输出</span><br><span class="line">-- 语法</span><br><span class="line">CREATE PROCEDURE 过程名 (参数列表)</span><br><span class="line">BEGIN</span><br><span class="line">    过程体</span><br><span class="line">END</span><br></pre></td></tr></table></figure><h3 id="用户和权限管理"><a href="#用户和权限管理" class="headerlink" title="用户和权限管理"></a>用户和权限管理</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/* 用户和权限管理 */ ------------------</span><br><span class="line">-- root密码重置</span><br><span class="line">1. 停止MySQL服务</span><br><span class="line">2.  [Linux] /usr/local/mysql/bin/safe_mysqld --skip-grant-tables &amp;</span><br><span class="line">    [Windows] mysqld --skip-grant-tables</span><br><span class="line">3. use mysql;</span><br><span class="line">4. UPDATE `user` SET PASSWORD=PASSWORD(&quot;密码&quot;) WHERE `user` = &quot;root&quot;;</span><br><span class="line">5. FLUSH PRIVILEGES;</span><br><span class="line">用户信息表：mysql.user</span><br><span class="line">-- 刷新权限</span><br><span class="line">FLUSH PRIVILEGES;</span><br><span class="line">-- 增加用户</span><br><span class="line">CREATE USER 用户名 IDENTIFIED BY [PASSWORD] 密码(字符串)</span><br><span class="line">    - 必须拥有mysql数据库的全局CREATE USER权限，或拥有INSERT权限。</span><br><span class="line">    - 只能创建用户，不能赋予权限。</span><br><span class="line">    - 用户名，注意引号：如 &apos;user_name&apos;@&apos;192.168.1.1&apos;</span><br><span class="line">    - 密码也需引号，纯数字密码也要加引号</span><br><span class="line">    - 要在纯文本中指定密码，需忽略PASSWORD关键词。要把密码指定为由PASSWORD()函数返回的混编值，需包含关键字PASSWORD</span><br><span class="line">-- 重命名用户</span><br><span class="line">RENAME USER old_user TO new_user</span><br><span class="line">-- 设置密码</span><br><span class="line">SET PASSWORD = PASSWORD(&apos;密码&apos;)  -- 为当前用户设置密码</span><br><span class="line">SET PASSWORD FOR 用户名 = PASSWORD(&apos;密码&apos;) -- 为指定用户设置密码</span><br><span class="line">-- 删除用户</span><br><span class="line">DROP USER 用户名</span><br><span class="line">-- 分配权限/添加用户</span><br><span class="line">GRANT 权限列表 ON 表名 TO 用户名 [IDENTIFIED BY [PASSWORD] &apos;password&apos;]</span><br><span class="line">    - all privileges 表示所有权限</span><br><span class="line">    - *.* 表示所有库的所有表</span><br><span class="line">    - 库名.表名 表示某库下面的某表</span><br><span class="line">    GRANT ALL PRIVILEGES ON `pms`.* TO &apos;pms&apos;@&apos;%&apos; IDENTIFIED BY &apos;pms0817&apos;;</span><br><span class="line">-- 查看权限</span><br><span class="line">SHOW GRANTS FOR 用户名</span><br><span class="line">    -- 查看当前用户权限</span><br><span class="line">    SHOW GRANTS; 或 SHOW GRANTS FOR CURRENT_USER; 或 SHOW GRANTS FOR CURRENT_USER();</span><br><span class="line">-- 撤消权限</span><br><span class="line">REVOKE 权限列表 ON 表名 FROM 用户名</span><br><span class="line">REVOKE ALL PRIVILEGES, GRANT OPTION FROM 用户名   -- 撤销所有权限</span><br><span class="line">-- 权限层级</span><br><span class="line">-- 要使用GRANT或REVOKE，您必须拥有GRANT OPTION权限，并且您必须用于您正在授予或撤销的权限。</span><br><span class="line">全局层级：全局权限适用于一个给定服务器中的所有数据库，mysql.user</span><br><span class="line">    GRANT ALL ON *.*和 REVOKE ALL ON *.*只授予和撤销全局权限。</span><br><span class="line">数据库层级：数据库权限适用于一个给定数据库中的所有目标，mysql.db, mysql.host</span><br><span class="line">    GRANT ALL ON db_name.*和REVOKE ALL ON db_name.*只授予和撤销数据库权限。</span><br><span class="line">表层级：表权限适用于一个给定表中的所有列，mysql.talbes_priv</span><br><span class="line">    GRANT ALL ON db_name.tbl_name和REVOKE ALL ON db_name.tbl_name只授予和撤销表权限。</span><br><span class="line">列层级：列权限适用于一个给定表中的单一列，mysql.columns_priv</span><br><span class="line">    当使用REVOKE时，您必须指定与被授权列相同的列。</span><br><span class="line">-- 权限列表</span><br><span class="line">ALL [PRIVILEGES]    -- 设置除GRANT OPTION之外的所有简单权限</span><br><span class="line">ALTER   -- 允许使用ALTER TABLE</span><br><span class="line">ALTER ROUTINE   -- 更改或取消已存储的子程序</span><br><span class="line">CREATE  -- 允许使用CREATE TABLE</span><br><span class="line">CREATE ROUTINE  -- 创建已存储的子程序</span><br><span class="line">CREATE TEMPORARY TABLES     -- 允许使用CREATE TEMPORARY TABLE</span><br><span class="line">CREATE USER     -- 允许使用CREATE USER, DROP USER, RENAME USER和REVOKE ALL PRIVILEGES。</span><br><span class="line">CREATE VIEW     -- 允许使用CREATE VIEW</span><br><span class="line">DELETE  -- 允许使用DELETE</span><br><span class="line">DROP    -- 允许使用DROP TABLE</span><br><span class="line">EXECUTE     -- 允许用户运行已存储的子程序</span><br><span class="line">FILE    -- 允许使用SELECT...INTO OUTFILE和LOAD DATA INFILE</span><br><span class="line">INDEX   -- 允许使用CREATE INDEX和DROP INDEX</span><br><span class="line">INSERT  -- 允许使用INSERT</span><br><span class="line">LOCK TABLES     -- 允许对您拥有SELECT权限的表使用LOCK TABLES</span><br><span class="line">PROCESS     -- 允许使用SHOW FULL PROCESSLIST</span><br><span class="line">REFERENCES  -- 未被实施</span><br><span class="line">RELOAD  -- 允许使用FLUSH</span><br><span class="line">REPLICATION CLIENT  -- 允许用户询问从属服务器或主服务器的地址</span><br><span class="line">REPLICATION SLAVE   -- 用于复制型从属服务器（从主服务器中读取二进制日志事件）</span><br><span class="line">SELECT  -- 允许使用SELECT</span><br><span class="line">SHOW DATABASES  -- 显示所有数据库</span><br><span class="line">SHOW VIEW   -- 允许使用SHOW CREATE VIEW</span><br><span class="line">SHUTDOWN    -- 允许使用mysqladmin shutdown</span><br><span class="line">SUPER   -- 允许使用CHANGE MASTER, KILL, PURGE MASTER LOGS和SET GLOBAL语句，mysqladmin debug命令；允许您连接（一次），即使已达到max_connections。</span><br><span class="line">UPDATE  -- 允许使用UPDATE</span><br><span class="line">USAGE   -- “无权限”的同义词</span><br><span class="line">GRANT OPTION    -- 允许授予权限</span><br></pre></td></tr></table></figure><h3 id="表维护"><a href="#表维护" class="headerlink" title="表维护"></a>表维护</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/* 表维护 */</span><br><span class="line">-- 分析和存储表的关键字分布</span><br><span class="line">ANALYZE [LOCAL | NO_WRITE_TO_BINLOG] TABLE 表名 ...</span><br><span class="line">-- 检查一个或多个表是否有错误</span><br><span class="line">CHECK TABLE tbl_name [, tbl_name] ... [option] ...</span><br><span class="line">option = &#123;QUICK | FAST | MEDIUM | EXTENDED | CHANGED&#125;</span><br><span class="line">-- 整理数据文件的碎片</span><br><span class="line">OPTIMIZE [LOCAL | NO_WRITE_TO_BINLOG] TABLE tbl_name [, tbl_name] ...</span><br></pre></td></tr></table></figure><h3 id="杂项"><a href="#杂项" class="headerlink" title="杂项"></a>杂项</h3><figure class="highlight plain"><table><tr><td class="code"><pre><span class="line">/* 杂项 */ ------------------</span><br><span class="line">1. 可用反引号（`）为标识符（库名、表名、字段名、索引、别名）包裹，以避免与关键字重名！中文也可以作为标识符！</span><br><span class="line">2. 每个库目录存在一个保存当前数据库的选项文件db.opt。</span><br><span class="line">3. 注释：</span><br><span class="line">    单行注释 # 注释内容</span><br><span class="line">    多行注释 /* 注释内容 */</span><br><span class="line">    单行注释 -- 注释内容     (标准SQL注释风格，要求双破折号后加一空格符（空格、TAB、换行等）)</span><br><span class="line">4. 模式通配符：</span><br><span class="line">    _   任意单个字符</span><br><span class="line">    %   任意多个字符，甚至包括零字符</span><br><span class="line">    单引号需要进行转义 \&apos;</span><br><span class="line">5. CMD命令行内的语句结束符可以为 &quot;;&quot;, &quot;\G&quot;, &quot;\g&quot;，仅影响显示结果。其他地方还是用分号结束。delimiter 可修改当前对话的语句结束符。</span><br><span class="line">6. SQL对大小写不敏感</span><br><span class="line">7. 清除已有语句：\c</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> DB </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SQL </tag>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>序列化与transient关键字</title>
      <link href="/2018/05/19/Java%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8Ctransient%E5%85%B3%E9%94%AE%E5%AD%97/"/>
      <url>/2018/05/19/Java%E5%BA%8F%E5%88%97%E5%8C%96%E5%92%8Ctransient%E5%85%B3%E9%94%AE%E5%AD%97/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>今天碰到了transient这个关键字，稍微了解下是不让这个对象序列化的意思，关于序列化和这个关键字有必要认识一下。</p><h2 id="序列化"><a href="#序列化" class="headerlink" title="序列化"></a>序列化</h2><p>Java中的序列化是指Java中对象的序列化指的是将对象转换成以字节序列的形式来表示，这些字节序列包含了对象的数据和信息，一个序列化后的对象可以被写到数据库或文件中，也可用于网络传输，一般当我们使用缓存cache（内存空间不够有可能会本地存储到硬盘）或远程调用rpc（网络传输）的时候，经常需要让我们的实体类实现Serializable接口，目的就是为了让其可序列化。<br>序列化后的字节序列都是可以恢复成Java对象的，这个过程就是反序列化。</p><h2 id="transient关键字"><a href="#transient关键字" class="headerlink" title="transient关键字"></a>transient关键字</h2><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><p>让被修饰的成员变量不被序列化</p><h3 id="场景"><a href="#场景" class="headerlink" title="场景"></a>场景</h3><p>类中的字段值可以根据其它字段推导出来，如一个长方形类有三个属性：长度、宽度、面积，那么在序列化的时候，面积这个属性就没必要被序列化了</p><p>其他就是看具体业务场景了</p><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><ul><li>在变量前加上这个关键字可以阻止该变量被序列化到文件中，在反序列化后，transient变量的值被设为初始值，如int型为0，对象为null</li><li>这个类实现了serilizable接口，则它的所有属性和方法都会自动序列化</li><li>一个静态变量不管是否被transient修饰，均不能被序列化</li></ul><p><strong><u>还有一条，transient关键字只能修饰变量，而不能修饰方法和类，这个有不同的声音，还有人说可以修饰方法？</u></strong><br>这个确定后在评论区见</p><hr><p>推荐一个🔗，大致看了下很不错</p><p><a href="http://www.360doc.com/content/13/0728/18/13247663_303173972.shtml" target="_blank" rel="noopener">Java序列化的高级认识</a></p><p>over</p>]]></content>
      
      
      <categories>
          
          <category> JavaSE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Serializable </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>多态的一道面试题</title>
      <link href="/2018/05/11/%E5%A4%9A%E6%80%81%E7%9A%84%E4%B8%80%E9%81%93%E9%9D%A2%E8%AF%95%E9%A2%98/"/>
      <url>/2018/05/11/%E5%A4%9A%E6%80%81%E7%9A%84%E4%B8%80%E9%81%93%E9%9D%A2%E8%AF%95%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="多态"><a href="#多态" class="headerlink" title="多态"></a>多态</h2><p>类A：</p><pre><code>class A {     public String show(D obj){         return (&quot;A and D&quot;);      }       public String show(A obj){                return (&quot;A and A&quot;);     }   }   </code></pre><p>类B：</p><pre><code>class B extends A{      public String show(B obj){         return (&quot;B and B&quot;);      }      public String show(A obj){         return (&quot;B and A&quot;);      }   }  </code></pre><p>类C：</p><pre><code>class C extends B{}</code></pre><p>类D：</p><pre><code>class D extends B{}</code></pre><p>测试类：</p><pre><code>class  DynamicTest{       public static void main(String[] args){   A a1 = new A();     A a2 = new B();     B b = new B();     C c = new C();      D d = new D();     System.out.println(a1.show(b));      System.out.println(a1.show(c));     System.out.println(a1.show(d));     System.out.println(a2.show(b));                                  System.out.println(a2.show(c));                                System.out.println(a2.show(d));           System.out.println(b.show(b));       System.out.println(b.show(c));     System.out.println(b.show(d));         }}</code></pre><p>答案：</p><pre><code>System.out.println(a1.show(b));       AASystem.out.println(a1.show(c));     AASystem.out.println(a1.show(d));      ADSystem.out.println(a2.show(b));     BA     编译看左边，看右边可有重写              System.out.println(a2.show(c));     BA   同样，看可有重写！                    System.out.println(a2.show(d));     AD   编译看左边，但没有重写System.out.println(b.show(b));       BB   System.out.println(b.show(c));      BB   这里父类和爷爷类都可以，取最近的System.out.println(b.show(d));           AD   B是A的子类 ，会把A的方法都继承</code></pre><p>如果觉得有用，不如给个<a href="https://github.com/JiGuangwuu/JiGuangwuu.github.io" target="_blank" rel="noopener">Star Or Follow</a>，感谢。</p>]]></content>
      
      
      <categories>
          
          <category> JavaSE </category>
          
      </categories>
      
      
        <tags>
            
            <tag> interview </tag>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>XML解析</title>
      <link href="/2018/04/26/XML%E8%A7%A3%E6%9E%90/"/>
      <url>/2018/04/26/XML%E8%A7%A3%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h1><hr><p>操作xml文档，将文档的数据读取到内存中。</p><h2 id="解析方式"><a href="#解析方式" class="headerlink" title="解析方式"></a>解析方式</h2><pre><code>DOM 将标记语言文档一次性加载进内存，在内存中形成一棵dom树优点：操作方便，可以对文档进行CRUD的所有操作缺点：占内存SAX 逐行读取，基于事件驱动优点：不占内存，相比DOM效率更高缺点：只能读取，不能增删改</code></pre><h2 id="解析器"><a href="#解析器" class="headerlink" title="解析器"></a>解析器</h2><p>常见解析器</p><pre><code>1. JAXP：sun公司提供的解析器，支持dom和sax两种思想2. DOM4J：一款非常优秀的解析器3. Jsoup：jsoup 是一款Java 的HTML解析器，可直接解析某个URL地址、HTML文本内容。它提供了一套非常省力的API，可通过DOM，CSS以及类似于jQuery的操作方法来取出和操作数据。4. PULL：Android操作系统内置的解析器，sax方式的。</code></pre><h3 id="DOM4J"><a href="#DOM4J" class="headerlink" title="DOM4J"></a>DOM4J</h3><p>本文中利用dom4j和xpath的支持进行解析，DOM4J中还提供了其他几种遍历节点的方法，例如枚举(Iterator)、递归、visitor模式等等。</p><p>范例</p><pre><code>1. 导包    dom4j-1.6.1.jar    jaxen-1.1-beta-6.jar2.     public class TestDemo01 {            @Test            public void method() throws DocumentException {            //创建解析器            SAXReader saxReader = new SAXReader();            //解析xml            Document document = saxReader.read(TestDemo01.class.getClassLoader().getResourceAsStream(&quot;student.xml&quot;));            //获取根标签            Element rootElement = document.getRootElement();            /*System.out.println(rootElement);            //获取子标签            List elements = rootElement.elements();            //获取第一个            Object stu1 = elements.get(0);            System.out.println(stu1);            System.out.println(&quot;----------&quot;);            //student个数            List student = rootElement.elements(&quot;student&quot;);            int size = student.size();            System.out.println(size);            System.out.println(&quot;----------&quot;);            //获取第一个学号            Element stu = rootElement.element(&quot;student&quot;);            String s1 = stu.attributeValue(&quot;number&quot;);            System.out.println(s1);            System.out.println(&quot;----------&quot;);            //获取第一个年龄            Element age1 = stu.element(&quot;age&quot;);            String text = age1.getText();            System.out.println(text);            // 即每一级便签和下一级标签用element方法获取第一个        }    }3. 结合xpath            Element element = (Element)rootElement.selectSingleNode(&quot;//student[@number=&apos;heima_0002&apos;]&quot;);            System.out.println(element);//xpath语法可通过xpath API文档查询</code></pre><h4 id="可能出现的问题"><a href="#可能出现的问题" class="headerlink" title="可能出现的问题"></a>可能出现的问题</h4><p>在idea中编程时，使用Schema约束会在写xml文件是自动出现 <strong>xmlns=”<a href="http://www.itcast.cn/xml&quot;" target="_blank" rel="noopener">http://www.itcast.cn/xml&quot;</a></strong>，使用这样的xml编码方式再结合xpath进行解析时，会发生找不到结果的问题</p><pre><code>&lt;students xmlns=&quot;http://www.itcast.cn/xml&quot;&gt;    &lt;student number=&quot;heima_0001&quot;&gt;    &lt;name&gt;zhangsan&lt;/name&gt;    &lt;age&gt;24&lt;/age&gt;    &lt;sex&gt;male&lt;/sex&gt;    &lt;/student&gt;&lt;/students&gt;</code></pre><p>如获取</p><pre><code>Element element = (Element)rootElement.selectSingleNode(&quot;//student[@number=&apos;heima_0002&apos;]&quot;);  System.out.println(element);</code></pre><p>结果为<strong>null</strong></p><h3 id="Jsoup"><a href="#Jsoup" class="headerlink" title="Jsoup"></a>Jsoup</h3><p>步骤：</p><pre><code>1. 导入jar包        jsoup-1.11.2.jar        JsoupXpath-0.3.2.jar2. 获取Document对象3. 获取对应的标签Element对象4. 获取数据</code></pre><p>代码：</p><pre><code>//2.1获取student.xml的path  String path = JsoupDemo1.class.getClassLoader().getResource(&quot;student.xml&quot;).getPath();  //2.2解析xml文档，加载文档进内存，获取dom树---&gt;Document  Document document = Jsoup.parse(new File(path), &quot;utf-8&quot;);  //3.获取元素对象 Element  Elements elements = document.getElementsByTag(&quot;name&quot;);  System.out.println(elements.size());  //3.1获取第一个name的Element对象  Element element = elements.get(0);  //3.2获取数据  String name = element.text();  System.out.println(name);</code></pre><p>对象的使用：</p><pre><code>1. Jsoup：工具类，可以解析html或xml文档，返回Document    * parse：解析html或xml文档，返回Document        * parse​(File in, String charsetName)：解析xml或html文件的。        * parse​(String html)：解析xml或html字符串        * parse​(URL url, int timeoutMillis)：通过网络路径获取指定的html或xml的文档对象2. Document：文档对象。代表内存中的dom树    * 获取Element对象        * getElementById​(String id)：根据id属性值获取唯一的element对象        * getElementsByTag​(String tagName)：根据标签名称获取元素对象集合        * getElementsByAttribute​(String key)：根据属性名称获取元素对象集合        * getElementsByAttributeValue​(String key, String value)：根据对应的属性名和属性值获取元素对象集合3. Elements：元素Element对象的集合。可以当做 ArrayList&lt;Element&gt;来使用4. Element：元素对象    1. 获取子元素对象        * getElementById​(String id)：根据id属性值获取唯一的element对象        * getElementsByTag​(String tagName)：根据标签名称获取元素对象集合        * getElementsByAttribute​(String key)：根据属性名称获取元素对象集合        * getElementsByAttributeValue​(String key, String value)：根据对应的属性名和属性值获取元素对象集合    2. 获取属性值        * String attr(String key)：根据属性名称获取属性值    3. 获取文本内容        * String text():获取文本内容        * String html():获取标签体的所有内容(包括字标签的字符串内容)5. Node：节点对象    * 是Document和Element的父类</code></pre><p>快捷查询方式：</p><pre><code>1. selector:选择器    * 使用的方法：Elements    select​(String cssQuery)        * 语法：参考Selector类中定义的语法2. XPath：XPath即为XML路径语言，它是一种用来确定XML（标准通用标记语言的子集）文档中某部分位置的语言    * 使用Jsoup的Xpath需要额外导入jar包。    * 查询w3cshool参考手册，使用xpath的语法完成查询    * 代码：        //1.获取student.xml的path        String path = JsoupDemo6.class.getClassLoader().getResource(&quot;student.xml&quot;).getPath();        //2.获取Document对象        Document document = Jsoup.parse(new File(path), &quot;utf-8&quot;);        //3.根据document对象，创建JXDocument对象        JXDocument jxDocument = new JXDocument(document);        //4.结合xpath语法查询        //4.1查询所有student标签        List&lt;JXNode&gt; jxNodes = jxDocument.selN(&quot;//student&quot;);        for (JXNode jxNode : jxNodes) {            System.out.println(jxNode);        }        System.out.println(&quot;--------------------&quot;);        //4.2查询所有student标签下的name标签        List&lt;JXNode&gt; jxNodes2 = jxDocument.selN(&quot;//student/name&quot;);        for (JXNode jxNode : jxNodes2) {            System.out.println(jxNode);        }        System.out.println(&quot;--------------------&quot;);        //4.3查询student标签下带有id属性的name标签        List&lt;JXNode&gt; jxNodes3 = jxDocument.selN(&quot;//student/name[@id]&quot;);        for (JXNode jxNode : jxNodes3) {            System.out.println(jxNode);        }        System.out.println(&quot;--------------------&quot;);        //4.4查询student标签下带有id属性的name标签 并且id属性值为itcast        List&lt;JXNode&gt; jxNodes4 = jxDocument.selN(&quot;//student/name[@id=&apos;itcast&apos;]&quot;);        for (JXNode jxNode : jxNodes4) {            System.out.println(jxNode);        }</code></pre>]]></content>
      
      
      <categories>
          
          <category> JavaWeb </category>
          
      </categories>
      
      
        <tags>
            
            <tag> xml </tag>
            
            <tag> xpath </tag>
            
            <tag> DOM4J </tag>
            
            <tag> Jsoup </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>XML简介与约束</title>
      <link href="/2018/04/22/XML%E5%85%A5%E9%97%A8/"/>
      <url>/2018/04/22/XML%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h1><hr><ul><li><p>XML是可扩展标记语言（Extensible Markup Language），可扩展即标签都是自定义的。</p></li><li><p>功能：存储数据    </p><pre><code>1. 配置文件2. 在网络中传输</code></pre></li><li><p>与HTML的区别</p><pre><code>1. xml标签都是自定义的，html标签是预定义。2. xml的语法严格（严格区分大小写），html语法松散3. xml是存储数据的，html是展示数据</code></pre></li><li><p>各个平台之间的数据传输类型，但现在已经被JSON替换了。XML可以存储简单、小量的数据。</p></li></ul><h1 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h1><hr><h2 id="写法"><a href="#写法" class="headerlink" title="写法"></a>写法</h2><p>注意：</p><ul><li>属性值必须使用引号(单双都可)引起来</li><li>标签名称区分大小写</li></ul><p>示例</p><pre><code>    &lt;?xml version=&apos;1.0&apos; ?&gt;&lt;users&gt;    &lt;user id=&apos;1&apos;&gt;        &lt;name&gt;zhangsan&lt;/name&gt;        &lt;age&gt;23&lt;/age&gt;        &lt;gender&gt;男&lt;/gender&gt;    &lt;/user&gt;    &lt;user id=&apos;2&apos;&gt;        &lt;name&gt;lisi&lt;/name&gt;        &lt;age&gt;25&lt;/age&gt;        &lt;gender&gt;男&lt;/gender&gt;    &lt;/user&gt;&lt;/users&gt;</code></pre><h2 id="组成部分"><a href="#组成部分" class="headerlink" title="组成部分"></a>组成部分</h2><pre><code>1. 文档声明    1. 格式：&lt;?xml 属性列表 ?&gt;    2. 属性列表：        * version：版本号，必须的属性        * encoding：编码方式。告知解析引擎当前文档使用的字符集，默认值：ISO-8859-1        * standalone：是否独立            * 取值：                * yes：不依赖其他文件                * no：依赖其他文件2. 指令(了解)：结合css的    * &lt;?xml-stylesheet type=&quot;text/css&quot; href=&quot;a.css&quot; ?&gt;3. 标签：标签名称自定义的    * 规则：        * 名称可以包含字母、数字以及其他的字符         * 名称不能以数字或者标点符号开始         * 名称不能以字母 xml（或者 XML、Xml 等等）开始         * 名称不能包含空格 4. 属性：    id属性值唯一5. 文本：    * CDATA区：在该区域中的数据会被原样展示        * 格式：  &lt;![CDATA[ 数据 ]]&gt;</code></pre><h2 id="约束"><a href="#约束" class="headerlink" title="约束"></a>约束</h2><p>约束为规定XML文档的编写规则。</p><p>第一种约束 <strong>DTD</strong></p><pre><code>外部dtd：将约束的规则定义在外部的dtd文件中                    * 本地：&lt;!DOCTYPE 根标签名 SYSTEM &quot;dtd文件的位置&quot;&gt;                    * 网络：&lt;!DOCTYPE 根标签名 PUBLIC &quot;dtd文件名字&quot; &quot;dtd文件的位置URL&quot;&gt;内部dtd：写在内部</code></pre><p>外部范例</p><pre><code>//student.dtd文件&lt;!ELEMENT students (student+) &gt;&lt;!ELEMENT student (name,age,sex)&gt;&lt;!ELEMENT name (#PCDATA)&gt;&lt;!ELEMENT age (#PCDATA)&gt;&lt;!ELEMENT sex (#PCDATA)&gt;&lt;!ATTLIST student number ID #REQUIRED&gt;//student.xml文件&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;!DOCTYPE students SYSTEM &quot;student.dtd&quot;&gt;&lt;students&gt;    &lt;student number=&quot;s001&quot;&gt;        &lt;name&gt;zhangsan&lt;/name&gt;        &lt;age&gt;abc&lt;/age&gt;        &lt;sex&gt;hehe&lt;/sex&gt;    &lt;/student&gt;    &lt;student number=&quot;s002&quot;&gt;        &lt;name&gt;lisi&lt;/name&gt;        &lt;age&gt;24&lt;/age&gt;        &lt;sex&gt;female&lt;/sex&gt;    &lt;/student&gt;&lt;/students&gt;</code></pre><p>第二种约束 <strong>Schema</strong></p><p>引入</p><pre><code>    1. 填写xml文档的根元素    2. 引入xsi前缀.  xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;    3. 引入xsd文件命名空间.  xsi:schemaLocation=&quot;http://www.itcast.cn/xml  student.xsd&quot;    4. 为每一个xsd约束声明一个前缀,作为标识  xmlns=&quot;http://www.itcast.cn/xml&quot;&lt;students   xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;        xmlns=&quot;http://www.itcast.cn/xml&quot;        xsi:schemaLocation=&quot;http://www.itcast.cn/xml  student.xsd&quot;&gt;</code></pre><p>范例</p><p>student.xsd</p><pre><code>&lt;?xml version=&quot;1.0&quot; ?&gt;&lt;xsd:schema xmlns=&quot;http://www.itcast.cn/xml&quot;            xmlns:xsd=&quot;http://www.w3.org/2001/XMLSchema&quot;            targetNamespace=&quot;http://www.itcast.cn/xml&quot; elementFormDefault=&quot;qualified&quot;&gt;    &lt;xsd:element name=&quot;students&quot; type=&quot;studentsType&quot;/&gt;    &lt;xsd:complexType name=&quot;studentsType&quot;&gt;        &lt;xsd:sequence&gt;            &lt;xsd:element name=&quot;student&quot; type=&quot;studentType&quot; minOccurs=&quot;0&quot; maxOccurs=&quot;unbounded&quot;/&gt;        &lt;/xsd:sequence&gt;    &lt;/xsd:complexType&gt;    &lt;xsd:complexType name=&quot;studentType&quot;&gt;        &lt;xsd:sequence&gt;            &lt;xsd:element name=&quot;name&quot; type=&quot;xsd:string&quot;/&gt;            &lt;xsd:element name=&quot;age&quot; type=&quot;ageType&quot; /&gt;            &lt;xsd:element name=&quot;sex&quot; type=&quot;sexType&quot; /&gt;        &lt;/xsd:sequence&gt;        &lt;xsd:attribute name=&quot;number&quot; type=&quot;numberType&quot; use=&quot;required&quot;/&gt;    &lt;/xsd:complexType&gt;    &lt;xsd:simpleType name=&quot;sexType&quot;&gt;        &lt;xsd:restriction base=&quot;xsd:string&quot;&gt;            &lt;xsd:enumeration value=&quot;male&quot;/&gt;            &lt;xsd:enumeration value=&quot;female&quot;/&gt;        &lt;/xsd:restriction&gt;    &lt;/xsd:simpleType&gt;    &lt;xsd:simpleType name=&quot;ageType&quot;&gt;        &lt;xsd:restriction base=&quot;xsd:integer&quot;&gt;            &lt;xsd:minInclusive value=&quot;0&quot;/&gt;            &lt;xsd:maxInclusive value=&quot;256&quot;/&gt;        &lt;/xsd:restriction&gt;    &lt;/xsd:simpleType&gt;    &lt;xsd:simpleType name=&quot;numberType&quot;&gt;        &lt;xsd:restriction base=&quot;xsd:string&quot;&gt;            &lt;xsd:pattern value=&quot;heima_\d{4}&quot;/&gt;        &lt;/xsd:restriction&gt;    &lt;/xsd:simpleType&gt;&lt;/xsd:schema&gt;</code></pre><p>student.xml</p><pre><code>&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;&lt;students   xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;            xmlns=&quot;http://www.itcast.cn/xml&quot;            xsi:schemaLocation=&quot;http://www.itcast.cn/xml  student.xsd&quot;&gt;    &lt;student number=&quot;heima_0001&quot;&gt;        &lt;name&gt;tom&lt;/name&gt;        &lt;age&gt;18&lt;/age&gt;        &lt;sex&gt;male&lt;/sex&gt;    &lt;/student&gt;&lt;/students&gt;</code></pre>]]></content>
      
      
      <categories>
          
          <category> JavaWeb </category>
          
      </categories>
      
      
        <tags>
            
            <tag> xml </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>冒泡、插入、选择排序</title>
      <link href="/2018/03/03/%E6%8E%92%E5%BA%8F1/"/>
      <url>/2018/03/03/%E6%8E%92%E5%BA%8F1/</url>
      
        <content type="html"><![CDATA[<h1 id="问题的引入"><a href="#问题的引入" class="headerlink" title="问题的引入"></a>问题的引入</h1><h2 id="从键盘输入10个整数并按从大到小的顺序排列，输出结果"><a href="#从键盘输入10个整数并按从大到小的顺序排列，输出结果" class="headerlink" title="从键盘输入10个整数并按从大到小的顺序排列，输出结果"></a><em>从键盘输入10个整数并按从大到小的顺序排列，输出结果</em></h2><h2 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h2><p>基本思想：比较所有相邻的两个元素，如果第一个数比第二个数大就交换它们两个。最后的数字应该最大得到升序排列。</p><p><img src="https://i.imgur.com/sTuENJp.png" alt></p><pre><code>package top.jgw;import java.util.Arrays;import java.util.Scanner;public class BubbleSort {     public static void main(String[] args) {           Scanner ra = new Scanner(System.in);           System.out.print(&quot;请输入10个数：&quot;);           int[] arr = new int[10];           for(int a=0;a&lt;10;a++){            arr[a] = ra.nextInt();            }      System.out.println(&quot;排序前的arr：&quot;+Arrays.toString(arr));       for(int i=arr.length-1;i&gt;0;i--){        for(int j=1;j&lt;=i;j++){            if(arr[j-1]&gt;arr[j]){                 int temp = arr[j-1];                 arr[j-1] = arr[j];                 arr[j] = temp;              }        }  }  System.out.println(&quot;排序后的arr ：&quot;+Arrays.toString(arr));  }}</code></pre><p>结论：冒泡排序是一种稳定的排序方法。　</p><ul><li>若文件初状为正序，则一趟起泡就可完成排序，排序码的比较次数为n-1，且没有记录移动，时间复杂度是O(n)</li><li>若文件初态为逆序，则需要n-1趟起泡，每趟进行n-i次排序码的比较，且每次比较都移动三次，比较和移动次数均达到最大值∶O(n2)</li><li>起泡排序平均时间复杂度为O(n2)</li></ul><h2 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h2><p>基本思想：每一步将一个待排序的记录，按其顺序码大小插入到前面已经排序的序列的合适位置（从后向前找到合适位置后），直到全部插入排序完为止。</p><p><img src="https://i.imgur.com/rrF3K6J.png" alt></p><pre><code>package top.jgw;import java.util.Arrays;import java.util.Scanner;public class InsertionSort {    public static void main(String[] args){        int i,j;        int temp=0;        Scanner ra=new Scanner(System.in);        System.out.print(&quot;请输入10个数：&quot;);        int arr[]=new int[10];        for(int a=0;a&lt;10;a++){            arr[a]=ra.nextInt();        }    System.out.println(&quot;排序前的arr: &quot;+Arrays.toString(arr));    for(i=1;i&lt;arr.length;i++){        temp=arr[i];        for(j=i-1;j&gt;=0 &amp;&amp; temp&lt;arr[j];j--){            arr[j+1]=arr[j];        }            arr[j+1]=temp;        }    System.out.println(&quot;排序后的arr：&quot;+Arrays.toString(arr));    }}</code></pre><p>结论：直接插入排序也是稳定的排序。<br>文件初态不同时，直接插入排序所耗费的时间有很大差异。若文件初态为正序，则每个待插入的记录只需要比较一次就能够找到合适的位置插入，故算法的时间复杂度为O(n)，这时最好的情况。若初态为反序，则第i个待插入记录需要比较i+1次才能找到合适位置插入，故时间复杂度为O(n2)，这时最坏的情况。</p><h2 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h2><p>基本思想：每一次排序都从待排序序列中选择一个最小元素放到已排好的序列的末端，重复此步骤可得到升序序列。</p><p><img src="https://i.imgur.com/Cmkm5Do.png" alt></p><pre><code>package top.jgw;import java.util.Arrays;import java.util.Scanner;public class SelectionSort {public static void main(String[] args){    Scanner ra=new Scanner(System.in);    System.out.print(&quot;请输入10个数: &quot;);    int arr[]=new int[10];    for(int a=0;a&lt;10;a++){        arr[a]=ra.nextInt();    }    System.out.println(&quot;排序前的arr: &quot;+Arrays.toString(arr));    int temp=0;    for(int i=0;i&lt;arr.length-1;i++){        for(int j=i+1;j&lt;arr.length;j++){            if(arr[i]&gt;arr[j]){                temp=arr[i];                arr[i]=arr[j];                arr[j]=temp;            }        }        }    System.out.println(&quot;排序后的arr: &quot;+Arrays.toString(arr));    }}</code></pre><p>结论：简单选择排序是不稳定的排序，时间复杂度：T(n)=O(n2)。</p><p><em>日后补充…</em></p><p>如果觉得有用，不如给个<a href="https://github.com/JiGuangwuu/JiGuangwuu.github.io" target="_blank" rel="noopener">Star Or Follow</a>，感谢。</p>]]></content>
      
      
      <categories>
          
          <category> 设计模式和数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sort </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>hexo＋next主题搭建GitHub blog干货教程</title>
      <link href="/2018/01/10/hexo/"/>
      <url>/2018/01/10/hexo/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本人开始并非使用next主题，这个大家可以去hexo官网<a href="https://hexo.io/themes/" target="_blank" rel="noopener">themes</a>处挑选自己喜欢的。<br>注意：点击主题预览图可以去预览下，点击主题名就可以去GitHub页面copy了。<br>但个人觉得next主题更好，bug少，拓展性强。好了，废话少说，进入正题。</p><h2 id="准备工作"><a href="#准备工作" class="headerlink" title="准备工作"></a>准备工作</h2><ul><li>注册github账号</li><li>安装node.js  </li><li>链接：<a href="https://pan.baidu.com/s/1mji9SmO" target="_blank" rel="noopener">https://pan.baidu.com/s/1mji9SmO</a> 密码：fjw1</li><li>安装git </li><li>链接：<a href="https://pan.baidu.com/s/1dGUlqEH" target="_blank" rel="noopener">https://pan.baidu.com/s/1dGUlqEH</a> 密码：q9ws<br>我的电脑是Windows10，其他你根据我提供的百度云链接下载即可。安装git时全打勾。</li></ul><h2 id="创建仓库"><a href="#创建仓库" class="headerlink" title="创建仓库"></a>创建仓库</h2><p>新建一个 你的用户名.github.io的仓库，比如说你的GitHub用户名是abc,那么你新建仓库名叫abc.github.io,你的博客搭建好之后访问的网站也就是 <a href="https://abc.github.io了。" target="_blank" rel="noopener">https://abc.github.io了。</a></p><p><img src="https://i.loli.net/2019/03/26/5c9a1bdf14b7a.png" alt></p><p><img src="https://i.loli.net/2019/03/26/5c9a1be09c749.png" alt><br>那怎么删除仓库呢？？？<br>打开settings</p><p><img src="https://i.loli.net/2019/03/26/5c9a1be6b70f2.png" alt></p><p><img src="https://i.loli.net/2019/03/26/5c9a1be31d9a3.png" alt></p><h2 id="创建博客根目录"><a href="#创建博客根目录" class="headerlink" title="创建博客根目录"></a>创建博客根目录</h2><p>在一个磁盘里创建一个文件夹，比如我，在D盘创建了一个blog文件夹。</p><h1 id="正式工作"><a href="#正式工作" class="headerlink" title="正式工作"></a>正式工作</h1><h2 id="配置SSH-Key"><a href="#配置SSH-Key" class="headerlink" title="配置SSH Key"></a>配置SSH Key</h2><p>桌面右键打开git bash here,输入</p><blockquote><p> $ cd ~/. ssh // 检查本机已存在的 ssh 密钥</p></blockquote><p>再接着输入</p><blockquote><p>ssh-keygen -t rsa -C “你的邮件地址”</p></blockquote><p>然后连续按三次回车，会生成id_rsa.pub文件，用记事本打开它，然后全部复制即可，待会要用。这个文件的地址：C:\Users\Administrator.ssh<br>打开你的GitHub主页，打开设置-&gt;Deploy keys-&gt;Add deploy key.<br>这里名称随便取，在下面粘贴内容保存即可，有需要打勾就打勾。</p><p>我们回来测试下是否把SSH配置成功了。<br>继续在bash里输入</p><blockquote><p>$ ssh -T <a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a></p></blockquote><p>如果提示 Are you sure you want to continue connecting (yes/no)? ，输入yes，然后会看到 successfully authenticated,but github…..<br>看到这个意味着已成功！</p><h2 id="配置信息"><a href="#配置信息" class="headerlink" title="配置信息"></a>配置信息</h2><blockquote><p> $ git config –global user.name “xxx”// 你的github用户名，比如上面的abc<br>$ git config –global user.email  “<a href="mailto:xxx@qq.com" target="_blank" rel="noopener">xxx@qq.com</a>“// 填写你的github注册邮箱</p></blockquote><h1 id="使用hexo"><a href="#使用hexo" class="headerlink" title="使用hexo"></a>使用hexo</h1><h2 id="安装hexo"><a href="#安装hexo" class="headerlink" title="安装hexo"></a>安装hexo</h2><p>我们打开cmd命令行，输入</p><blockquote><p> npm install -g hexo</p></blockquote><p>这里可能会很慢，所以推荐使用淘宝镜像。</p><blockquote><p>安装：<code>npm install -g cnpm --registry=https://registry.npm.taobao.org</code> </p><p>验证是否安装成功使用：<code>cnpm -v</code><br>这里使用使用： <code>cnpm install -g hexo安装</code>hexo</p><p>验证Hexo是否安装成功使用：<code>hexo -v</code> </p></blockquote><h2 id="初始化hexo"><a href="#初始化hexo" class="headerlink" title="初始化hexo"></a>初始化hexo</h2><p>打开我们之前创建的文件夹，比如我的blog，右击鼠标，打开git bash here,输入</p><blockquote><p>$ hexo init</p></blockquote><p>我们的文件夹会自动下载一些文件到这个blog目录里。</p><p>继续输入</p><blockquote><p>$ hexo g<br>$ hexo s</p></blockquote><p>hexo s是指启动服务，成功打开后会有提示，登录localhost:4000即可看到初始页面，到这里你的blog就基本搭建好了。</p><h2 id="新建文章"><a href="#新建文章" class="headerlink" title="新建文章"></a>新建文章</h2><p>在bash里输入</p><blockquote><p> $ hexo new post “文章名”</p></blockquote><p>然后去blog/source/_posts就可以看到</p><h2 id="上传到GitHub"><a href="#上传到GitHub" class="headerlink" title="上传到GitHub"></a>上传到GitHub</h2><p>配置_config.yml中的deploy部分，注意这里的_config.yml文件是blog根目录，并非themes里的同名文件。<br>配置如下(xxx为你的GitHub名)</p><blockquote><p> deploy:<br>  type: git<br>  repository: <a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a>:xxx/xxx.github.io.git<br>  branch: master</p></blockquote><p>再次注意：关于_config.yml文件的配置，冒号后一定要加个空格，否则就无法部署了。</p><p>一切完成后在bash中继续输入</p><blockquote><p> npm install hexo-deployer-git –save #这里是安装插件，不然无法deploy</p></blockquote><p>然后输入以下就可以了</p><blockquote><p> hexo clean &amp;&amp; hexo g &amp;&amp; hexo d</p></blockquote><p>成功后会提示：Deploy done：git  证明成功啦。这是打开你的xxx.github.io就可以看到网页啦！</p><h2 id="主题设置"><a href="#主题设置" class="headerlink" title="主题设置"></a>主题设置</h2><p>打开<a href="http://theme-next.iissnan.com/getting-started.html" target="_blank" rel="noopener">next使用文档</a>有详细的教程。<br>主题教程以及拓展：<br><img src="https://i.imgur.com/lotL1do.png" alt></p><h1 id="绑定个性域名"><a href="#绑定个性域名" class="headerlink" title="绑定个性域名"></a>绑定个性域名</h1><h2 id="申请域名"><a href="#申请域名" class="headerlink" title="申请域名"></a>申请域名</h2><p>在阿里云或腾讯云申请域名。我是在阿里云申请的，实名认证很快，推荐。</p><h2 id="解析域名"><a href="#解析域名" class="headerlink" title="解析域名"></a>解析域名</h2><p>按我的内容来即可。<br><img src="https://i.loli.net/2019/03/26/5c9a1b95b0be7.png" alt></p><h2 id="部署域名"><a href="#部署域名" class="headerlink" title="部署域名"></a>部署域名</h2><p>在blog根目录的source文件夹中新建无后缀文件 CNAME。里面内容只写上你的域名即可，注意不需要www<br>按之前的顺序deploy即可</p><p>如果觉得有用，不如给个<a href="https://github.com/JiGuangwuu/JiGuangwuu.github.io" target="_blank" rel="noopener">Star Or Follow</a>，感谢。</p>]]></content>
      
      
      <categories>
          
          <category> 技术栈 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> hexo </tag>
            
            <tag> blog </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>出发永远是美好的一件事</title>
      <link href="/2018/01/07/%E5%87%BA%E5%8F%91/"/>
      <url>/2018/01/07/%E5%87%BA%E5%8F%91/</url>
      
        <content type="html"><![CDATA[<p>去做就是啦。</p><p>总结了一七再去展望一八，哈哈我是真想做个技术流人才然后……<br>忙着结束手头上的事情，项目等等，想着去全身心投入到学习中，这是促进我去搭建自己的独立博客的初衷，去学习，去整理，去分享。<br>大学也浪了大半了，两次六级考试都几乎零准备，湖泊你说咋写来着？</p><p>要说新年计划的话，最近打算好好总结Java的知识，以及对基本框架，数据结构与算法的学习，对博客的维护与优化，还有考研的准备！</p><p>新年快乐！<br><img src="https://i.loli.net/2018/01/07/5a5211e581fdc.png" alt></p>]]></content>
      
      
      <categories>
          
          <category> 逆旅 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> mood </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
